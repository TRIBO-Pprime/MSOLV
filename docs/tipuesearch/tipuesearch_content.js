var tipuesearch = {"pages":[{"title":" MSOLV-fortran ","loc":"index.html","text":"MSOLV-fortran Table of Contents Brief description Requested libraries Example of use Data-format Limitations Prerequesites Wrappers Make Full description License Brief description A generic API for using Sparse Direct Solvers, written in modern Fortran. It is designed to work with: MUMPS - MU ltifrontal M assively P arallel sparse direct S olver 1 UMFPACK - U nsymmetric M ulti F rontal method solver 2 SuperLU - LU decomposition with partial pivoting and triangular system solves through forward and back substitution 3 MA48 - Sparse unsymmetric system solver 4 top Requested libraries Generic librefblas.a liblapack.a MUMPS libmetis.a libmpiseq.a libmumps_common.a libdmumps.a UMFPACK libamd.a libcamd.a libcolamd.a libccolamd.a libcholmod.a libsuitesparseconfig.a libumfpack.a SuperLU libsuperlu.a MA48 libhsl_ma48.a top Example of use test_solvers proposes to test the solvers on two systems, a very small one and a \"bigger\" one. Some solvers have an \"analyze\" step during which symbolic factorization is performed.\nHence if the sparsity of a new system does not change much, the symbolic factorisation is reused for the numerical factorization. To assess the time gained, after the first resolution other\nresolution are proposed with the same matrix pattern.\nAfter each resolution, the error is assessed remultipying the solution by the matrix and comparing it to the right-hand side. top Data format By default, UMFPACK and SuperLU are configured to read C ompressed C olumn Harwell/Boeing formatted data, MUMPS reads elemental CC formatted data, MA48 reads sparse triplet formatted data. top Limitations The package MUSST is developped to handle some lubrication problems thanks to a multiscale approach. During the processe, sparse linear systems are solved either on concurrent threads or using all threads. In the first case, 'OpenMP' is not usefull because each thread is dedicated to the resolution of its own bunch of systems ( B ottom S cale systems). In the second case, 'OpenMP' is desirable to speed up the resolution ( T op S cale systems). For the moment, MUSST isn't designed for distributed shared memory architectures. \nTherefore the following choices are made: MUMPS is built with its sequential configuration ( OpenMP , but not MPI ). It is dedicated to TS systems. BLAS is built without OpenMP UMFPACK , SuperLU and MA48 are built without OpenMP . They are dedicated to BS systems. top Prerequesites The solver libraries must be downloaded and statically compiled together with their prerequisites: UMFPACK BLAS , LAPACK MUMPS BLAS , SCOTCH SuperLU BLAS MA48 BLAS top Wrappers UMFPACK A module mumfpack has been developped by Ladislav Hanyk . It has been checked with UMFPACK 5.6.2, but it also works fine here with UMFPACK 5.7.6. MUMPS A module mumps_wrapper is created with the content of dmumps_struc.h provided by MUMPS and it includes mpif.h , also provided by MUMPS. It is to be noticed that almost all global variables are deactivated in mpif.h . SuperLU A module sulu_wrapper is created from scratch because following SuperLU fortran examples (with the wrapper provided by SuperLU), we were not able to continuously solve systems with systematic memory release. As a consequence, the memory needed by MUSST increased untill the programs would stop. MA48 In its double flavour, HSL_MA48 needs 3 files: common90.f90 , ddeps90.f90 and hsl_ma48d.f90 , renamed hsl_common90.f90 and hsl_ddeps90.f90 for the two first.\n    In order to work with arrays independently from the solvers, the global solver type MAT_SOLV contains the system arrays –like eltptr , eltvar , a_elt , etc.– pointed by a solver type, for instance ZD11_TYPE . Therefore, in version 3.3 of HSL_MA48 , the attribute allocatable (in ZD11_TYPE) of row , col , ptr and val is changed to pointer . top Make General syntax: make clean all \"DEBUG=[yes,'']\" \"GPROF=[yes,'']\" Examples: first clean all, then make the 'debug' executable prg for profiling make clean\nmake all \"DEBUG=yes\" \"GPROF=yes\" just build the modified sources, then make a productive executable make all top Full description The aim of the present project is to provide generic subroutines for the direct full resolution of sparse linear systems: solver initialization call solve_syst ( mat = system_type , step = 'ini' ) system analyze call solve_syst ( mat = system_type , step = 'ana' ) system factorization call solve_syst ( mat = system_type , step = 'fac' ) system solution call solve_syst ( mat = system_type , step = 'sol' ) memory release call solve_syst ( mat = system_type , step = 'fre' ) solver finalization call solve_syst ( mat = system_type , step = 'end' ) system_type is of complex type MAT_SOLV built to deal with MUMPS , UMFPACK , SuperLU and MA48 requirements. top License CeCILL-C license ↩ GNU GPL ↩ New BSD-3 ↩ HSL software is strictly intended for Personal academic use on the download page ↩ Developer Info Arthur Francisco - Noël Brunetière","tags":"home"},{"title":"dmumps_struc.f90 – MSOLV-fortran","loc":"sourcefile/dmumps_struc.f90.html","text":"Files dependent on this one sourcefile~~dmumps_struc.f90~~AfferentGraph sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mumps_wrapper Source Code dmumps_struc.f90 Source Code module mumps_wrapper ! !  This file is part of MUMPS 5.1.2, released !  on Mon Oct  2 07:37:01 UTC 2017 ! ! !  Copyright 1991-2017 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria, !  University of Bordeaux. ! !  This version of MUMPS is provided to you free of charge. It is !  released under the CeCILL-C license: !  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html ! include 'mpif.f90' INCLUDE 'dmumps_root.f90' TYPE DMUMPS_STRUC SEQUENCE ! ! This structure contains all parameters ! for the interface to the user, plus internal ! information from the solver ! ! ***************** ! INPUT PARAMETERS ! ***************** !    ----------------- !    MPI Communicator !    ----------------- INTEGER :: COMM !    ------------------ !    Problem definition !    ------------------ !    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, !        SYM=2 general symmetric) !    Type of parallelism (PAR=1 host working, PAR=0 host not working) INTEGER :: SYM , PAR INTEGER :: JOB !    -------------------- !    Order of Input matrix !    -------------------- INTEGER :: N ! !    ---------------------------------------- !    Assembled input matrix : User interface !    ---------------------------------------- INTEGER :: NZ ! Standard integer input + bwd. compat. INTEGER ( 8 ) :: NNZ ! 64-bit integer input DOUBLE PRECISION , DIMENSION (:), POINTER :: A INTEGER , DIMENSION (:), POINTER :: IRN , JCN DOUBLE PRECISION , DIMENSION (:), POINTER :: COLSCA , ROWSCA , pad0 ! !       ------------------------------------ !       Case of distributed assembled matrix !       matrix on entry: !       ------------------------------------ INTEGER :: NZ_loc ! Standard integer input + bwd. compat. INTEGER :: pad1 INTEGER ( 8 ) :: NNZ_loc ! 64-bit integer input INTEGER , DIMENSION (:), POINTER :: IRN_loc , JCN_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: A_loc , pad2 ! !    ---------------------------------------- !    Unassembled input matrix: User interface !    ---------------------------------------- INTEGER :: NELT , pad3 INTEGER , DIMENSION (:), POINTER :: ELTPTR INTEGER , DIMENSION (:), POINTER :: ELTVAR DOUBLE PRECISION , DIMENSION (:), POINTER :: A_ELT , pad4 ! !    --------------------------------------------- !    Symmetric permutation : !               PERM_IN if given by user (optional) !    --------------------------------------------- INTEGER , DIMENSION (:), POINTER :: PERM_IN ! ! ! ****************** ! INPUT/OUTPUT data ! ****************** !    -------------------------------------------------------- !    RHS / SOL_loc !    ------------- !       right-hand side and solution !    ------------------------------------------------------- DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS , REDRHS DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_SPARSE DOUBLE PRECISION , DIMENSION (:), POINTER :: SOL_loc INTEGER , DIMENSION (:), POINTER :: IRHS_SPARSE INTEGER , DIMENSION (:), POINTER :: IRHS_PTR INTEGER , DIMENSION (:), POINTER :: ISOL_loc INTEGER :: LRHS , NRHS , NZ_RHS , LSOL_loc , LREDRHS INTEGER :: pad5 !    ---------------------------- !    Control parameters, !    statistics and output data !    --------------------------- INTEGER :: ICNTL ( 40 ) INTEGER :: INFO ( 40 ) INTEGER :: INFOG ( 40 ) DOUBLE PRECISION :: COST_SUBTREES DOUBLE PRECISION :: CNTL ( 15 ) DOUBLE PRECISION :: RINFO ( 40 ) DOUBLE PRECISION :: RINFOG ( 40 ) !    --------------------------------------------------------- !    Permutations computed during analysis: !       SYM_PERM: Symmetric permutation !       UNS_PERM: Column permutation (optional) !    --------------------------------------------------------- INTEGER , DIMENSION (:), POINTER :: SYM_PERM , UNS_PERM ! !    ----- !    Schur !    ----- INTEGER :: NPROW , NPCOL , MBLOCK , NBLOCK INTEGER :: SCHUR_MLOC , SCHUR_NLOC , SCHUR_LLD INTEGER :: SIZE_SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR_CINTERFACE INTEGER , DIMENSION (:), POINTER :: LISTVAR_SCHUR !    ------------------------------------- !    Case of distributed matrix on entry: !    DMUMPS potentially provides mapping !    ------------------------------------- INTEGER , DIMENSION (:), POINTER :: MAPPING !    -------------- !    Version number !    -------------- CHARACTER ( LEN = 30 ) :: VERSION_NUMBER !    ----------- !    Out-of-core !    ----------- CHARACTER ( LEN = 255 ) :: OOC_TMPDIR CHARACTER ( LEN = 63 ) :: OOC_PREFIX !    ------------------------------------------ !    To save the matrix in matrix market format !    ------------------------------------------ CHARACTER ( LEN = 255 ) :: WRITE_PROBLEM !    ----------- !    Save/Restore !    ----------- CHARACTER ( LEN = 255 ) :: SAVE_DIR CHARACTER ( LEN = 255 ) :: SAVE_PREFIX CHARACTER ( LEN = 7 ) :: pad8 ! ! ! ********************** ! INTERNAL Working data ! ********************* INTEGER ( 8 ) :: KEEP8 ( 150 ), MAX_SURF_MASTER INTEGER :: INST_Number !       For MPI INTEGER :: COMM_NODES , MYID_NODES , COMM_LOAD INTEGER :: MYID , NPROCS , NSLAVES INTEGER :: ASS_IRECV INTEGER :: LBUFR INTEGER :: LBUFR_BYTES INTEGER , DIMENSION (:), POINTER :: BUFR !       IS is used for the factors + workspace for contrib. blocks INTEGER , DIMENSION (:), POINTER :: IS !       IS1 (maxis1) contains working arrays computed !       and used only during analysis INTEGER , DIMENSION (:), POINTER :: IS1 !       For analysis/facto/solve phases INTEGER :: MAXIS1 , Deficiency INTEGER :: KEEP ( 500 ) !       The following data/arrays are computed during the analysis !       phase and used during the factorization and solve phases. INTEGER :: LNA INTEGER :: NBSA INTEGER , POINTER , DIMENSION (:) :: STEP , NE_STEPS , ND_STEPS !  Info for pruning tree INTEGER , POINTER , DIMENSION (:) :: Step2node !  --------------------- INTEGER , POINTER , DIMENSION (:) :: FRERE_STEPS , DAD_STEPS INTEGER , POINTER , DIMENSION (:) :: FILS , FRTPTR , FRTELT INTEGER ( 8 ), POINTER , DIMENSION (:) :: PTRAR INTEGER , POINTER , DIMENSION (:) :: NA , PROCNODE_STEPS !       The two pointer arrays computed in facto and used by the solve !          (except the factors) are PTLUST_S and PTRFAC. INTEGER , DIMENSION (:), POINTER :: PTLUST_S INTEGER ( 8 ), DIMENSION (:), POINTER :: PTRFAC !       main real working arrays for factorization/solve phases DOUBLE PRECISION , DIMENSION (:), POINTER :: S !       Information on mapping INTEGER , DIMENSION (:), POINTER :: PROCNODE !       Input matrix ready for numerical assembly !           -arrowhead format in case of assembled matrix !           -element format otherwise INTEGER , DIMENSION (:), POINTER :: INTARR DOUBLE PRECISION , DIMENSION (:), POINTER :: DBLARR !       Element entry: internal data INTEGER :: NELT_loc , LELTVAR INTEGER , DIMENSION (:), POINTER :: ELTPROC !       Candidates and node partitionning INTEGER , DIMENSION (:,:), POINTER :: CANDIDATES INTEGER , DIMENSION (:), POINTER :: ISTEP_TO_INIV2 INTEGER , DIMENSION (:), POINTER :: FUTURE_NIV2 INTEGER , DIMENSION (:,:), POINTER :: TAB_POS_IN_PERE LOGICAL , DIMENSION (:), POINTER :: I_AM_CAND !       For heterogeneous architecture INTEGER , DIMENSION (:), POINTER :: MEM_DIST !       Compressed RHS INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_ROW LOGICAL :: POSINRHSCOMP_COL_ALLOC , pad11 INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_COL DOUBLE PRECISION , DIMENSION (:), POINTER :: RHSCOMP !       Info on the subtrees to be used during factorization DOUBLE PRECISION , DIMENSION (:), POINTER :: MEM_SUBTREE DOUBLE PRECISION , DIMENSION (:), POINTER :: COST_TRAV INTEGER , DIMENSION (:), POINTER :: MY_ROOT_SBTR INTEGER , DIMENSION (:), POINTER :: MY_FIRST_LEAF INTEGER , DIMENSION (:), POINTER :: MY_NB_LEAF INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST_SEQ INTEGER , DIMENSION (:), POINTER :: SBTR_ID INTEGER , DIMENSION (:), POINTER :: SCHED_DEP INTEGER , DIMENSION (:), POINTER :: SCHED_GRP INTEGER , DIMENSION (:), POINTER :: SCHED_SBTR INTEGER , DIMENSION (:), POINTER :: CROIX_MANU DOUBLE PRECISION , DIMENSION (:), POINTER :: WK_USER INTEGER :: NBSA_LOCAL INTEGER :: LWK_USER !    Internal control array DOUBLE PRECISION :: DKEEP ( 230 ) !    For simulating parallel out-of-core stack. DOUBLE PRECISION , DIMENSION (:), POINTER :: CB_SON_SIZE !    Instance number used/managed by the C/F77 interface INTEGER :: INSTANCE_NUMBER !    OOC management data that must persist from factorization to solve. INTEGER :: OOC_MAX_NB_NODES_FOR_ZONE INTEGER , DIMENSION (:,:), POINTER :: OOC_INODE_SEQUENCE INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_SIZE_OF_BLOCK INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_VADDR INTEGER , DIMENSION (:), POINTER :: OOC_TOTAL_NB_NODES INTEGER , DIMENSION (:), POINTER :: OOC_NB_FILES INTEGER :: OOC_NB_FILE_TYPE , pad12 INTEGER , DIMENSION (:), POINTER :: OOC_FILE_NAME_LENGTH CHARACTER , DIMENSION (:,:), POINTER :: OOC_FILE_NAMES !    Indices of nul pivots INTEGER , DIMENSION (:), POINTER :: PIVNUL_LIST !    Array needed to manage additionnal candidate processor INTEGER , DIMENSION (:,:), POINTER :: SUP_PROC , pad14 !    Lists of nodes where processors work. Built/used in solve phase. INTEGER , DIMENSION (:), POINTER :: IPTR_WORKING , WORKING !    Root structure(internal) TYPE ( DMUMPS_ROOT_STRUC ) :: root !    Low-rank INTEGER , POINTER , DIMENSION (:) :: LRGROUPS INTEGER :: NBGRP , pad13 !    Pointer encoding for FDM_F data CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: FDM_F_ENCODING !    Pointer array encoding BLR factors pointers CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: BLRARRAY_ENCODING !    Multicore INTEGER :: LPOOL_AFTER_L0_OMP , LPOOL_BEFORE_L0_OMP INTEGER :: L_PHYS_L0_OMP INTEGER :: L_VIRT_L0_OMP INTEGER :: LL0_OMP_MAPPING , pad15 INTEGER ( 8 ) :: THREAD_LA ! Pool before L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_BEFORE_L0_OMP ! Pool after L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_AFTER_L0_OMP ! Subtrees INTEGER , DIMENSION (:), POINTER :: PHYS_L0_OMP ! Amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP ! From heaviest to lowest subtree INTEGER , DIMENSION (:), POINTER :: PERM_L0_OMP ! To get leafs in global pool INTEGER , DIMENSION (:), POINTER :: PTR_LEAFS_L0_OMP ! Mapping of the subtrees INTEGER , DIMENSION (:), POINTER :: L0_OMP_MAPPING ! for RR on root DOUBLE PRECISION , DIMENSION (:), POINTER :: SINGULAR_VALUES INTEGER :: NB_SINGULAR_VALUES ! To know if OOC files are associated to a saved and so if they should be removed. LOGICAL :: ASSOCIATED_OOC_FILES END TYPE DMUMPS_STRUC endmodule mumps_wrapper","tags":""},{"title":"mod_solver.f90 – MSOLV-fortran","loc":"sourcefile/mod_solver.f90.html","text":"This file depends on sourcefile~~mod_solver.f90~~EfferentGraph sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_sort.f90 mod_sort.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_num_par.f90 sourcefile~mod_sort.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_solver.f90~~AfferentGraph sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules solver Source Code mod_solver.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **Api for different sparse matrix solvers** !  </span> module solver use iso_c_binding , only : C_PTR , C_NULL_PTR , C_ASSOCIATED use data_arch , only : I4 , I8 , R8 , EPS_R8 , HIG_R8 use num_param , only : OPU , SOLV_MESS , NO_MESS , PRINT_MESS use sort_arrays , only : sort_int_1real , sort_int_1int_1real !------------------------------------------------- use hsl_ma48_double !------------------------------------------------- use sulu_wrapper , MAT_SULU => SULU_ENV , & SULU_SAMEPATTERN => SAMEPATTERN , & SULU_FACTORED => FACTORED , & SULU_DOFACT => DOFACT !------------------------------------------------- use mumps_wrapper , MAT_MUMP => DMUMPS_STRUC !------------------------------------------------- use mumfpack , only : UMFPACK_CONTROL , & UMFPACK_STATUS , & UMFPACK_INFO , & UMFPACK_PRL , & UMFPACK_IRSTEP , & UMFPACK_NUMERIC_SIZE_ESTIMATE , & UMFPACK_PEAK_MEMORY_ESTIMATE , & UMFPACK_SIZE_OF_UNIT , & UMFPACK_DI_DEFAULTS , & UMFPACK_DI_REPORT_CONTROL , & UMFPACK_DI_FREE_NUMERIC , & UMFPACK_DI_FREE_SYMBOLIC , & UMFPACK_DI_REPORT_INFO , & S_UMFPACK_DI_SYMBOLIC , & S_UMFPACK_DI_NUMERIC , & S_UMFPACK_DI_SOLVE , & UMFPACK_A !------------------------------------------------- implicit none type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48 type MAT_UMFP !! <span style=\"color:green\">All the stuff needed by *UMFPACK*</span> type ( c_ptr ) :: c_symbolic type ( c_ptr ) :: c_numeric real ( kind = R8 ), dimension ( 0 : UMFPACK_CONTROL - 1 ) :: c_control real ( kind = R8 ), dimension ( 0 : UMFPACK_INFO - 1 ) :: c_info endtype MAT_UMFP type MAT_SOLV !! <span style=\"color:green\">MUSST high level system type</span> integer ( kind = I4 ) :: slv_t !! *solver type* logical ( kind = I4 ) :: first = . true . !! *analysis of the system to be done?* integer ( kind = I4 ) :: nn !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: nt !! *number of **a priori** non-zero terms in the matrix* integer ( kind = I4 ) :: nz !! *number of non-zero terms in the matrix* integer ( kind = I4 ) :: nvar !! *eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices)* integer ( kind = I4 ) :: code !! *error code*   [not used yet] real ( kind = R8 ) :: error !! *error value*  [not used yet] character ( len = 1024 ) :: mess !! *message*      [not used yet] !..................................................... type ( MAT_MUMP ) :: matmump !! *matrices for mumps solver* type ( MAT_MA48 ) :: matma48 !! *matrices for ma48 solver* type ( MAT_SULU ) :: matsulu !! *matrices for SuperLu solver* type ( MAT_UMFP ) :: matumfp !! *matrices for Umfpack solver* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *rows in assembled matrix* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *element rows pointer* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *unassembled rigidity matrix* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: irow !! *line number* integer ( kind = I4 ), dimension (:), allocatable :: jcol !! *column number* integer ( kind = I4 ), dimension (:), allocatable :: jptr !! *line pointer* !..................................................... real ( kind = R8 ), dimension (:), allocatable :: b !! *right hand side vector* real ( kind = R8 ), dimension (:), allocatable :: x !! *unknwon vector* endtype MAT_SOLV !< <span style=\"color:green\">MUSST multiscale high level solver type</span> !  @note ```MS_MAT_SOLV``` is needed by MUSST, but it is useless for the present module ! type MS_MAT_SOLV type ( MAT_SOLV ) :: ts_mat !! *top-scale solver type matrices* type ( MAT_SOLV ), dimension (:), allocatable :: bs_mat !! *bottom-scale solver type matrices (table)* integer ( kind = I4 ), dimension (:), allocatable :: ass_loc_in_mat !! *table for assembly location (for parallel computation)* endtype ms_mat_solv ! Solver types integer ( kind = I4 ), parameter :: MA48 = 0 !! *code for     Ma48 solver type* integer ( kind = I4 ), parameter :: SULU = 1 !! *code for SUPER LU solver type* integer ( kind = I4 ), parameter :: MUMP = 2 !! *code for    MUMPS solver type* integer ( kind = I4 ), parameter :: UMFP = 3 !! *code for  UMFPACK solver type* ! What solver to use for bottom- or top- scale grids integer ( kind = I4 ) :: SOLVER_BS = - 1 !! *solver used for bottom scale grids* [not used by the present module] integer ( kind = I4 ) :: SOLVER_TS = - 1 !! *solver used for top scale grids* [not used by the present module] contains !========================================================================================= !< @note General hat subroutine that handles the resolution steps:      <br/> !  * ```ini``` solver initialization                                    <br/> !  * ```ana``` solver analyzis when it's proposed by the solver         <br/> !  * ```fac``` solver factorization                                     <br/> !  * ```sol``` solver solution                                          <br/> !  * ```fre``` solver memory release when it's proposed by the solver   <br/> !  * ```end``` solver end !----------------------------------------------------------------------------------------- subroutine solve_syst ( mat , step ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* character ( len =* ), intent ( in ) :: step !! *'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver* if ( index ( step , 'ini' ) /= 0 ) then ; call init_solver ( mat ) ; return ; endif if ( index ( step , 'ana' ) /= 0 ) then ; call analyse_solver ( mat ) ; return ; endif if ( index ( step , 'fac' ) /= 0 ) then ; call factorize_solver ( mat ) ; return ; endif if ( index ( step , 'sol' ) /= 0 ) then ; call solution_solver ( mat ) ; return ; endif if ( index ( step , 'fre' ) /= 0 ) then ; call freefact_solver ( mat ) ; return ; endif if ( index ( step , 'end' ) /= 0 ) then ; call close_solver ( mat ) ; return ; endif stop 'Bad step chosen in SOLVE_SYST' return endsubroutine solve_syst !========================================================================================= !> @note Subroutine to initialize the matrices of the solver !----------------------------------------------------------------------------------------- subroutine init_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr ! allocation of the system vectors: rhs and unknown allocate ( mat % b ( mat % nn ), mat % x ( mat % nn ) ) mat % b = HIG_R8 mat % x = HIG_R8 ! check solver type select case ( mat % slv_t ) case ( MA48 ) call ma48_initialize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matma48 % ctrl % wp = - 1 mat % matma48 % ctrl % mp = - 1 mat % matma48 % ctrl % ldiag = - 1 case ( PRINT_MESS :) mat % matma48 % ctrl % ldiag = + 2 endselect case ( MUMP ) call mpi_init ( ierr ) mat % matmump % comm = MPI_COMM_WORLD mat % matmump % job = - 1 ! initialisation mat % matmump % sym = 0 ! no symetry mat % matmump % par = 1 ! MPI, host working call dmumps ( mat % matmump ) mat % matmump % icntl ( 5 ) = 1 ! Specify element entry : elemental matrices if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'MUMP error, INIT_SOLVER' endif select case ( SOLV_MESS ) case ( NO_MESS ) mat % matmump % icntl ( 4 ) = 1 ! error output only case ( PRINT_MESS :) mat % matmump % icntl ( 4 ) = 3 ! all error output endselect case ( SULU ) call init_superlu ( sulu = mat % matsulu ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matsulu % options % PrintStat = 0 case ( PRINT_MESS :) mat % matsulu % options % PrintStat = 1 endselect case ( UMFP ) mat % matumfp % c_numeric = C_NULL_PTR call umfpack_di_defaults ( mat % matumfp % c_control ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matumfp % c_control ( UMFPACK_PRL ) = 1 case ( PRINT_MESS :) mat % matumfp % c_control ( UMFPACK_PRL ) = 2 endselect call umfpack_di_report_control ( mat % matumfp % c_control ) case default stop 'Unknown solver type, INIT_SOLVER' endselect return endsubroutine init_solver !========================================================================================= !> @note Subroutine to analyse, factorize (symbolic) the matrix of the system !----------------------------------------------------------------------------------------- subroutine analyse_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) mat % matma48 % zmat % row => mat % irow mat % matma48 % zmat % col => mat % jcol mat % matma48 % zmat % val => mat % a_elt mat % matma48 % zmat % n = mat % nn mat % matma48 % zmat % m = mat % nn mat % matma48 % zmat % ne = mat % nz call ma48_analyse ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & ainfo = mat % matma48 % ainf , & finfo = mat % matma48 % finf ) if ( mat % matma48 % ainf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_analyse with ainfop%flag = ' , mat % matma48 % ainf % flag stop endif case ( MUMP ) mat % matmump % eltptr => mat % eltptr mat % matmump % eltvar => mat % eltvar mat % matmump % a_elt => mat % a_elt mat % matmump % rhs => mat % b mat % matmump % n = mat % nn mat % matmump % nelt = mat % ne mat % matmump % job = 1 ! performs the analysis call dmumps ( mat % matmump ) case ( SULU ) mat % matsulu % irow => mat % irow mat % matsulu % jptr => mat % jptr mat % matsulu % a_elt => mat % a_elt mat % matsulu % b => mat % b mat % matsulu % n = mat % nn mat % matsulu % nz = mat % nz mat % matsulu % nrhs = 1 mat % matsulu % first = . true . call prep_superlu ( sulu = mat % matsulu ) case ( UMFP ) call s_umfpack_di_symbolic ( n_row = mat % nn , & n_col = mat % nn , & Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'ANALYSE_SOLVER : unknown solver type' endselect return endsubroutine analyse_solver !========================================================================================= !> @note Subroutine to factorize the matrix of the system !----------------------------------------------------------------------------------------- subroutine factorize_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) call ma48_factorize ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & finfo = mat % matma48 % finf , & fast = mat % matma48 % fast ) if ( mat % matma48 % finf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_factorize with finfo%flag = ' , mat % matma48 % finf % flag stop endif case ( MUMP ) mat % matmump % job = 2 call dmumps ( mat % matmump ) case ( SULU ) ! Just factorize once, in the case that the matrix doesn't change much if ( mat % matsulu % first ) call fact_superlu ( sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! first release memory call s_umfpack_di_numeric ( Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Numeric = mat % matumfp % c_numeric , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'Unknown solver type, FACTORIZE_SOLVER' endselect return endsubroutine factorize_solver !========================================================================================= !> @note Subroutine to solve the system [A]\\{x\\} = \\{b\\} (sparse A) !----------------------------------------------------------------------------------------- subroutine solution_solver ( mat ) implicit none type ( MAT_SOLV ), target , intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr select case ( mat % slv_t ) case ( MA48 ) call ma48_solve ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & rhs = mat % b , & x = mat % x , & control = mat % matma48 % ctrl , & sinfo = mat % matma48 % sinf , & resid = mat % matma48 % resid , & error = mat % error ) case ( MUMP ) mat % matmump % job = 3 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error in SOLUTION_SOLVER' endif ! solution has been assembled on the host if ( mat % matmump % myid == 0 ) then mat % x ( 1 : mat % nn ) = mat % matmump % rhs ( 1 : mat % nn ) endif case ( SULU ) call solv_superlu ( sol_x = mat % x , & sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) mat % matsulu % first = . false . case ( UMFP ) ! Numeric factors must exist if (. not . C_ASSOCIATED ( mat % matumfp % c_numeric )) call solve_syst ( mat , 'fac' ) mat % matumfp % c_control ( UMFPACK_IRSTEP ) = 0 ! solve ax=b, without iterative refinement ! If you want to evaluate the required RAM (Go) ! write(*,*) mat%matumfp%c_info(UMFPACK_PEAK_MEMORY_ESTIMATE)/mat%matumfp%c_info(UMFPACK_SIZE_OF_UNIT)/1e9 ! write(*,*) sizeof(mat%a_elt)/1e9 call s_umfpack_di_solve ( sys = UMFPACK_A , & x = mat % x , & b = mat % b , & numeric = mat % matumfp % c_numeric , & control = mat % matumfp % c_control , & info = mat % matumfp % c_info ) if ( mat % matumfp % c_info ( UMFPACK_STATUS ) < 0 ) then write ( OPU , * ) 'error occurred in umfpack_di_solve: ' , mat % matumfp % c_info ( UMFPACK_STATUS ) stop 'Error in SOLUTION_SOLVER' endif case default stop 'Unknown solver type, SOLUTION_SOLVER' endselect return endsubroutine solution_solver !========================================================================================= !> @note Subroutine to free the factors if applicable !----------------------------------------------------------------------------------------- subroutine freefact_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) continue case ( MUMP ) continue case ( SULU ) call free_superlu () case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization case default stop 'unknown solver type, FREEFACT_SOLVER' endselect return endsubroutine freefact_solver !========================================================================================= !> @note Subroutine to close the solver !----------------------------------------------------------------------------------------- subroutine close_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr deallocate ( mat % eltptr ) deallocate ( mat % eltvar ) select case ( mat % slv_t ) case ( MA48 ) nullify ( mat % matma48 % zmat % row ) nullify ( mat % matma48 % zmat % col ) nullify ( mat % matma48 % zmat % val ) call ma48_finalize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & info = ierr ) deallocate ( mat % b , mat % x ) case ( MUMP ) if ( mat % matmump % myid == 0 ) then nullify ( mat % matmump % rhs ) nullify ( mat % matmump % eltptr ) nullify ( mat % matmump % eltvar ) nullify ( mat % matmump % a_elt ) endif ! destroy the instance (deallocate internal data structures) mat % matmump % job = - 2 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error MUMP in close_solver' endif call mpi_finalize ( ierr ) deallocate ( mat % b , mat % x ) case ( SULU ) call close_superlu ( sulu = mat % matsulu ) nullify ( mat % matsulu % b ) nullify ( mat % matsulu % irow ) nullify ( mat % matsulu % jptr ) nullify ( mat % matsulu % a_elt ) case ( UMFP ) deallocate ( mat % jptr , mat % irow ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization ! no lu factors (numeric) are in memory at this point. call umfpack_di_free_symbolic ( Symbolic = mat % matumfp % c_symbolic ) ! free the symbolic analysis call umfpack_di_report_info ( Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) ! print final statistics deallocate ( mat % b , mat % x ) case default stop 'Unknown solver type, close_solver' endselect return endsubroutine close_solver !========================================================================================= !> @note Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet !----------------------------------------------------------------------------------------- subroutine convert_matrice_format ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ) :: i ! ======================================================================================================================= ! Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. ! ************************************************ ! Elemental entries (example provided by MUMP): ! A1 = 1|-1  2  3| A2 = 3|2 -1  3| !      2| 2  1  1|      4|1  2 -1| !      3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) ! ! A  = 1|-1  2  3  0  0| !      2| 2  1  1  0  0| !      3| 1  1  3 -1  3| !      4| 0  0  1  2 -1| !      5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix !                        => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last !                                               position being size(eltvar)+1) ! ! ************************************************ ! Assembled matrix : ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jptr = (1, 4, 7, 12, 15, 18) ! ! ======================================================================================================================= ! Triplet form ! ************************************************ ! For each non zero a_elt entry, returns its row and column number ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) call from_elemental_to_assembled ( mat = mat ) select case ( mat % slv_t ) case ( MA48 ) ! Triplet form: irow, jcol, a_elt continue case ( MUMP ) ! Compressed row, elemental entries chosen: eltptr, eltvar, a_elt continue case ( UMFP , SULU ) ! Compressed row, assembled form: irow, jptr, a_elt deallocate ( mat % jcol ) ! no more needed ! UMFP and SULU allocations begin at 0 (C convention) do i = 1 , mat % nn + 1 mat % jptr ( i ) = mat % jptr ( i ) - 1 enddo if ( mat % slv_t == SULU ) mat % matsulu % jptr => mat % jptr ! otherwise, matsulu%jptr will be associated to ! a deallocated part of memory do i = 1 , mat % nz mat % irow ( i ) = mat % irow ( i ) - 1 enddo case default stop 'Unknown solver type, CONVERT_MATRICE_FORMAT' endselect return endsubroutine convert_matrice_format !========================================================================================= !> @note Subroutine to transform the elemental entries into assembled CC vectors !----------------------------------------------------------------------------------------- subroutine from_elemental_to_assembled ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ), pointer :: solver , nb_elt , n , ntot , nz integer ( kind = I4 ), dimension (:), pointer :: eltptr integer ( kind = I4 ), dimension (:), pointer :: eltvar real ( kind = R8 ), dimension (:), pointer :: a_elt integer ( kind = I4 ), dimension (:), pointer :: irow , jcol integer ( kind = I4 ), dimension (:), pointer :: jptr integer ( kind = I4 ) :: inelt , imatorder , i , j , ii , jj , i1 , i2 , ir1 , ir2 , jr1 , jr2 , itmp , innz , state solver => mat % slv_t nb_elt => mat % ne n => mat % nn ntot => mat % nt nz => mat % nz if ( solver == MUMP ) return ! conversion from elemental form to triplet form, perhaps with null a_elts !-------------------------------------------------------------------------- state = 0 if (. not . allocated ( mat % irow )) allocate ( mat % irow ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' if (. not . allocated ( mat % jcol )) allocate ( mat % jcol ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' eltptr => mat % eltptr eltvar => mat % eltvar a_elt => mat % a_elt irow => mat % irow jcol => mat % jcol jptr => mat % jptr irow ( 1 : ntot ) = - 1 jcol ( 1 : ntot ) = - 1 ii = 1 do inelt = 1 , nb_elt imatorder = eltptr ( inelt + 1 ) - eltptr ( inelt ) do i = 1 , imatorder irow ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ): eltptr ( inelt + 1 ) - 1 ) jcol ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ) + i - 1 ) ii = ii + imatorder enddo enddo ! where a_elt brings no contribution, rows and columns are zeroed !----------------------------------------------------------------- where ( abs ( a_elt ) < EPS_R8 ) irow = 0 jcol = 0 endwhere ! the triplet irow, jcol and a_elt is sorted according jcol !----------------------------------------------------------- call sort_int_1int_1real ( g = 1 , d = ntot , itabref = jcol ( 1 : ntot ), itab1 = irow ( 1 : ntot ), rtab2 = a_elt ( 1 : ntot )) ! column pointer determination for each new value !---------------------------------------------- if ( allocated ( mat % jptr )) deallocate ( mat % jptr ) ; allocate ( mat % jptr ( n + 1 ) ) ; jptr => mat % jptr ii = 1 do if ( jcol ( ii ) > 0 ) exit ! zeroed terms are ignored ii = ii + 1 enddo jptr ( 1 ) = ii do i = 1 , n - 1 itmp = jcol ( ii ) do ii = ii + 1 if ( jcol ( ii ) /= itmp ) exit enddo jptr ( i + 1 ) = ii enddo jptr ( n + 1 ) = ntot + 1 ! columns are already sorted; rows are now sorted for each row value !-------------------------------------------------------------------- do i = 1 , n i1 = jptr ( i ) i2 = jptr ( i + 1 ) - 1 call sort_int_1real ( g = 1 , d = i2 - i1 + 1 , itabref = irow ( i1 : i2 ), rtab1 = a_elt ( i1 : i2 )) enddo ! assembly starting from the jcol, irow and a_elt top ! for identical matrix locations, a_elts are added !----------------------------------------------------- innz = 1 jj = jptr ( 1 ) ! first non-zero element jr1 = jcol ( jj ) ir1 = irow ( jj ) jcol ( innz ) = jr1 irow ( innz ) = ir1 a_elt ( innz ) = a_elt ( jj ) do j = jj + 1 , ntot jr2 = jcol ( j ) ir2 = irow ( j ) if ( ( jr2 /= jr1 ). or .( ir2 /= ir1 ) ) then ! if row or column index has changed innz = innz + 1 ! a non-zero term is added jcol ( innz ) = jr2 irow ( innz ) = ir2 a_elt ( innz ) = a_elt ( j ) else a_elt ( innz ) = a_elt ( innz ) + a_elt ( j ) ! row and column indexes are the same, stiffness terms are added endif jr1 = jr2 ! stores (i-1) and (j-1) for further comparison ir1 = ir2 enddo nz = innz jcol ( nz + 1 : ntot ) = - 1 irow ( nz + 1 : ntot ) = - 1 a_elt ( nz + 1 : ntot ) = huge ( 1._R8 ) ! col pointer update !---------------------------------------------- jj = 1 jptr ( 1 ) = 1 do j = 1 , n - 1 itmp = jcol ( jj ) do jj = jj + 1 if ( jcol ( jj ) /= itmp ) exit enddo jptr ( j + 1 ) = jj enddo jptr ( n + 1 ) = nz + 1 nullify ( eltptr , eltvar , a_elt , irow , jcol , jptr ) return endsubroutine from_elemental_to_assembled endmodule solver","tags":""},{"title":"prg.f90 – MSOLV-fortran","loc":"sourcefile/prg.f90.html","text":"This file depends on sourcefile~~prg.f90~~EfferentGraph sourcefile~prg.f90 prg.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~prg.f90->sourcefile~mod_num_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_num_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort.f90 mod_sort.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs test_solvers Source Code prg.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **MSOLV example of use** !  </span> ! ! @note ! ! The program asks first for the matrix size: ```1``` for a very small matrix, and ```0``` ! for a bigger one.The systems are CC HB format systems with elemental matrices. ! ! <h3>Small system -- nnz=18</h3> ! ! The system is (example provided by MUMP): !  A1 = \\begin{pmatrix} !           -1 & 2 & 3 \\\\ !            2 & 1 & 1 \\\\ !            1 & 1 & 1 !          \\end{pmatrix} ~ !    A2 = \\begin{pmatrix} !            2 & -1 &  3 \\\\ !            1 &  2 & -1 \\\\ !            3 &  2 &  1 !         \\end{pmatrix}  \\\\ \\text{ } \\\\ ! \\rightarrow a\\_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) \\\\ \\text{ } \\\\ !  A = \\begin{pmatrix} !           -1 & 2 & 3 & 0 & 0 \\\\ !            2 & 1 & 1 & 0 & 0 \\\\ !            1 & 1 & 3 &-1 & 3 \\\\ !            0 & 0 & 1 & 2 &-1 \\\\ !            0 & 0 & 3 & 2 & 1 !      \\end{pmatrix}  \\\\ \\text{ } \\\\ ! \\rightarrow eltvar = (1, 2, 3, 3, 4, 5) \\text{ and } eltptr = (1, 4, 7) !  ! ! + *eltvar* locates the elemental matrix line in the assembled matrix ! + *eltptr* gives the elemental matrix first entry position in *eltvar* !          (last position being size(*eltvar*)+1) <br/><br/> ! ! The rhs is (12, 7, 23, 6, 22), and the solution (1, 2, 3, 4, 5) ! ! <h3>Big (well, in fact, medium) system -- nnz=2,097,152</h3> ! ! The system results from a *MUSST* study case and there is of course no theoretical solution to compare with ! ! @endnote ! ! @warning ! ! Some solver implementation are C written, so the arrays may begin at 0. It explains the variable ```dec``` in [[prod_a_x]] ! ! @endwarning program test_solvers use omp_lib , only : omp_get_wtime use data_arch , only : I4 , R4 , R8 , get_unit use num_param , only : OPU , & ! *default output unit* IPU , & ! *default input unit* SOLV_MESS , & ! *Solver message: yes=```PRINT_MESS```, no=```NO_MESS```* NO_MESS , & ! *no output message* PRINT_MESS ! *solver infos output* use solver , only : MAT_SOLV , & ! *system data type* solve_syst , & ! *subroutine for the system resolution* MUMP , & ! *integer* UMFP , & ! *integer* SULU , & ! *integer* convert_matrice_format ! *various matrix format conversion* implicit none integer ( kind = I4 ) :: i , ii , uu , size_a_elt , state real ( kind = R8 ) :: time1 , time2 , error type ( MAT_SOLV ) :: slv_struct real ( kind = R8 ), dimension (:), allocatable :: b !! *system right hand side* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *matrix non-zero entries in CC* real ( kind = R8 ), dimension (:), allocatable :: a_elt_ref !! *initial ```a_elt```* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *elemental matrices position in ```eltvar```* integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *elemental matrix global lines* SOLV_MESS = NO_MESS !PRINT_MESS! write ( OPU , * ) 'small matrix? 0:n, 1:y' read ( IPU , * ) i ! ======================== SOLVER TYPE =========================================== do write ( OPU , * ) 'data read, choose solver n° : 0-MA48, 1-SULU, 2-MUMP (ref), 3-UMFP' read ( IPU , * ) ii slv_struct % slv_t = ii if ( ii >= 0 . and . ii <= 3 ) exit enddo ! ======================== SYST DATA READ =========================================== call get_unit ( uu ) if ( i == 0 ) then open ( uu , file = \"mat/big_syst.sys\" ) else open ( uu , file = \"mat/small_syst.sys\" ) endif ! ======================== SYST INFO =========================================== read ( uu , * ) slv_struct % nn , slv_struct % ne , slv_struct % nvar , slv_struct % nt write ( OPU , * ) '*************** INFO ********************' write ( OPU , * ) 'system size:                  ' , slv_struct % nn write ( OPU , * ) 'number of elemental matrices: ' , slv_struct % ne write ( OPU , * ) 'number of nnz entries:        ' , slv_struct % nt write ( OPU , * ) '*****************************************' slv_struct % first = . true . allocate ( eltvar ( slv_struct % nvar ) ) allocate ( a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( a_elt_ref ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( eltptr ( slv_struct % ne + 1 ) ) allocate ( b ( slv_struct % nn ) ) allocate ( slv_struct % eltvar ( slv_struct % nvar ) ) allocate ( slv_struct % a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( slv_struct % eltptr ( slv_struct % ne + 1 ) ) call solve_syst ( mat = slv_struct , step = 'ini' ) do ii = 1 , slv_struct % nvar read ( uu , * ) slv_struct % eltvar ( ii ) enddo do ii = 1 , slv_struct % ne + 1 read ( uu , * ) slv_struct % eltptr ( ii ) enddo do ii = 1 , slv_struct % nt read ( uu , * ) slv_struct % a_elt ( ii ) enddo do ii = 1 , slv_struct % nn read ( uu , * ) slv_struct % b ( ii ) enddo close ( uu ) ! The matrices are in CC HB format. Only MUMPS accepts elemental entries, so the ! following subroutine converts elemental marices to assembled vectors. ! If MUMPS is chosen, nothing is done. call convert_matrice_format ( mat = slv_struct ) ! ======================== backup ============================================ eltvar = slv_struct % eltvar a_elt_ref = slv_struct % a_elt eltptr = slv_struct % eltptr b = slv_struct % b ! ======================== PROCESS =========================================== time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'ana' ) ; write ( OPU , * ) 'system analyzed' ; slv_struct % first = . false . call solve_syst ( mat = slv_struct , step = 'fac' ) ; write ( OPU , * ) 'system factorized' call solve_syst ( mat = slv_struct , step = 'sol' ) ; write ( OPU , * ) 'system solved' call solve_syst ( mat = slv_struct , step = 'fre' ) ; write ( OPU , * ) 'system freed' time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt_ref , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) ! Here, the matrix coefficients are modified, but the sparsity is conserved. It gives a look to the ability ! of the solver to exploit the symbolic calculations performed before. do if ( slv_struct % slv_t == MUMP ) then size_a_elt = size ( slv_struct % a_elt ) else size_a_elt = slv_struct % nt endif ! the original entries are retrieved, then modified a_elt = a_elt_ref call modify_a_elt ( tab = a_elt , nz = size_a_elt ) slv_struct % a_elt = a_elt slv_struct % b = b slv_struct % x = 0._R8 time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'fac' ) call solve_syst ( mat = slv_struct , step = 'sol' ) call solve_syst ( mat = slv_struct , step = 'fre' ) time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) write ( OPU , * ) 'STOP? (y=1, n=0)' read ( IPU , * ) ii if ( ii == 1 ) exit enddo deallocate ( eltvar , a_elt , a_elt_ref , eltptr , b ) call solve_syst ( mat = slv_struct , step = 'end' ) stop contains !========================================================================================= !< @note The product \\{y\\} of the system matrix [A] by the solution \\{x\\}, is !        calculated, and compared to the right hand side \\{b\\}. !        The calculated error is the absolute error in %. !----------------------------------------------------------------------------------------- subroutine verif_solution ( slv_struct , a_elt , b , error ) implicit none type ( MAT_SOLV ), intent ( in ) :: slv_struct real ( kind = R8 ), dimension (:), intent ( in ) :: a_elt real ( kind = R8 ), dimension (:), intent ( in ) :: b real ( kind = R8 ), intent ( out ) :: error real ( kind = R8 ), dimension ( slv_struct % nn ) :: y ! to assess the accuracy, the solution is applied to the ! system matrix and compared to the rhs. if ( slv_struct % slv_t == MUMP ) then call prod_elemental_x ( n = slv_struct % nn , & nz = slv_struct % nt , & nelt = slv_struct % ne , & nvar = slv_struct % nvar , & x = slv_struct % x , & y = y , & a_elt = a_elt , & eltptr = slv_struct % eltptr , & eltvar = slv_struct % eltvar ) else call prod_a_x ( n = slv_struct % nn , & nz = slv_struct % nz , & x = slv_struct % x , & y = y , & a_elt = a_elt , & irow = slv_struct % irow , & jptr = slv_struct % jptr , & slvt = slv_struct % slv_t ) endif error = 100 * maxval ( abs ( y ( 1 : slv_struct % nn ) - b ( 1 : slv_struct % nn )) ) / & maxval ( abs ( y ( 1 : slv_struct % nn ) + b ( 1 : slv_struct % nn )) ) return endsubroutine verif_solution !========================================================================================= !> @note multiplication of the system coefficient by a random factor !----------------------------------------------------------------------------------------- subroutine modify_a_elt ( tab , nz ) implicit none integer ( kind = I4 ), intent ( in ) :: nz real ( kind = R8 ), intent ( inout ) :: tab ( 1 : nz ) real ( kind = R8 ), allocatable :: tmp (:) allocate ( tmp ( 1 : nz )) call random_number ( harvest = tmp ( 1 : nz )) tmp ( 1 : nz ) = 2 * tmp ( 1 : nz ) - 1.0_R8 tab ( 1 : nz ) = tab ( 1 : nz ) * tmp ( 1 : nz ) deallocate ( tmp ) return endsubroutine modify_a_elt !========================================================================================= !> @note [A] \\{x\\}, assembled CC format !----------------------------------------------------------------------------------------- subroutine prod_a_x ( n , nz , x , y , a_elt , irow , jptr , slvt ) implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , slvt real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nz ), intent ( in ) :: irow integer ( kind = I4 ), dimension ( n + 1 ), intent ( in ) :: jptr real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , k , dec y ( 1 : n ) = 0._R8 dec = 0 if ( slvt == UMFP . or . slvt == SULU ) dec = 1 do i = 1 , n do k = jptr ( i ), jptr ( i + 1 ) - 1 y ( irow ( k + dec ) + dec ) = y ( irow ( k + dec ) + dec ) + x ( i ) * a_elt ( k + dec ) enddo enddo return endsubroutine prod_a_x !========================================================================================= !> @note [A] \\{x\\}, elemental CC format !----------------------------------------------------------------------------------------- subroutine prod_elemental_x ( n , nz , nelt , nvar , x , y , a_elt , eltptr , eltvar ) implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , nelt , nvar real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nelt + 1 ), intent ( in ) :: eltptr integer ( kind = I4 ), dimension ( nvar ), intent ( in ) :: eltvar real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , j , k , kk , inc_nz , inc_nn , n_elem , i_elem , max_n_elem real ( kind = R8 ), dimension (:), allocatable :: a_elt_tmp , x_tmp , y_tmp inc_nz = 0 inc_nn = 0 n_elem = 0 y = 0._R8 max_n_elem = 0 do i_elem = 1 , nelt max_n_elem = max ( max_n_elem , eltptr ( i_elem + 1 ) - eltptr ( i_elem )) enddo allocate ( a_elt_tmp ( 1 : max_n_elem ** 2 ) ) allocate ( x_tmp ( 1 : max_n_elem ) ) allocate ( y_tmp ( 1 : max_n_elem ) ) do i_elem = 1 , nelt ! browse all elemental matrices inc_nn = inc_nn + n_elem ! step in eltvar for matrix number i_elem inc_nz = inc_nz + n_elem ** 2 ! step in a_elt for matrix number i_elem n_elem = eltptr ( i_elem + 1 ) - eltptr ( i_elem ) ! elemental matrix size a_elt_tmp ( 1 : n_elem ** 2 ) = a_elt ( inc_nz + 1 : inc_nz + n_elem ** 2 ) ! elemental matrix coefficients ! --- elemental rhs kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 x_tmp ( kk ) = x ( eltvar ( k )) enddo ! --- elemental product y_tmp ( 1 : n_elem ) = 0._R8 do i = 1 , n_elem do j = 1 , n_elem y_tmp ( i ) = y_tmp ( i ) + a_elt_tmp ( i + n_elem * ( j - 1 )) * x_tmp ( j ) enddo enddo ! --- elemental product in global vector y kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 y ( eltvar ( k )) = y ( eltvar ( k )) + y_tmp ( kk ) enddo enddo deallocate ( a_elt_tmp , x_tmp , y_tmp ) return endsubroutine prod_elemental_x endprogram test_solvers","tags":""},{"title":"superlu.f90 – MSOLV-fortran","loc":"sourcefile/superlu.f90.html","text":"Files dependent on this one sourcefile~~superlu.f90~~AfferentGraph sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sulu_wrapper Source Code superlu.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **A SuperLU wrapper** !  </span> module sulu_wrapper use iso_c_binding , only : C_INT , C_FLOAT , C_DOUBLE , C_CHAR , C_PTR , C_F_POINTER , C_NULL_CHAR , C_NULL_PTR implicit none private integer ( kind = 4 ), parameter :: I4 = 4 , R4 = 4 , R8 = 8 !------------------------------------------------------------------------------- ! -------------------   ENUMS -------------------------------------------------- !------------------------------------------------------------------------------- enum , bind ( c ) ! trans_t enumerator :: NOTRANS enumerator :: TRANS enumerator :: CONJ endenum enum , bind ( c ) ! fact_t enumerator :: DOFACT enumerator :: SAMEPATTERN enumerator :: SAMEPATTERN_SAMEROWPERM enumerator :: FACTORED endenum enum , bind ( c ) ! Stype_t enumerator :: SLU_NC !! *column-wise, no supernode* enumerator :: SLU_NCP !! *column-wise, column-permuted, no supernode* enumerator :: SLU_NR !! *row-wize, no supernode* enumerator :: SLU_SC !! *column-wise, supernode* enumerator :: SLU_SCP !! *supernode, column-wise, permuted* enumerator :: SLU_SR !! *row-wise, supernode* enumerator :: SLU_DN !! *Fortran style column-wise storage for dense matrix* enumerator :: SLU_NR_loc !! *distributed compressed row format* endenum enum , bind ( c ) ! Dtype_t enumerator :: SLU_S !! *single* enumerator :: SLU_D !! *double* enumerator :: SLU_C !! *single complex* enumerator :: SLU_Z !! *double complex* endenum enum , bind ( c ) ! Mtype_t enumerator :: SLU_GE !! *general* enumerator :: SLU_TRLU !! *lower triangular, unit diagonal* enumerator :: SLU_TRUU !! *upper triangular, unit diagonal* enumerator :: SLU_TRL !! *lower triangular* enumerator :: SLU_TRU !! *upper triangular* enumerator :: SLU_SYL !! *symmetric, store lower half* enumerator :: SLU_SYU !! *symmetric, store upper half* enumerator :: SLU_HEL !! *Hermitian, store lower half* enumerator :: SLU_HEU !! *Hermitian, store upper half* endenum !------------------------------------------------------------------------------- ! -------------------   DERIVED TYPES   ---------------------------------------- !------------------------------------------------------------------------------- type , bind ( c ) :: LU_STACK_T integer ( kind = C_INT ) :: size integer ( kind = C_INT ) :: used integer ( kind = C_INT ) :: top1 integer ( kind = C_INT ) :: top2 type ( C_PTR ) :: array endtype LU_STACK_T type , bind ( c ) :: EXPHEADER integer ( kind = C_INT ) :: size type ( C_PTR ) :: mem endtype EXPHEADER type , bind ( c ) :: GLOBALLU_T integer ( kind = C_INT ) :: xsup integer ( kind = C_INT ) :: supno integer ( kind = C_INT ) :: lsub integer ( kind = C_INT ) :: xlsub type ( C_PTR ) :: lusup integer ( kind = C_INT ) :: xlusup type ( C_PTR ) :: ucol integer ( kind = C_INT ) :: usub integer ( kind = C_INT ) :: xusub integer ( kind = C_INT ) :: nzlmax integer ( kind = C_INT ) :: nzumax integer ( kind = C_INT ) :: nzlumax integer ( kind = C_INT ) :: MemModel = 0 integer ( kind = C_INT ) :: num_expansions type ( EXPHEADER ) :: expanders type ( LU_STACK_T ) :: stack endtype GLOBALLU_T type , bind ( c ) :: SUPERLUSTAT_T type ( C_PTR ) :: panel_histo !! *histogram of panel size distribution* type ( C_PTR ) :: utime !! *running time at various phases* type ( C_PTR ) :: ops !! *operation count at various phases* integer ( kind = C_INT ) :: TinyPivots !! *number of tiny pivots* integer ( kind = C_INT ) :: RefineSteps !! *number of iterative refinement steps* integer ( kind = C_INT ) :: expansions !! *number of memory expansions* endtype SUPERLUSTAT_T type , bind ( c ) :: MEM_USAGE_T real ( kind = C_FLOAT ) :: for_lu real ( kind = C_FLOAT ) :: total_needed endtype MEM_USAGE_T !< @note ! Stype == ```SLU_NC``` (Also known as Harwell-Boeing sparse matrix format) ! ! Zero-based indexing is used; colptr[] has ncol+1 entries, the last one pointing beyond the last column, ! so that colptr[ncol] = nnz. ! @endnote type , bind ( c ) :: NCFORMAT integer ( kind = C_INT ) :: nnz !! *number of nonzeros in the matrix* type ( C_PTR ) :: nzval !! *pointer to array of nonzero values, packed by column* type ( C_PTR ) :: rowind !! *pointer to array of row indices of the nonzeros* type ( C_PTR ) :: colptr !! *pointer to array of beginning of columns in nzval[] and rowind[]* endtype NCFORMAT type , bind ( c ) :: SUPERMATRIX integer ( kind = C_INT ) :: Stype !! *Storage type: interprets the storage structure pointed to by Store* integer ( kind = C_INT ) :: Dtype !! *Data type* integer ( kind = C_INT ) :: Mtype !! *Matrix type: describes the mathematical property of the matrix* integer ( kind = C_INT ) :: nrow !! *number of rows* integer ( kind = C_INT ) :: ncol !! *number of columns* type ( C_PTR ) :: Store !! *pointer to the actual storage of the matrix, here, pointer to [[NCformat]]* endtype SUPERMATRIX type , bind ( c ) :: SUPERLU_OPTIONS_T !/* ! *-- This contains the options used to control the solution process. ! * ! * Fact   (fact_t) ! *        Specifies whether or not the factored form of the matrix ! *        A is supplied on entry, and if not, how the matrix A should ! *        be factorizaed. ! *        = DOFACT: The matrix A will be factorized from scratch, and the ! *             factors will be stored in L and U. ! *        = SamePattern: The matrix A will be factorized assuming ! *             that a factorization of a matrix with the same sparsity ! *             pattern was performed prior to this one. Therefore, this ! *             factorization will reuse column permutation vector ! *             ScalePermstruct->perm_c and the column elimination tree ! *             LUstruct->etree. ! *        = SamePattern_SameRowPerm: The matrix A will be factorized ! *             assuming that a factorization of a matrix with the same ! *             sparsity   pattern and similar numerical values was performed ! *             prior to this one. Therefore, this factorization will reuse ! *             both row and column scaling factors R and C, both row and ! *             column permutation vectors perm_r and perm_c, and the ! *             L & U data structures set up from the previous factorization. !! *        = FACTORED: On entry, L, U, perm_r and perm_c contain the ! *              factored form of A. If DiagScale is not NOEQUIL, the matrix ! *              A has been equilibrated with scaling factors R and C. ! * ! * Equil  (yes_no_t) ! *        Specifies whether to equilibrate the system (scale A's row and ! *        columns to have unit norm). ! * ! * ColPerm (colperm_t) ! *        Specifies what type of column permutation to use to reduce fill. ! *        = NATURAL: use the natural ordering ! *        = MMD_ATA: use minimum degree ordering on structure of A'*A ! *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A ! *        = COLAMD: use approximate minimum degree column ordering ! *        = MY_PERMC: use the ordering specified by the user ! * ! * Trans  (trans_t) ! *        Specifies the form of the system of equations: ! *        = NOTRANS: A * X = B        (No transpose) ! *        = TRANS:   A**T * X = B     (Transpose) ! *        = CONJ:    A**H * X = B     (Transpose) ! * ! * IterRefine (IterRefine_t) ! *        Specifies whether to perform iterative refinement. ! *        = NO: no iterative refinement ! *        = SLU_SINGLE: perform iterative refinement in single precision ! *        = SLU_DOUBLE: perform iterative refinement in double precision ! *        = SLU_EXTRA: perform iterative refinement in extra precision ! * ! * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU) ! *        Specifies the threshold used for a diagonal entry to be an ! *        acceptable pivot. ! * ! * SymmetricMode (yest_no_t) ! *        Specifies whether to use symmetric mode. Symmetric mode gives ! *        preference to diagonal pivots, and uses an (A'+A)-based column ! *        permutation algorithm. ! * ! * PivotGrowth (yes_no_t) ! *        Specifies whether to compute the reciprocal pivot growth. ! * ! * ConditionNumber (ues_no_t) ! *        Specifies whether to compute the reciprocal condition number. ! * ! * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU) ! *        Specifies whether to permute rows of the original matrix. ! *        = NO: not to permute the rows ! *        = LargeDiag: make the diagonal large relative to the off-diagonal ! *        = MY_PERMR: use the permutation given by the user ! * ! * ILU_DropRule (int) ! *        Specifies the dropping rule: ! *     = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau). ! *     = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n. ! *     = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column, ! *                     p = gamma * nnz(A(:,j)). ! *     = DROP_AREA:    Variation of ILUTP, for j-th column, use ! *                     nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory. ! *     = DROP_DYNAMIC: Modify the threshold tau during factorizaion: ! *                     If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma ! *                         tau_L(j) := MIN(tau_0, tau_L(j-1) * 2); ! *                     Otherwise ! *                         tau_L(j) := MAX(tau_0, tau_L(j-1) / 2); ! *                     tau_U(j) uses the similar rule. ! *                     NOTE: the thresholds used by L and U are separate. ! *     = DROP_INTERP:  Compute the second dropping threshold by ! *                     interpolation instead of sorting (default). ! *                     In this case, the actual fill ratio is not ! *                     guaranteed to be smaller than gamma. ! *                     Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive. ! *    ( Default: DROP_BASIC | DROP_AREA ) ! * ! * ILU_DropTol (double) ! *        numerical threshold for dropping. ! * ! * ILU_FillFactor (double) ! *        Gamma in the secondary dropping. ! * ! * ILU_Norm (norm_t) ! *        Specify which norm to use to measure the row size in a ! *        supernode: infinity-norm, 1-norm, or 2-norm. ! * ! * ILU_FillTol (double) ! *        numerical threshold for zero pivot perturbation. ! * ! * ILU_MILU (milu_t) ! *        Specifies which version of MILU to use. ! * ! * ILU_MILU_Dim (double) ! *        Dimension of the PDE if available. ! * ! * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether to replace the tiny diagonals by ! *        sqrt(epsilon)*||A|| during LU factorization. ! * ! * SolveInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        triangular solve. ! * ! * RefineInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        sparse matrix-vector multiplication routine needed in iterative ! *        refinement. ! * ! * PrintStat (yes_no_t) ! *        Specifies whether to print the solver's statistics. ! */ integer ( kind = C_INT ) :: Fact integer ( kind = C_INT ) :: Equil integer ( kind = C_INT ) :: ColPerm integer ( kind = C_INT ) :: Trans integer ( kind = C_INT ) :: IterRefine real ( kind = C_DOUBLE ) :: DiagPivotThresh integer ( kind = C_INT ) :: SymmetricMode integer ( kind = C_INT ) :: PivotGrowth integer ( kind = C_INT ) :: ConditionNumber integer ( kind = C_INT ) :: RowPerm integer ( kind = C_INT ) :: ILU_DropRule real ( kind = C_DOUBLE ) :: ILU_DropTol real ( kind = C_DOUBLE ) :: ILU_FillFactor integer ( kind = C_INT ) :: ILU_Norm real ( kind = C_DOUBLE ) :: ILU_FillTol integer ( kind = C_INT ) :: ILU_MILU real ( kind = C_DOUBLE ) :: ILU_MILU_Dim integer ( kind = C_INT ) :: ParSymbFact integer ( kind = C_INT ) :: ReplaceTinyPivot integer ( kind = C_INT ) :: SolveInitialized integer ( kind = C_INT ) :: RefineInitialized integer ( kind = C_INT ) :: PrintStat integer ( kind = C_INT ) :: nnzL , nnzU !! *used to store nnzs for now* integer ( kind = C_INT ) :: num_lookaheads !! *num of levels in look-ahead* integer ( kind = C_INT ) :: lookahead_etree !! *use etree computed from the serial symbolic factorization* integer ( kind = C_INT ) :: SymPattern !! *symmetric factorization* endtype SUPERLU_OPTIONS_T !------------------------------------------------------------------------------- ! -------------------   SULU GLOBAL TYPE   ------------------------------------- !------------------------------------------------------------------------------- type SULU_ENV !! <span style=\"color:green\">Global type for *SuperLU* which covers all the stuff needed</span> integer ( kind = C_INT ) :: n !! *system size* integer ( kind = C_INT ) :: nrhs !! *number of right hand sides* integer ( kind = C_INT ) :: nz !! *number on non-zero entries* integer ( kind = C_INT ) :: info !! *info returned by [[dgssvx]]* integer ( kind = C_INT ) :: lwork !! *size of workspace, not used here* logical ( kind = I4 ) :: first !! *if ```false``` the system has been factorized at least once* real ( kind = R8 ), dimension (:), pointer :: b !! *right hand side: points to [[MAT_SOLV:b]]* real ( kind = R8 ), allocatable , dimension (:) :: x !! *solution* real ( kind = R8 ), dimension (:), pointer :: a_elt !! *CC system matrix: points to [[MAT_SOLV:a_elt]]* integer ( kind = I4 ), dimension (:), pointer :: irow !! *matrix line of an a_elt element: points to [[MAT_SOLV:irow]]* integer ( kind = I4 ), dimension (:), pointer :: jptr !! *matrix column pointers: points to [[MAT_SOLV:jptr]]* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: ferr !! *estimated forward error bound for each solution vector* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: berr !! *componentwise relative backward error of each solution* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: RR !! *row scale factors for A * real ( kind = C_DOUBLE ), allocatable , dimension (:) :: CC !!*column scale factors for A* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rpg !! *reciprocal pivot growth factor* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rcond !!*estimate of the reciprocal condition number of the matrix A* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_c !!*If A->Stype = ```SLU_NC```, Column permutation vector of size A->ncol* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_r !!*If A->Stype = ```SLU_NC```, row permutation vector of size A->nrow* integer ( kind = C_INT ), allocatable , dimension (:) :: etree !! *Elimination tree* character ( len = 1 , kind = C_CHAR ) :: equed !! *form of equilibration* type ( C_PTR ) :: work !! *User supplied workspace* type ( SUPERLU_OPTIONS_T ) :: options !! *LU controls* type ( SUPERMATRIX ) :: sma !! *Matrix A in A*X=B* type ( SUPERMATRIX ) :: smb !! *On entry, the right hand side matrix* type ( SUPERMATRIX ) :: smx !! *olution matrix to the original system* type ( SUPERMATRIX ) :: sml !! *factor L from the factorization* type ( SUPERMATRIX ) :: smu !! *factor U from the factorization* type ( SUPERLUSTAT_T ) :: stat !! *statistics on runtime and floating-point operation count* type ( GLOBALLU_T ) :: Glu !! *first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity* type ( MEM_USAGE_T ) :: mem_usage !! *memory usage statistics* endtype SULU_ENV !------------------------------------------------------------------------------- ! -------------------   INTERFACES   ------------------------------------------- !------------------------------------------------------------------------------- interface !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_SuperNode_Matrix ( A ) & ! bind ( c , name = \"Destroy_SuperNode_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_SuperNode_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_SuperMatrix_Store ( A ) & ! bind ( c , name = \"Destroy_SuperMatrix_Store\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_SuperMatrix_Store !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_CompCol_Matrix ( A ) & ! bind ( c , name = \"Destroy_CompCol_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_CompCol_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_Dense_Matrix ( A ) & ! bind ( c , name = \"Destroy_Dense_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_Dense_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatInit ( stat ) & ! bind ( c , name = \"StatInit\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( out ) :: stat endsubroutine StatInit !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatFree ( stat ) & ! bind ( c , name = \"StatFree\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( in ) :: stat endsubroutine StatFree !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine dCreate_CompCol_Matrix ( A , & ! out SuperMatrix m , & ! in int n , & ! in int nnz , & ! in int nzval , & ! in double dimension() rowind , & ! in int dimension() colptr , & ! in int dimension() stype , & ! in int dtype , & ! in int mtype & ! in int ) & bind ( c , name = \"dCreate_CompCol_Matrix\" ) use , intrinsic :: iso_c_binding , only : C_INT , C_DOUBLE import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( out ) :: A integer ( kind = C_INT ), value , intent ( in ) :: m integer ( kind = C_INT ), value , intent ( in ) :: n integer ( kind = C_INT ), value , intent ( in ) :: nnz real ( kind = C_DOUBLE ), intent ( in ) :: nzval ( * ) integer ( kind = C_INT ), intent ( in ) :: rowind ( * ) integer ( kind = C_INT ), intent ( in ) :: colptr ( * ) integer ( kind = C_INT ), value , intent ( in ) :: stype integer ( kind = C_INT ), value , intent ( in ) :: dtype integer ( kind = C_INT ), value , intent ( in ) :: mtype endsubroutine dCreate_CompCol_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine dCreate_Dense_Matrix ( BX , & ! out SuperMatrix m , & ! in int n , & ! in int x , & ! in double dimension() ldx , & ! in int stype , & ! in int dtype , & ! in int mtype & ! in int ) & bind ( c , name = 'dCreate_Dense_Matrix' ) use , intrinsic :: iso_c_binding , only : C_INT , C_DOUBLE import SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( out ) :: BX integer ( kind = C_INT ), value , intent ( in ) :: m integer ( kind = C_INT ), value , intent ( in ) :: n real ( kind = C_DOUBLE ), intent ( in ) :: x ( * ) integer ( kind = C_INT ), value , intent ( in ) :: ldx integer ( kind = C_INT ), value , intent ( in ) :: stype integer ( kind = C_INT ), value , intent ( in ) :: dtype integer ( kind = C_INT ), value , intent ( in ) :: mtype endsubroutine dCreate_Dense_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine set_default_options ( options ) & ! bind ( c , name = 'set_default_options' ) use , intrinsic :: iso_c_binding import SUPERLU_OPTIONS_T implicit none type ( SUPERLU_OPTIONS_T ), intent ( inout ) :: options endsubroutine set_default_options !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . !/*! Arguments ! * ! * <pre> ! * Purpose ! * ======= ! * ! * DGSSVX solves the system of linear equations A*X=B or A'*X=B, using ! * the LU factorization from dgstrf(). Error bounds on the solution and ! * a condition estimate are also provided. It performs the following steps: ! * ! *   1. If A is stored column-wise (A->Stype = SLU_NC): ! * ! *      1.1. If options->Equil = YES, scaling factors are computed to ! *           equilibrate the system: ! *           options->Trans = NOTRANS: ! *               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B ! *           options->Trans = TRANS: ! *               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B ! *           options->Trans = CONJ: ! *               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B ! *           Whether or not the system will be equilibrated depends on the ! *           scaling of the matrix A, but if equilibration is used, A is ! *           overwritten by diag(R)*A*diag(C) and B by diag(R)*B ! *           (if options->Trans=NOTRANS) or diag(C)*B (if options->Trans ! *           = TRANS or CONJ). ! * ! *      1.2. Permute columns of A, forming A*Pc, where Pc is a permutation ! *           matrix that usually preserves sparsity. ! *           For more details of this step, see sp_preorder.c. ! * ! *      1.3. If options->Fact != FACTORED, the LU decomposition is used to ! *           factor the matrix A (after equilibration if options->Equil = YES) ! *           as Pr*A*Pc = L*U, with Pr determined by partial pivoting. ! * ! *      1.4. Compute the reciprocal pivot growth factor. ! * ! *      1.5. If some U(i,i) = 0, so that U is exactly singular, then the ! *           routine returns with info = i. Otherwise, the factored form of ! *           A is used to estimate the condition number of the matrix A. If ! *           the reciprocal of the condition number is less than machine ! *           precision, info = A->ncol+1 is returned as a warning, but the ! *           routine still goes on to solve for X and computes error bounds ! *           as described below. ! * ! *      1.6. The system of equations is solved for X using the factored form ! *           of A. ! * ! *      1.7. If options->IterRefine != NOREFINE, iterative refinement is ! *           applied to improve the computed solution matrix and calculate ! *           error bounds and backward error estimates for it. ! * ! *      1.8. If equilibration was used, the matrix X is premultiplied by ! *           diag(C) (if options->Trans = NOTRANS) or diag(R) ! *           (if options->Trans = TRANS or CONJ) so that it solves the ! *           original system before equilibration. ! * ! *   2. If A is stored row-wise (A->Stype = SLU_NR), apply the above algorithm ! *      to the transpose of A: ! * ! *      2.1. If options->Equil = YES, scaling factors are computed to ! *           equilibrate the system: ! *           options->Trans = NOTRANS: ! *               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B ! *           options->Trans = TRANS: ! *               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B ! *           options->Trans = CONJ: ! *               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B ! *           Whether or not the system will be equilibrated depends on the ! *           scaling of the matrix A, but if equilibration is used, A' is ! *           overwritten by diag(R)*A'*diag(C) and B by diag(R)*B ! *           (if trans='N') or diag(C)*B (if trans = 'T' or 'C'). ! * ! *      2.2. Permute columns of transpose(A) (rows of A), ! *           forming transpose(A)*Pc, where Pc is a permutation matrix that ! *           usually preserves sparsity. ! *           For more details of this step, see sp_preorder.c. ! * ! *      2.3. If options->Fact != FACTORED, the LU decomposition is used to ! *           factor the transpose(A) (after equilibration if ! *           options->Fact = YES) as Pr*transpose(A)*Pc = L*U with the ! *           permutation Pr determined by partial pivoting. ! * ! *      2.4. Compute the reciprocal pivot growth factor. ! * ! *      2.5. If some U(i,i) = 0, so that U is exactly singular, then the ! *           routine returns with info = i. Otherwise, the factored form ! *           of transpose(A) is used to estimate the condition number of the ! *           matrix A. If the reciprocal of the condition number ! *           is less than machine precision, info = A->nrow+1 is returned as ! *           a warning, but the routine still goes on to solve for X and ! *           computes error bounds as described below. ! * ! *      2.6. The system of equations is solved for X using the factored form ! *           of transpose(A). ! * ! *      2.7. If options->IterRefine != NOREFINE, iterative refinement is ! *           applied to improve the computed solution matrix and calculate ! *           error bounds and backward error estimates for it. ! * ! *      2.8. If equilibration was used, the matrix X is premultiplied by ! *           diag(C) (if options->Trans = NOTRANS) or diag(R) ! *           (if options->Trans = TRANS or CONJ) so that it solves the ! *           original system before equilibration. ! * ! *   See supermatrix.h for the definition of 'SuperMatrix' structure. ! * ! * Arguments ! * ========= ! * ! * options (input) superlu_options_t* ! *         The structure defines the input parameters to control ! *         how the LU decomposition will be performed and how the ! *         system will be solved. ! * ! * A       (input/output) SuperMatrix* ! *         Matrix A in A*X=B, of dimension (A->nrow, A->ncol). The number ! *         of the linear equations is A->nrow. Currently, the type of A can be: ! *         Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE. ! *         In the future, more general A may be handled. ! * ! *         On entry, If options->Fact = FACTORED and equed is not 'N', ! *         then A must have been equilibrated by the scaling factors in ! *         R and/or C. ! *         On exit, A is not modified if options->Equil = NO, or if ! *         options->Equil = YES but equed = 'N' on exit. ! *         Otherwise, if options->Equil = YES and equed is not 'N', ! *         A is scaled as follows: ! *         If A->Stype = SLU_NC: ! *           equed = 'R':  A := diag(R) * A ! *           equed = 'C':  A := A * diag(C) ! *           equed = 'B':  A := diag(R) * A * diag(C). ! *         If A->Stype = SLU_NR: ! *           equed = 'R':  transpose(A) := diag(R) * transpose(A) ! *           equed = 'C':  transpose(A) := transpose(A) * diag(C) ! *           equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C). ! * ! * perm_c  (input/output) int* ! *         If A->Stype = SLU_NC, Column permutation vector of size A->ncol, ! *         which defines the permutation matrix Pc; perm_c[i] = j means ! *         column i of A is in position j in A*Pc. ! *         On exit, perm_c may be overwritten by the product of the input ! *         perm_c and a permutation that postorders the elimination tree ! *         of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree ! *         is already in postorder. ! * ! *         If A->Stype = SLU_NR, column permutation vector of size A->nrow, ! *         which describes permutation of columns of transpose(A) ! *         (rows of A) as described above. ! * ! * perm_r  (input/output) int* ! *         If A->Stype = SLU_NC, row permutation vector of size A->nrow, ! *         which defines the permutation matrix Pr, and is determined ! *         by partial pivoting.  perm_r[i] = j means row i of A is in ! *         position j in Pr*A. ! * ! *         If A->Stype = SLU_NR, permutation vector of size A->ncol, which ! *         determines permutation of rows of transpose(A) ! *         (columns of A) as described above. ! * ! *         If options->Fact = SamePattern_SameRowPerm, the pivoting routine ! *         will try to use the input perm_r, unless a certain threshold ! *         criterion is violated. In that case, perm_r is overwritten by a ! *         new permutation determined by partial pivoting or diagonal ! *         threshold pivoting. ! *         Otherwise, perm_r is output argument. ! * ! * etree   (input/output) int*,  dimension (A->ncol) ! *         Elimination tree of Pc'*A'*A*Pc. ! *         If options->Fact != FACTORED and options->Fact != DOFACT, ! *         etree is an input argument, otherwise it is an output argument. ! *         Note: etree is a vector of parent pointers for a forest whose ! *         vertices are the integers 0 to A->ncol-1; etree[root]==A->ncol. ! * ! * equed   (input/output) char* ! *         Specifies the form of equilibration that was done. ! *         = 'N': No equilibration. ! *         = 'R': Row equilibration, i.e., A was premultiplied by diag(R). ! *         = 'C': Column equilibration, i.e., A was postmultiplied by diag(C). ! *         = 'B': Both row and column equilibration, i.e., A was replaced ! *                by diag(R)*A*diag(C). ! *         If options->Fact = FACTORED, equed is an input argument, ! *         otherwise it is an output argument. ! * ! * R       (input/output) double*, dimension (A->nrow) ! *         The row scale factors for A or transpose(A). ! *         If equed = 'R' or 'B', A (if A->Stype = SLU_NC) or transpose(A) ! *             (if A->Stype = SLU_NR) is multiplied on the left by diag(R). ! *         If equed = 'N' or 'C', R is not accessed. ! *         If options->Fact = FACTORED, R is an input argument, ! *             otherwise, R is output. ! *         If options->zFact = FACTORED and equed = 'R' or 'B', each element ! *             of R must be positive. ! * ! * C       (input/output) double*, dimension (A->ncol) ! *         The column scale factors for A or transpose(A). ! *         If equed = 'C' or 'B', A (if A->Stype = SLU_NC) or transpose(A) ! *             (if A->Stype = SLU_NR) is multiplied on the right by diag(C). ! *         If equed = 'N' or 'R', C is not accessed. ! *         If options->Fact = FACTORED, C is an input argument, ! *             otherwise, C is output. ! *         If options->Fact = FACTORED and equed = 'C' or 'B', each element ! *             of C must be positive. ! * ! * L       (output) SuperMatrix* ! *         The factor L from the factorization ! *             Pr*A*Pc=L*U              (if A->Stype SLU_= NC) or ! *             Pr*transpose(A)*Pc=L*U   (if A->Stype = SLU_NR). ! *         Uses compressed row subscripts storage for supernodes, i.e., ! *         L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU. ! * ! * U       (output) SuperMatrix* ! *         The factor U from the factorization ! *             Pr*A*Pc=L*U              (if A->Stype = SLU_NC) or ! *             Pr*transpose(A)*Pc=L*U   (if A->Stype = SLU_NR). ! *         Uses column-wise storage scheme, i.e., U has types: ! *         Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU. ! * ! * work    (workspace/output) void*, size (lwork) (in bytes) ! *         User supplied workspace, should be large enough ! *         to hold data structures for factors L and U. ! *         On exit, if fact is not 'F', L and U point to this array. ! * ! * lwork   (input) int ! *         Specifies the size of work array in bytes. ! *         = 0:  allocate space internally by system malloc; ! *         > 0:  use user-supplied work array of length lwork in bytes, ! *               returns error if space runs out. ! *         = -1: the routine guesses the amount of space needed without ! *               performing the factorization, and returns it in ! *               mem_usage->total_needed; no other side effects. ! * ! *         See argument 'mem_usage' for memory usage statistics. ! * ! * B       (input/output) SuperMatrix* ! *         B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. ! *         On entry, the right hand side matrix. ! *         If B->ncol = 0, only LU decomposition is performed, the triangular ! *                         solve is skipped. ! *         On exit, ! *            if equed = 'N', B is not modified; otherwise ! *            if A->Stype = SLU_NC: ! *               if options->Trans = NOTRANS and equed = 'R' or 'B', ! *                  B is overwritten by diag(R)*B; ! *               if options->Trans = TRANS or CONJ and equed = 'C' of 'B', ! *                  B is overwritten by diag(C)*B; ! *            if A->Stype = SLU_NR: ! *               if options->Trans = NOTRANS and equed = 'C' or 'B', ! *                  B is overwritten by diag(C)*B; ! *               if options->Trans = TRANS or CONJ and equed = 'R' of 'B', ! *                  B is overwritten by diag(R)*B. ! * ! * X       (output) SuperMatrix* ! *         X has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. ! *         If info = 0 or info = A->ncol+1, X contains the solution matrix ! *         to the original system of equations. Note that A and B are modified ! *         on exit if equed is not 'N', and the solution to the equilibrated ! *         system is inv(diag(C))*X if options->Trans = NOTRANS and ! *         equed = 'C' or 'B', or inv(diag(R))*X if options->Trans = 'T' or 'C' ! *         and equed = 'R' or 'B'. ! * ! * recip_pivot_growth (output) double* ! *         The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ). ! *         The infinity norm is used. If recip_pivot_growth is much less ! *         than 1, the stability of the LU factorization could be poor. ! * ! * rcond   (output) double* ! *         The estimate of the reciprocal condition number of the matrix A ! *         after equilibration (if done). If rcond is less than the machine ! *         precision (in particular, if rcond = 0), the matrix is singular ! *         to working precision. This condition is indicated by a return ! *         code of info > 0. ! * ! * FERR    (output) double*, dimension (B->ncol) ! *         The estimated forward error bound for each solution vector ! *         X(j) (the j-th column of the solution matrix X). ! *         If XTRUE is the true solution corresponding to X(j), FERR(j) ! *         is an estimated upper bound for the magnitude of the largest ! *         element in (X(j) - XTRUE) divided by the magnitude of the ! *         largest element in X(j).  The estimate is as reliable as ! *         the estimate for RCOND, and is almost always a slight ! *         overestimate of the true error. ! *         If options->IterRefine = NOREFINE, ferr = 1.0. ! * ! * BERR    (output) double*, dimension (B->ncol) ! *         The componentwise relative backward error of each solution ! *         vector X(j) (i.e., the smallest relative change in ! *         any element of A or B that makes X(j) an exact solution). ! *         If options->IterRefine = NOREFINE, berr = 1.0. ! * ! * Glu      (input/output) GlobalLU_t * ! *          If options->Fact == SamePattern_SameRowPerm, it is an input; ! *              The matrix A will be factorized assuming that a ! *              factorization of a matrix with the same sparsity pattern ! *              and similar numerical values was performed prior to this one. ! *              Therefore, this factorization will reuse both row and column ! *              scaling factors R and C, both row and column permutation ! *              vectors perm_r and perm_c, and the L & U data structures ! *              set up from the previous factorization. ! *          Otherwise, it is an output. ! * ! * mem_usage (output) mem_usage_t* ! *         Record the memory usage statistics, consisting of following fields: ! *         - for_lu (float) ! *           The amount of space used in bytes for L\\U data structures. ! *         - total_needed (float) ! *           The amount of space needed in bytes to perform factorization. ! *         - expansions (int) ! *           The number of memory expansions during the LU factorization. ! * ! * stat   (output) SuperLUStat_t* ! *        Record the statistics on runtime and floating-point operation count. ! *        See slu_util.h for the definition of 'SuperLUStat_t'. ! * ! * info    (output) int* ! *         = 0: successful exit ! *         < 0: if info = -i, the i-th argument had an illegal value ! *         > 0: if info = i, and i is ! *              <= A->ncol: U(i,i) is exactly zero. The factorization has ! *                    been completed, but the factor U is exactly ! *                    singular, so the solution and error bounds ! *                    could not be computed. ! *              = A->ncol+1: U is nonsingular, but RCOND is less than machine ! *                    precision, meaning that the matrix is singular to ! *                    working precision. Nevertheless, the solution and ! *                    error bounds are computed because there are a number ! *                    of situations where the computed solution can be more ! *                    accurate than the value of RCOND would suggest. ! *              > A->ncol+1: number of bytes allocated when memory allocation ! *                    failure occurred, plus A->ncol. ! * </pre> ! */ subroutine dgssvx (& ! argument                 |     type           |   C def           |  C call options , & ! superlu_options_t   *options             &options A , & ! SuperMatrix         *A                   &A1 perm_c , & ! int                 *perm_c               perm_c perm_r , & ! int                 *perm_r               perm_r etree , & ! int                 *etree                etree equed , & ! char                *equed                equed R , & ! double              *R                    R C , & ! double              *C                    C L , & ! SuperMatrix         *L                   &L U , & ! SuperMatrix         *U                   &U work , & ! void                *work                 work lwork , & ! int                  lwork                lwork B , & ! SuperMatrix         *B                   &B1 X , & ! SuperMatrix         *X                   &X recip_pivot_growth , & ! double              *recip_pivot_growth  &rpg rcond , & ! double              *rcond               &rcond ferr , & ! double              *ferr                 ferr berr , & ! double              *berr                 berr Glu , & ! GlobalLU_t          *Glu                 &Glu mem_usage , & ! mem_usage_t         *mem_usage           &smem_usage stat , & ! SuperLUStat_t       *stat                &stat info & ! int                 *info                &info ) & bind ( c , name = 'dgssvx' ) use , intrinsic :: iso_c_binding , only : C_INT , C_CHAR , C_DOUBLE , C_PTR import :: SUPERLU_OPTIONS_T , SUPERMATRIX , SUPERLUSTAT_T , MEM_USAGE_T , GLOBALLU_T implicit none type ( SUPERLU_OPTIONS_T ), intent ( in ) :: options type ( SUPERMATRIX ), intent ( inout ) :: A integer ( kind = C_INT ), intent ( inout ) :: perm_c ( * ) integer ( kind = C_INT ), intent ( inout ) :: perm_r ( * ) integer ( kind = C_INT ), intent ( inout ) :: etree ( * ) character ( kind = C_CHAR ), intent ( inout ) :: equed ( * ) real ( kind = C_DOUBLE ), intent ( inout ) :: R ( * ) real ( kind = C_DOUBLE ), intent ( inout ) :: C ( * ) type ( SUPERMATRIX ), intent ( inout ) :: L type ( SUPERMATRIX ), intent ( inout ) :: U type ( C_PTR ), intent ( out ) :: work integer ( kind = C_INT ), value , intent ( in ) :: lwork type ( SUPERMATRIX ), intent ( inout ) :: B type ( SUPERMATRIX ), intent ( out ) :: X real ( kind = C_DOUBLE ), intent ( out ) :: recip_pivot_growth ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: rcond ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: ferr ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: berr ( * ) type ( GLOBALLU_T ), intent ( inout ) :: Glu type ( MEM_USAGE_T ), intent ( out ) :: mem_usage type ( SUPERLUSTAT_T ), intent ( out ) :: stat integer ( kind = C_INT ), intent ( out ) :: info endsubroutine dgssvx !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatPrint ( stat ) & ! bind ( c , name = \"StatPrint\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( in ) :: stat endsubroutine StatPrint !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . endinterface public :: sulu_env , init_superlu , prep_superlu , fact_superlu , solv_superlu , free_superlu , close_superlu , Destroy_CompCol_Matrix , Destroy_SuperNode_Matrix , & SAMEPATTERN , FACTORED , DOFACT contains !========================================================================================= !< @note ! **Subroutine to set the default LU behaviour** ! ! + sulu%options%Fact               = ```DOFACT``` ! + sulu%options%Equil              = ```YES``` ! + sulu%options%ColPerm            = ```COLAMD``` ! + sulu%options%DiagPivotThresh    = ```1.0``` ! + sulu%options%Trans              = ```NOTRANS``` ! + sulu%options%IterRefine         = ```NOREFINE``` ! + sulu%options%SymmetricMode      = ```NO``` ! + sulu%options%PivotGrowth        = ```NO``` ! + sulu%options%ConditionNumber    = ```NO``` ! + sulu%options%PrintStat          = ```YES``` ! ! @endnote !----------------------------------------------------------------------------------------- subroutine init_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call set_default_options ( sulu % options ) return endsubroutine init_superlu !========================================================================================= !> @note **Subroutine to prepare the [[SULU_ENV]] components** !----------------------------------------------------------------------------------------- subroutine prep_superlu ( sulu ) implicit none type ( sulu_env ), intent ( inout ) :: sulu integer ( kind = I4 ) :: nn , nz , nb nn = sulu % n nz = sulu % nz nb = sulu % nrhs if (. not . allocated ( sulu % perm_c )) then allocate ( sulu % perm_c ( 1 : nn ) ) allocate ( sulu % perm_r ( 1 : nn ) ) allocate ( sulu % etree ( 1 : nn ) ) allocate ( sulu % RR ( 1 : nn ) ) allocate ( sulu % CC ( 1 : nn ) ) allocate ( sulu % ferr ( 1 : nb ) ) allocate ( sulu % berr ( 1 : nb ) ) allocate ( sulu % rpg ( 1 : nb ) ) allocate ( sulu % rcond ( 1 : nb ) ) allocate ( sulu % x ( 1 : nn ) ) endif sulu % x ( 1 : nn ) = 0 call dCreate_CompCol_Matrix ( A = sulu % SMA , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % n , & ! in int nnz = sulu % nz , & ! in int nzval = sulu % a_elt , & ! in double dimension() rowind = sulu % irow , & ! in int dimension() colptr = sulu % jptr , & ! in int dimension() stype = SLU_NC , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smb , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % b , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smx , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % x , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) return endsubroutine prep_superlu !========================================================================================= !< @note ! **Subroutine to factorize the system** ! ! note the directives: ! ! + sulu%options%Fact = ```DOFACT``` ! + sulu%SMB%ncol     = ```0``` ! ! @endnote !----------------------------------------------------------------------------------------- subroutine fact_superlu ( sulu , verbose ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose sulu % lwork = 0 call StatInit ( sulu % stat ) sulu % options % Fact = DOFACT sulu % SMB % ncol = 0 call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) return endsubroutine fact_superlu !========================================================================================= !< @note ! **Subroutine to solve the system** ! ! + If no resolution has yet occured, sulu%first=```true``` !     * sulu%options%Fact = ```FACTORED``` !     * sulu%SMB%ncol     = sulu%nrhs (usually ```1```) ! + otherwise !     * sulu%options%Fact = ```SAMEPATTERN``` !     * sma, smb and smx are recreated but do not forget that we still have: !         - mat%matsulu%irow   => mat%irow !         - mat%matsulu%jptr   => mat%jptr !         - mat%matsulu%a_elt  => mat%a_elt !         - mat%matsulu%b      => mat%b ! ! @endnote ! ! @note ! The solution is retrieved with the pointer *store* of type [[NCFORMAT]] which ! gives access to [[NCFORMAT:nzval]] ! @endnote ! ! @warning ! At the end, the memory is released with the dstruction of *sml* and *smu* ! @endwarning !----------------------------------------------------------------------------------------- subroutine solv_superlu ( sol_x , sulu , verbose ) implicit none real ( kind = R8 ), dimension (:), intent ( inout ) :: sol_x type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose type ( NCFORMAT ), pointer :: Xstore real ( kind = R8 ), pointer :: tabX (:) integer ( kind = I4 ) :: i call StatInit ( sulu % stat ) if ( sulu % first ) then sulu % options % Fact = FACTORED sulu % SMB % ncol = sulu % nrhs else sulu % options % Fact = SAMEPATTERN call prep_superlu ( sulu ) endif call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) call c_f_pointer ( sulu % SMX % Store , XStore ) call c_f_pointer ( XStore % nzval , tabX , [ XStore % nnz ]) do i = 1 , sulu % n sol_x ( i ) = tabX ( i ) enddo nullify ( Xstore , tabX ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) call Destroy_SuperNode_Matrix ( sulu % SML ) call Destroy_CompCol_Matrix ( sulu % SMU ) return endsubroutine solv_superlu !========================================================================================= !< @note Subroutine that actually does nothing yet. Maybe, there will be extra memory that ! could be released here? !----------------------------------------------------------------------------------------- subroutine free_superlu () implicit none !type(SULU_ENV), intent(inout) :: sulu return endsubroutine free_superlu !========================================================================================= !> @note **Subroutine to close the SuperLU process, with memory release** !----------------------------------------------------------------------------------------- subroutine close_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call Destroy_CompCol_Matrix ( sulu % SMA ) call Destroy_Dense_Matrix ( sulu % smb ) call Destroy_Dense_Matrix ( sulu % smx ) deallocate ( sulu % perm_c ) deallocate ( sulu % perm_r ) deallocate ( sulu % etree ) deallocate ( sulu % RR ) deallocate ( sulu % CC ) deallocate ( sulu % ferr ) deallocate ( sulu % berr ) deallocate ( sulu % rpg ) deallocate ( sulu % rcond ) return endsubroutine close_superlu endmodule sulu_wrapper","tags":""},{"title":"umfpack.f90 – MSOLV-fortran","loc":"sourcefile/umfpack.f90.html","text":"Files dependent on this one sourcefile~~umfpack.f90~~AfferentGraph sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mumfpack Source Code umfpack.f90 Source Code ! ====================================================================== ! UMFPACK Fortran interface via the mUMFPACK module ! ====================================================================== ! Version 1.0 (Apr 23, 2014) for UMFPACK version 5.6.2 ! ====================================================================== ! Compile with any Fortran compiler with support of iso_c_binding module ! and link with the UMFPACK C library: ! e.g., gfortran umfpack.f90 my_code.f90 -lumfpack ! ====================================================================== module mumfpack ! ====================================================================== use iso_c_binding implicit none ! private size constants integer , parameter , private :: i4 = 4 , & ! size of default integer i8 = 8 , & ! size of long integer ip = c_intptr_t , & ! size of pointers used in basic Fortran wrappers r4 = 4 , & ! size of single precision real/complex r8 = 8 ! size of double precision real/complex ! default pointers to UMFPACK Symbolic and Numeric objects type ( c_ptr ), private :: iSymbolic = c_null_ptr , iNumeric = c_null_ptr ! ====================================================================== ! UMFPACK constants ! ====================================================================== ! size of Info and Control arrays integer , parameter :: UMFPACK_INFO = 90 , & UMFPACK_CONTROL = 20 ! Version, copyright, and license character ( 30 ), parameter :: UMFPACK_VERSION = \"UMFPACK V5.6.2 (Apr 25, 2013)\" character ( 79 ), parameter :: UMFPACK_COPYRIGHT = \"UMFPACK:  Copyright (c) 2005-2012 by Timothy A. Davis.  All Rights Reserved.\" character ( 12 ), parameter :: UMFPACK_DATE = \"Apr 25, 2013\" integer , parameter :: UMFPACK_MAIN_VERSION = 5 , & UMFPACK_SUB_VERSION = 6 , & UMFPACK_SUBSUB_VERSION = 2 ! UMFPACK_VER_CODE(main,sub) ((main) * 1000 + (sub)) ! UMFPACK_VER UMFPACK_VER_CODE(UMFPACK_MAIN_VERSION,UMFPACK_SUB_VERSION) ! contents of Info enum , bind ( c ) enumerator :: & ! returned by all routines that use Info: UMFPACK_STATUS = 0 , & ! /* UMFPACK_OK, or other result */ UMFPACK_NROW = 1 , & ! /* n_row input value */ UMFPACK_NCOL = 16 , & ! /* n_col input value */ UMFPACK_NZ = 2 , & ! /* # of entries in A */ ! computed in UMFPACK_*symbolic and UMFPACK_numeric: UMFPACK_SIZE_OF_UNIT = 3 , & ! /* sizeof (Unit) */ ! computed in UMFPACK_*symbolic: UMFPACK_SIZE_OF_INT = 4 , & ! /* sizeof (int) */ UMFPACK_SIZE_OF_LONG = 5 , & ! /* sizeof (SuiteSparse_long) */ UMFPACK_SIZE_OF_POINTER = 6 , & ! /* sizeof (void *) */ UMFPACK_SIZE_OF_ENTRY = 7 , & ! /* sizeof (Entry), real or complex */ UMFPACK_NDENSE_ROW = 8 , & ! /* number of dense rows */ UMFPACK_NEMPTY_ROW = 9 , & ! /* number of empty rows */ UMFPACK_NDENSE_COL = 10 , & ! /* number of dense rows */ UMFPACK_NEMPTY_COL = 11 , & ! /* number of empty rows */ UMFPACK_SYMBOLIC_DEFRAG = 12 , & ! /* # of memory compactions */ UMFPACK_SYMBOLIC_PEAK_MEMORY = 13 , & ! /* memory used by symbolic analysis */ UMFPACK_SYMBOLIC_SIZE = 14 , & ! /* size of Symbolic object, in Units */ UMFPACK_SYMBOLIC_TIME = 15 , & ! /* time (sec.) for symbolic analysis */ UMFPACK_SYMBOLIC_WALLTIME = 17 , & ! /* wall clock time for sym. analysis */ UMFPACK_STRATEGY_USED = 18 , & ! /* strategy used: sym, unsym */ UMFPACK_ORDERING_USED = 19 , & ! /* ordering used: colamd, amd, given */ UMFPACK_QFIXED = 31 , & ! /* whether Q is fixed or refined */ UMFPACK_DIAG_PREFERRED = 32 , & ! /* whether diagonal pivoting attempted*/ UMFPACK_PATTERN_SYMMETRY = 33 , & ! /* symmetry of pattern of S */ UMFPACK_NZ_A_PLUS_AT = 34 , & ! /* nnz (S+S'), excl. diagonal */ UMFPACK_NZDIAG = 35 , & ! /* nnz (diag (S)) */ ! AMD statistics, computed in UMFPACK_*symbolic: UMFPACK_SYMMETRIC_LUNZ = 36 , & ! /* nz in L+U, if AMD ordering used */ UMFPACK_SYMMETRIC_FLOPS = 37 , & ! /* flops for LU, if AMD ordering used */ UMFPACK_SYMMETRIC_NDENSE = 38 , & ! /* # of \"dense\" rows/cols in S+S' */ UMFPACK_SYMMETRIC_DMAX = 39 , & ! /* max nz in cols of L, for AMD */ ! 51:55 unused ! statistics for singleton pruning UMFPACK_COL_SINGLETONS = 56 , & ! /* # of column singletons */ UMFPACK_ROW_SINGLETONS = 57 , & ! /* # of row singletons */ UMFPACK_N2 = 58 , & ! /* size of S */ UMFPACK_S_SYMMETRIC = 59 , & ! /* 1 if S square and symmetricly perm.*/ ! estimates computed in UMFPACK_*symbolic: UMFPACK_NUMERIC_SIZE_ESTIMATE = 20 , & ! /* final size of Numeric->Memory */ UMFPACK_PEAK_MEMORY_ESTIMATE = 21 , & ! /* for symbolic & numeric */ UMFPACK_FLOPS_ESTIMATE = 22 , & ! /* flop count */ UMFPACK_LNZ_ESTIMATE = 23 , & ! /* nz in L, incl. diagonal */ UMFPACK_UNZ_ESTIMATE = 24 , & ! /* nz in U, incl. diagonal */ UMFPACK_VARIABLE_INIT_ESTIMATE = 25 , & ! /* initial size of Numeric->Memory*/ UMFPACK_VARIABLE_PEAK_ESTIMATE = 26 , & ! /* peak size of Numeric->Memory */ UMFPACK_VARIABLE_FINAL_ESTIMATE = 27 , & ! /* final size of Numeric->Memory */ UMFPACK_MAX_FRONT_SIZE_ESTIMATE = 28 , & ! /* max frontal matrix size */ UMFPACK_MAX_FRONT_NROWS_ESTIMATE = 29 , & ! /* max # rows in any front */ UMFPACK_MAX_FRONT_NCOLS_ESTIMATE = 30 , & ! /* max # columns in any front */ ! exact values, (estimates shown above) computed in UMFPACK_numeric: UMFPACK_NUMERIC_SIZE = 40 , & ! /* final size of Numeric->Memory */ UMFPACK_PEAK_MEMORY = 41 , & ! /* for symbolic & numeric */ UMFPACK_FLOPS = 42 , & ! /* flop count */ UMFPACK_LNZ = 43 , & ! /* nz in L, incl. diagonal */ UMFPACK_UNZ = 44 , & ! /* nz in U, incl. diagonal */ UMFPACK_VARIABLE_INIT = 45 , & ! /* initial size of Numeric->Memory*/ UMFPACK_VARIABLE_PEAK = 46 , & ! /* peak size of Numeric->Memory */ UMFPACK_VARIABLE_FINAL = 47 , & ! /* final size of Numeric->Memory */ UMFPACK_MAX_FRONT_SIZE = 48 , & ! /* max frontal matrix size */ UMFPACK_MAX_FRONT_NROWS = 49 , & ! /* max # rows in any front */ UMFPACK_MAX_FRONT_NCOLS = 50 , & ! /* max # columns in any front */ ! computed in UMFPACK_numeric: UMFPACK_NUMERIC_DEFRAG = 60 , & ! /* # of garbage collections */ UMFPACK_NUMERIC_REALLOC = 61 , & ! /* # of memory reallocations */ UMFPACK_NUMERIC_COSTLY_REALLOC = 62 , & ! /* # of costlly memory realloc's */ UMFPACK_COMPRESSED_PATTERN = 63 , & ! /* # of integers in LU pattern */ UMFPACK_LU_ENTRIES = 64 , & ! /* # of reals in LU factors */ UMFPACK_NUMERIC_TIME = 65 , & ! /* numeric factorization time */ UMFPACK_UDIAG_NZ = 66 , & ! /* nz on diagonal of U */ UMFPACK_RCOND = 67 , & ! /* est. reciprocal condition # */ UMFPACK_WAS_SCALED = 68 , & ! /* none, max row, or sum row */ UMFPACK_RSMIN = 69 , & ! /* min (max row) or min (sum row) */ UMFPACK_RSMAX = 70 , & ! /* max (max row) or max (sum row) */ UMFPACK_UMIN = 71 , & ! /* min abs diagonal entry of U */ UMFPACK_UMAX = 72 , & ! /* max abs diagonal entry of U */ UMFPACK_ALLOC_INIT_USED = 73 , & ! /* alloc_init parameter used */ UMFPACK_FORCED_UPDATES = 74 , & ! /* # of forced updates */ UMFPACK_NUMERIC_WALLTIME = 75 , & ! /* numeric wall clock time */ UMFPACK_NOFF_DIAG = 76 , & ! /* number of off-diagonal pivots */ UMFPACK_ALL_LNZ = 77 , & ! /* nz in L, if no dropped entries */ UMFPACK_ALL_UNZ = 78 , & ! /* nz in U, if no dropped entries */ UMFPACK_NZDROPPED = 79 , & ! /* # of dropped small entries */ ! computed in UMFPACK_solve: UMFPACK_IR_TAKEN = 80 , & ! /* # of iterative refinement steps taken */ UMFPACK_IR_ATTEMPTED = 81 , & ! /* # of iter. refinement steps attempted */ UMFPACK_OMEGA1 = 82 , & ! /* omega1, sparse backward error estimate */ UMFPACK_OMEGA2 = 83 , & ! /* omega2, sparse backward error estimate */ UMFPACK_SOLVE_FLOPS = 84 , & ! /* flop count for solve */ UMFPACK_SOLVE_TIME = 85 , & ! /* solve time (seconds) */ UMFPACK_SOLVE_WALLTIME = 86 ! /* solve time (wall clock, seconds) */ ! Info(87,88,89) unused ! Unused parts of Info may be used in future versions of UMFPACK. end enum ! contents of Control enum , bind ( c ) enumerator :: & ! used in all UMFPACK_report_* routines: UMFPACK_PRL = 0 , & ! /* print level */ ! used in UMFPACK_*symbolic only: UMFPACK_DENSE_ROW = 1 , & ! /* dense row parameter */ UMFPACK_DENSE_COL = 2 , & ! /* dense col parameter */ UMFPACK_BLOCK_SIZE = 4 , & ! /* BLAS-3 block size */ UMFPACK_STRATEGY = 5 , & ! /* auto, symmetric, or unsym. */ UMFPACK_ORDERING = 10 , & ! /* ordering method to use */ UMFPACK_FIXQ = 13 , & ! /* -1: no fixQ, 0: default, 1: fixQ */ UMFPACK_AMD_DENSE = 14 , & ! /* for AMD ordering */ UMFPACK_AGGRESSIVE = 19 , & ! /* whether or not to use aggressive */ UMFPACK_SINGLETONS = 11 , & ! /* singleton filter on if true */ ! used in UMFPACK_*numeric only: UMFPACK_PIVOT_TOLERANCE = 3 , & ! /* threshold partial pivoting setting */ UMFPACK_ALLOC_INIT = 6 , & ! /* initial allocation ratio */ UMFPACK_SYM_PIVOT_TOLERANCE = 15 , & ! /* threshold, only for diag. entries */ UMFPACK_SCALE = 16 , & ! /* what row scaling to do */ UMFPACK_FRONT_ALLOC_INIT = 17 , & ! /* frontal matrix allocation ratio */ UMFPACK_DROPTOL = 18 , & ! /* drop tolerance for entries in L,U */ ! used in UMFPACK_*solve only: UMFPACK_IRSTEP = 7 , & ! /* max # of iterative refinements */ ! compile-time settings - Control(8:11) cannot be changed at run time: UMFPACK_COMPILED_WITH_BLAS = 8 ! /* uses the BLAS */ end enum ! /* 9,12: unused */ ! Control(UMFPACK_STRATEGY) is one of the following: enum , bind ( c ) ; enumerator :: & UMFPACK_STRATEGY_AUTO = 0 , & ! /* use sym. or unsym. strategy */ UMFPACK_STRATEGY_UNSYMMETRIC , & ! /* COLAMD(A), coletree postorder, not prefer diag*/ UMFPACK_STRATEGY_OBSOLETE , & ! /* 2-by-2 is no longer available */ UMFPACK_STRATEGY_SYMMETRIC ! /* AMD(A+A'), no coletree postorder, prefer diagonal */ end enum ! Control(UMFPACK_SCALE) is one of the following: enum , bind ( c ) ; enumerator :: & UMFPACK_SCALE_NONE = 0 , & ! /* no scaling */ UMFPACK_SCALE_SUM , & ! /* default: divide each row by sum (abs (row))*/ UMFPACK_SCALE_MAX ! /* divide each row by max (abs (row)) */ end enum ! Control(UMFPACK_ORDERING) and Info(UMFPACK_ORDERING_USED) are one of: enum , bind ( c ) ; enumerator :: & UMFPACK_ORDERING_CHOLMOD = 0 , & ! /* use CHOLMOD (AMD/COLAMD then METIS)*/ UMFPACK_ORDERING_AMD , & ! /* use AMD/COLAMD */ UMFPACK_ORDERING_GIVEN , & ! /* user-provided Qinit */ UMFPACK_ORDERING_METIS , & ! /* use METIS */ UMFPACK_ORDERING_BEST , & ! /* try many orderings, pick best */ UMFPACK_ORDERING_NONE , & ! /* natural ordering */ UMFPACK_ORDERING_USER ! /* user-provided function */ ! /* AMD/COLAMD means: use AMD for symmetric strategy, COLAMD for unsymmetric */ end enum ! status codes enum , bind ( c ) ; enumerator :: & UMFPACK_OK = 0 , & ! /* status > 0 means a warning, but the method was successful anyway. */ ! /* A Symbolic or Numeric object was still created. */ UMFPACK_WARNING_singular_matrix = 1 , & ! /* The following warnings were added in umfpack_*_get_determinant */ UMFPACK_WARNING_determinant_underflow = 2 , & UMFPACK_WARNING_determinant_overflow = 3 , & ! /* status < 0 means an error, and the method was not successful. */ ! /* No Symbolic of Numeric object was created. */ UMFPACK_ERROR_out_of_memory =- 1 , & UMFPACK_ERROR_invalid_Numeric_object =- 3 , & UMFPACK_ERROR_invalid_Symbolic_object =- 4 , & UMFPACK_ERROR_argument_missing =- 5 , & UMFPACK_ERROR_n_nonpositive =- 6 , & UMFPACK_ERROR_invalid_matrix =- 8 , & UMFPACK_ERROR_different_pattern =- 11 , & UMFPACK_ERROR_invalid_system =- 13 , & UMFPACK_ERROR_invalid_permutation =- 15 , & UMFPACK_ERROR_internal_error =- 911 , & ! /* yes, call me if you get this! */ UMFPACK_ERROR_file_IO =- 17 , & UMFPACK_ERROR_ordering_failed =- 18 end enum ! solve codes ! /* Solve the system ( )x=b, where ( ) is defined below.  \"t\" refers to the */ ! /* linear algebraic transpose (complex conjugate if A is complex), or the (') */ ! /* operator in MATLAB.  \"at\" refers to the array transpose, or the (.') */ ! /* operator in MATLAB. */ enum , bind ( c ) ; enumerator :: & UMFPACK_A = 0 , & ! /* Ax=b    */ UMFPACK_At = 1 , & ! /* A'x=b   */ UMFPACK_Aat = 2 , & ! /* A.'x=b  */ UMFPACK_Pt_L = 3 , & ! /* P'Lx=b  */ UMFPACK_L = 4 , & ! /* Lx=b    */ UMFPACK_Lt_P = 5 , & ! /* L'Px=b  */ UMFPACK_Lat_P = 6 , & ! /* L.'Px=b */ UMFPACK_Lt = 7 , & ! /* L'x=b   */ UMFPACK_Lat = 8 , & ! /* L.'x=b  */ UMFPACK_U_Qt = 9 , & ! /* UQ'x=b  */ UMFPACK_U = 10 , & ! /* Ux=b    */ UMFPACK_Q_Ut = 11 , & ! /* QU'x=b  */ UMFPACK_Q_Uat = 12 , & ! /* QU.'x=b */ UMFPACK_Ut = 13 , & ! /* U'x=b   */ UMFPACK_Uat = 14 ! /* U.'x=b  */ end enum ! ====================================================================== ! Full UMFPACK interface: interfaces to C functions ! ====================================================================== interface ! int umfpack_di_symbolic(int n_row,int n_col,const int Ap [ ],const int Ai [ ],const double Ax [ ], ! void **Symbolic,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) bind ( c , name = 'umfpack_di_symbolic' ) import c_int , c_ptr integer ( c_int ), value :: n_row , n_col type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ) :: Symbolic type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) bind ( c , name = 'umfpack_zi_symbolic' ) import c_int , c_ptr integer ( c_int ), value :: n_row , n_col type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ) :: Symbolic type ( c_ptr ), value :: Control , Info end function ! int umfpack_di_numeric(const int Ap [ ],const int Ai [ ],const double Ax [ ], ! void *Symbolic,void **Numeric,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) bind ( c , name = 'umfpack_di_numeric' ) import c_int , c_ptr type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ), value , intent ( in ) :: Symbolic type ( c_ptr ) :: Numeric type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) bind ( c , name = 'umfpack_zi_numeric' ) import c_int , c_ptr type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ), value , intent ( in ) :: Symbolic type ( c_ptr ) :: Numeric type ( c_ptr ), value :: Control , Info end function ! int umfpack_di_solve(int sys,const int Ap [ ],const int Ai [ ],const double Ax [ ],double X [ ],const double B [ ], ! void *Numeric,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) bind ( c , name = 'umfpack_di_solve' ) import c_int , c_ptr integer ( c_int ), value :: sys type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ), value :: X type ( c_ptr ), value , intent ( in ) :: B type ( c_ptr ), value , intent ( in ) :: Numeric type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) bind ( c , name = 'umfpack_zi_solve' ) import c_int , c_ptr integer ( c_int ), value :: sys type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ), value :: Xx , Xz type ( c_ptr ), value , intent ( in ) :: Bx , Bz type ( c_ptr ), value , intent ( in ) :: Numeric type ( c_ptr ), value :: Control , Info end function ! void umfpack_di_free_symbolic(void **Symbolic) ; subroutine c_umfpack_di_free_symbolic ( Symbolic ) bind ( c , name = 'umfpack_di_free_symbolic' ) import c_ptr type ( c_ptr ) :: Symbolic end subroutine subroutine c_umfpack_zi_free_symbolic ( Symbolic ) bind ( c , name = 'umfpack_zi_free_symbolic' ) import c_ptr type ( c_ptr ) :: Symbolic end subroutine ! void umfpack_di_free_numeric(void **Numeric) ; subroutine c_umfpack_di_free_numeric ( Numeric ) bind ( c , name = 'umfpack_di_free_numeric' ) import c_ptr type ( c_ptr ) :: Numeric end subroutine subroutine c_umfpack_zi_free_numeric ( Numeric ) bind ( c , name = 'umfpack_zi_free_numeric' ) import c_ptr type ( c_ptr ) :: Numeric end subroutine ! void umfpack_di_defaults(double Control [UMFPACK_CONTROL]) ; subroutine c_umfpack_di_defaults ( Control ) bind ( c , name = 'umfpack_di_defaults' ) import c_ptr type ( c_ptr ), value :: Control end subroutine subroutine c_umfpack_zi_defaults ( Control ) bind ( c , name = 'umfpack_zi_defaults' ) import c_ptr type ( c_ptr ), value :: Control end subroutine ! int umfpack_di_scale(double X [ ],const double B [ ],void *Numeric) ; integer ( c_int ) function c_umfpack_di_scale ( X , B , Numeric ) bind ( c , name = 'umfpack_di_scale' ) import c_int , c_ptr type ( c_ptr ), value :: X type ( c_ptr ), value , intent ( in ) :: B type ( c_ptr ), value , intent ( in ) :: Numeric end function integer ( c_int ) function c_umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) bind ( c , name = 'umfpack_zi_scale' ) import c_int , c_ptr type ( c_ptr ), value :: Xx , Xz type ( c_ptr ), value , intent ( in ) :: Bx , Bz type ( c_ptr ), value , intent ( in ) :: Numeric end function ! int umfpack_di_save_numeric(void *Numeric,char *filename) ; integer ( c_int ) function c_umfpack_di_save_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_di_save_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Numeric character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_save_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_zi_save_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Numeric character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_save_symbolic(void *Symbolic,char *filename) ; integer ( c_int ) function c_umfpack_di_save_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_di_save_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_save_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_zi_save_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_load_numeric(void **Numeric,char *filename) ; integer ( c_int ) function c_umfpack_di_load_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_di_load_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Numeric character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_load_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_zi_load_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Numeric character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_load_symbolic(void **Symbolic,char *filename) ; integer ( c_int ) function c_umfpack_di_load_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_di_load_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_load_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_zi_load_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function ! void umfpack_di_report_status(const double Control [UMFPACK_CONTROL],int status) ; subroutine c_umfpack_di_report_status ( Control , status ) bind ( c , name = 'umfpack_di_report_status' ) import c_ptr , c_int type ( c_ptr ), value :: Control integer ( c_int ), value :: status end subroutine subroutine c_umfpack_zi_report_status ( Control , status ) bind ( c , name = 'umfpack_zi_report_status' ) import c_ptr , c_int type ( c_ptr ), value :: Control integer ( c_int ), value :: status end subroutine ! void umfpack_di_report_control(const double Control [UMFPACK_CONTROL]) ; subroutine c_umfpack_di_report_control ( Control ) bind ( c , name = 'umfpack_di_report_control' ) import c_ptr type ( c_ptr ), value :: Control end subroutine subroutine c_umfpack_zi_report_control ( Control ) bind ( c , name = 'umfpack_zi_report_control' ) import c_ptr type ( c_ptr ), value :: Control end subroutine ! void umfpack_di_report_info(const double Control [UMFPACK_CONTROL],const double Info [UMFPACK_INFO]) ; subroutine c_umfpack_di_report_info ( Control , Info ) bind ( c , name = 'umfpack_di_report_info' ) import c_ptr type ( c_ptr ), value :: Control , Info end subroutine subroutine c_umfpack_zi_report_info ( Control , Info ) bind ( c , name = 'umfpack_zi_report_info' ) import c_ptr type ( c_ptr ), value :: Control , Info end subroutine ! int umfpack_di_report_numeric(void *Numeric,const double Control [UMFPACK_CONTROL]) ; integer ( c_int ) function c_umfpack_di_report_numeric ( Numeric , Control ) bind ( c , name = 'umfpack_di_report_numeric' ) import c_int , c_ptr type ( c_ptr ), value :: Numeric , Control end function integer ( c_int ) function c_umfpack_zi_report_numeric ( Numeric , Control ) bind ( c , name = 'umfpack_zi_report_numeric' ) import c_int , c_ptr type ( c_ptr ), value :: Numeric , Control end function ! int umfpack_di_report_symbolic(void *Symbolic,const double Control [UMFPACK_CONTROL]) ; integer ( c_int ) function c_umfpack_di_report_symbolic ( Symbolic , Control ) bind ( c , name = 'umfpack_di_report_symbolic' ) import c_int , c_ptr type ( c_ptr ), value :: Symbolic , Control end function integer ( c_int ) function c_umfpack_zi_report_symbolic ( Symbolic , Control ) bind ( c , name = 'umfpack_zi_report_symbolic' ) import c_int , c_ptr type ( c_ptr ), value :: Symbolic , Control end function end interface ! ====================================================================== ! Full UMFPACK interface: overloaded names ! ====================================================================== interface umfpack_zi_symbolic module procedure umfpack_zi_symbolic , umfpack_ci_symbolic end interface interface s_umfpack_zi_symbolic module procedure s_umfpack_zi_symbolic , s_umfpack_ci_symbolic end interface interface umfpack_symbolic module procedure umfpack_di_symbolic , umfpack_zi_symbolic , umfpack_ci_symbolic end interface interface s_umfpack_symbolic module procedure s_umfpack_di_symbolic , s_umfpack_zi_symbolic , s_umfpack_ci_symbolic end interface interface umfpack_zi_numeric module procedure umfpack_zi_numeric , umfpack_ci_numeric end interface interface s_umfpack_zi_numeric module procedure s_umfpack_zi_numeric , s_umfpack_ci_numeric end interface interface umfpack_numeric module procedure umfpack_di_numeric , umfpack_zi_numeric , umfpack_ci_numeric end interface interface s_umfpack_numeric module procedure s_umfpack_di_numeric , s_umfpack_zi_numeric , s_umfpack_ci_numeric end interface interface umfpack_zi_solve module procedure umfpack_zi_solve , umfpack_ci_solve end interface interface s_umfpack_zi_solve module procedure s_umfpack_zi_solve , s_umfpack_ci_solve end interface interface umfpack_solve module procedure umfpack_di_solve , umfpack_zi_solve , umfpack_ci_solve end interface interface s_umfpack_solve module procedure s_umfpack_di_solve , s_umfpack_zi_solve , s_umfpack_ci_solve end interface interface s_umfpack_free_symbolic module procedure umfpack_free_symbolic end interface interface s_umfpack_di_free_symbolic module procedure umfpack_di_free_symbolic end interface interface s_umfpack_zi_free_symbolic module procedure umfpack_zi_free_symbolic end interface interface s_umfpack_free_numeric module procedure umfpack_free_numeric end interface interface s_umfpack_di_free_numeric module procedure umfpack_di_free_numeric end interface interface s_umfpack_zi_free_numeric module procedure umfpack_zi_free_numeric end interface interface s_umfpack_defaults module procedure umfpack_defaults end interface interface s_umfpack_di_defaults module procedure umfpack_di_defaults end interface interface s_umfpack_zi_defaults module procedure umfpack_zi_defaults end interface ! a conflict with the constant UMFPACK_SCALE interface umfpack_zi_scale module procedure umfpack_zi_scale , umfpack_ci_scale end interface interface umfpack_scale_function module procedure umfpack_di_scale , umfpack_zi_scale , umfpack_ci_scale end interface interface s_umfpack_zi_scale module procedure s_umfpack_zi_scale , s_umfpack_ci_scale end interface interface s_umfpack_scale module procedure s_umfpack_di_scale , s_umfpack_zi_scale , s_umfpack_ci_scale end interface interface s_umfpack_report_control module procedure umfpack_report_control end interface interface s_umfpack_di_report_control module procedure umfpack_di_report_control end interface interface s_umfpack_zi_report_control module procedure umfpack_zi_report_control end interface interface s_umfpack_report_info module procedure umfpack_report_info end interface interface s_umfpack_di_report_info module procedure umfpack_di_report_info end interface interface s_umfpack_zi_report_info module procedure umfpack_zi_report_info end interface ! ====================================================================== ! Basic UMFPACK interface: overloaded names ! ====================================================================== interface umf4csym module procedure umf4csym , umf4csym_ip end interface interface umf4zsym module procedure umf4zsym , umf4zsym_ip , umf4csym , umf4csym_ip end interface interface umf4sym module procedure umf4sym , umf4sym_ip , umf4zsym , umf4zsym_ip , umf4csym , umf4csym_ip end interface interface umf4cnum module procedure umf4cnum , umf4cnum_ip end interface interface umf4znum module procedure umf4znum , umf4znum_ip , umf4cnum , umf4cnum_ip end interface interface umf4num module procedure umf4num , umf4num_ip , umf4znum , umf4znum_ip , umf4cnum , umf4cnum_ip end interface interface umf4csolr module procedure umf4csolr , umf4csolr_ip end interface interface umf4zsolr module procedure umf4zsolr , umf4zsolr_ip , umf4csolr , umf4csolr_ip end interface interface umf4solr module procedure umf4solr , umf4solr_ip , umf4zsolr , umf4zsolr_ip , umf4csolr , umf4csolr_ip end interface interface umf4csol module procedure umf4csol , umf4csol_ip end interface interface umf4zsol module procedure umf4zsol , umf4zsol_ip , umf4csol , umf4csol_ip end interface interface umf4sol module procedure umf4sol , umf4sol_ip , umf4zsol , umf4zsol_ip , umf4csol , umf4csol_ip end interface interface umf4cscal module procedure umf4cscal , umf4cscal_ip end interface interface umf4zscal module procedure umf4zscal , umf4zscal_ip , umf4cscal , umf4cscal_ip end interface interface umf4scal module procedure umf4scal , umf4scal_ip , umf4zscal , umf4zscal_ip , umf4cscal , umf4cscal_ip end interface interface umf4cfnum module procedure umf4cfnum , umf4cfnum_ip end interface interface umf4zfnum module procedure umf4zfnum , umf4zfnum_ip end interface interface umf4fnum module procedure umf4fnum , umf4fnum_ip end interface interface umf4cfsym module procedure umf4cfsym , umf4cfsym_ip end interface interface umf4zfsym module procedure umf4zfsym , umf4zfsym_ip end interface interface umf4fsym module procedure umf4fsym , umf4fsym_ip end interface interface umf4csnum module procedure umf4csnum , umf4csnum_ip end interface interface umf4zsnum module procedure umf4zsnum , umf4zsnum_ip end interface interface umf4snum module procedure umf4snum , umf4snum_ip end interface interface umf4cssym module procedure umf4cssym , umf4cssym_ip end interface interface umf4zssym module procedure umf4zssym , umf4zssym_ip end interface interface umf4ssym module procedure umf4ssym , umf4ssym_ip end interface interface umf4clnum module procedure umf4clnum , umf4clnum_ip end interface interface umf4zlnum module procedure umf4zlnum , umf4zlnum_ip end interface interface umf4lnum module procedure umf4lnum , umf4lnum_ip end interface interface umf4clsym module procedure umf4clsym , umf4clsym_ip end interface interface umf4zlsym module procedure umf4zlsym , umf4zlsym_ip end interface interface umf4lsym module procedure umf4lsym , umf4lsym_ip end interface ! ====================================================================== ! Defined operator .umfpack. ! ====================================================================== type tCSC_di integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) end type type tCSC_zi integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) real ( r8 ), allocatable :: Az (:) end type type tCSC_ci integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) complex ( r8 ), allocatable :: Ax (:) end type type tCSR_di integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) end type type tCSR_zi integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) real ( r8 ), allocatable :: Az (:) end type type tCSR_ci integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) complex ( r8 ), allocatable :: Ax (:) end type type tVec_zi real ( r8 ), allocatable :: x (:) real ( r8 ), allocatable :: z (:) end type type pCSC_di integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) end type type pCSC_zi integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) real ( r8 ), pointer :: Az (:) end type type pCSC_ci integer , pointer :: Ap (:) integer , pointer :: Ai (:) complex ( r8 ), pointer :: Ax (:) end type type pCSR_di integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) end type type pCSR_zi integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) real ( r8 ), pointer :: Az (:) end type type pCSR_ci integer , pointer :: Ap (:) integer , pointer :: Ai (:) complex ( r8 ), pointer :: Ax (:) end type type pVec_zi real ( r8 ), pointer :: x (:) real ( r8 ), pointer :: z (:) end type ! overloaded structure constructors (not implemented in g95) ! interface pCSC_di ! module procedure make_CSC_di ! end interface ! interface pCSC_zi ! module procedure make_CSC_zi ! end interface ! interface pCSC_ci ! module procedure make_CSC_ci ! end interface interface pCSC module procedure make_CSC_di , make_CSC_zi , make_CSC_ci end interface interface pCSR module procedure make_CSR_di , make_CSR_zi , make_CSR_ci end interface ! interface pVec_zi ! module procedure make_Vec_zi ! end interface interface pVec module procedure make_Vec_zi end interface interface operator (. umfpack .) module procedure umfpack_di_operator_CSC , umfpack_zi_operator_CSC , umfpack_ci_operator_CSC , & umfpack_di_operator_CSR , umfpack_zi_operator_CSR , umfpack_ci_operator_CSR , & umfpack_di_operator_pCSC , umfpack_zi_operator_pCSC , umfpack_ci_operator_pCSC , & umfpack_di_operator_pCSR , umfpack_zi_operator_pCSR , umfpack_ci_operator_pCSR end interface contains ! ====================================================================== ! Full UMFPACK interface: Fortran wrappers ! ====================================================================== integer function umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_symbolic = c_umfpack_di_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) real ( r8 ), target , intent ( in ) :: Az ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_Az = c_loc ( Az ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_symbolic = c_umfpack_zi_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) real ( r8 ), intent ( in ) :: Az ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_null_ptr if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_symbolic = c_umfpack_zi_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_numeric = c_umfpack_di_numeric ( c_Ap , c_Ai , c_Ax , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_loc ( Az ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_numeric = c_umfpack_zi_numeric ( c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_null_ptr if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_numeric = c_umfpack_zi_numeric ( c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) real ( r8 ), target :: X ( * ) real ( r8 ), target , intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_X , c_B , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_X = c_loc ( X ) c_B = c_loc ( B ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_solve = c_umfpack_di_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_X , c_B , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: X ( * ) real ( r8 ), intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), target :: Xx ( * ), Xz ( * ) real ( r8 ), target , intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif if ( present ( Az )) then ; c_Az = c_loc ( Az ) ; else ; c_Az = c_null_ptr ; endif c_Xx = c_loc ( Xx ) c_Xz = c_loc ( Xz ) c_Bx = c_loc ( Bx ) c_Bz = c_loc ( Bz ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_solve = c_umfpack_zi_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: Xx ( * ), Xz ( * ) real ( r8 ), intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , optional , intent ( in ) :: Ax ( * ) complex ( r8 ), target :: Xx ( * ) complex ( r8 ), target , intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_Az = c_null_ptr c_Xx = c_loc ( Xx ) c_Xz = c_null_ptr c_Bx = c_loc ( Bx ) c_Bz = c_null_ptr if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_solve = c_umfpack_zi_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), optional , intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: Xx ( * ) complex ( r8 ), intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine subroutine umfpack_di_free_symbolic ( Symbolic ) type ( c_ptr ), optional :: Symbolic type ( c_ptr ) :: c_Symbolic if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif call c_umfpack_di_free_symbolic ( c_Symbolic ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end subroutine subroutine umfpack_zi_free_symbolic ( Symbolic ) type ( c_ptr ), optional :: Symbolic type ( c_ptr ) :: c_Symbolic if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif call c_umfpack_zi_free_symbolic ( c_Symbolic ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end subroutine subroutine umfpack_free_symbolic ( Symbolic , version ) type ( c_ptr ), optional :: Symbolic character ( * ), optional :: version type ( c_ptr ) :: c_Symbolic character ( 2 ) :: c_version if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_free_symbolic ( c_Symbolic ) case ( \"ci\" ) ; call umfpack_zi_free_symbolic ( c_Symbolic ) case default ; call umfpack_di_free_symbolic ( c_Symbolic ) end select end subroutine subroutine umfpack_di_free_numeric ( Numeric ) type ( c_ptr ), optional :: Numeric type ( c_ptr ) :: c_Numeric if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif call c_umfpack_di_free_numeric ( c_Numeric ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end subroutine subroutine umfpack_zi_free_numeric ( Numeric ) type ( c_ptr ), optional :: Numeric type ( c_ptr ) :: c_Numeric if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif call c_umfpack_zi_free_numeric ( c_Numeric ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end subroutine subroutine umfpack_free_numeric ( Numeric , version ) type ( c_ptr ), optional :: Numeric character ( * ), optional :: version type ( c_ptr ) :: c_Numeric character ( 2 ) :: c_version if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_free_numeric ( c_Numeric ) case ( \"ci\" ) ; call umfpack_zi_free_numeric ( c_Numeric ) case default ; call umfpack_di_free_numeric ( c_Numeric ) end select end subroutine integer function umfpack_di_scale ( X , B , Numeric ) real ( r8 ), target :: X ( * ) real ( r8 ), target , intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_X , c_B , c_Numeric c_X = c_loc ( X ) c_B = c_loc ( B ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_di_scale = c_umfpack_di_scale ( c_X , c_B , c_Numeric ) end function subroutine s_umfpack_di_scale ( X , B , Numeric , status ) real ( r8 ), intent ( out ) :: X ( * ) real ( r8 ), intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_di_scale ( X , B , Numeric ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) real ( r8 ), target :: Xx ( * ), Xz ( * ) real ( r8 ), target , intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric c_Xx = c_loc ( Xx ) c_Xz = c_loc ( Xz ) c_Bx = c_loc ( Bx ) c_Bz = c_loc ( Bz ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_zi_scale = c_umfpack_zi_scale ( c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric ) end function subroutine s_umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric , status ) real ( r8 ), intent ( out ) :: Xx ( * ), Xz ( * ) real ( r8 ), intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_scale ( Xx , Bx , Numeric ) complex ( r8 ), target :: Xx ( * ) complex ( r8 ), target , intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric c_Xx = c_loc ( Xx ) c_Xz = c_null_ptr c_Bx = c_loc ( Bx ) c_Bz = c_null_ptr if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_ci_scale = c_umfpack_zi_scale ( c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric ) end function subroutine s_umfpack_ci_scale ( Xx , Bx , Numeric , status ) complex ( r8 ), intent ( out ) :: Xx ( * ) complex ( r8 ), intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_ci_scale ( Xx , Bx , Numeric ) if ( present ( status )) status = c_status end subroutine subroutine umfpack_di_defaults ( Control ) real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif call c_umfpack_di_defaults ( c_Control ) end subroutine subroutine umfpack_zi_defaults ( Control ) real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif call c_umfpack_zi_defaults ( c_Control ) end subroutine subroutine umfpack_defaults ( Control , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_defaults ( Control ) case ( \"ci\" ) ; call umfpack_zi_defaults ( Control ) case default ; call umfpack_di_defaults ( Control ) end select end subroutine subroutine umfpack_di_report_control ( Control ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_di_report_control ( c_Control ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_zi_report_control ( Control ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_zi_report_control ( c_Control ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_report_control ( Control , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_report_control ( Control ) case ( \"ci\" ) ; call umfpack_zi_report_control ( Control ) case default ; call umfpack_di_report_control ( Control ) end select end subroutine subroutine umfpack_di_report_info ( Control , Info ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ), target :: Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Control , c_Info logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif c_Info = c_loc ( Info ) inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_di_report_info ( c_Control , c_Info ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_zi_report_info ( Control , Info ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ), target :: Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Control , c_Info logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif c_Info = c_loc ( Info ) inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_zi_report_info ( c_Control , c_Info ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_report_info ( Control , Info , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ) :: Info ( 0 : UMFPACK_INFO - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_report_info ( Control , Info ) case ( \"ci\" ) ; call umfpack_zi_report_info ( Control , Info ) case default ; call umfpack_di_report_info ( Control , Info ) end select end subroutine integer function umfpack_di_save_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_di_save_numeric = c_umfpack_di_save_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_save_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_save_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_save_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_zi_save_numeric = c_umfpack_zi_save_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_save_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_save_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_save_numeric ( Numeric , filename , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_save_numeric = umfpack_zi_save_numeric ( Numeric , filename ) case ( \"ci\" ) ; umfpack_save_numeric = umfpack_zi_save_numeric ( Numeric , filename ) case default ; umfpack_save_numeric = umfpack_di_save_numeric ( Numeric , filename ) end select end function subroutine s_umfpack_save_numeric ( Numeric , filename , status , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_save_numeric ( Numeric , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_save_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_di_save_symbolic = c_umfpack_di_save_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_save_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_save_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_save_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_zi_save_symbolic = c_umfpack_zi_save_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_save_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_save_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_save_symbolic ( Symbolic , filename , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_save_symbolic = umfpack_zi_save_symbolic ( Symbolic , filename ) case ( \"ci\" ) ; umfpack_save_symbolic = umfpack_zi_save_symbolic ( Symbolic , filename ) case default ; umfpack_save_symbolic = umfpack_di_save_symbolic ( Symbolic , filename ) end select end function subroutine s_umfpack_save_symbolic ( Symbolic , filename , status , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_save_symbolic ( Symbolic , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_load_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_di_load_numeric = c_umfpack_di_load_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_load_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_load_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_load_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_zi_load_numeric = c_umfpack_zi_load_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_load_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_load_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_load_numeric ( Numeric , filename , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_load_numeric = umfpack_zi_load_numeric ( Numeric , filename ) case ( \"ci\" ) ; umfpack_load_numeric = umfpack_zi_load_numeric ( Numeric , filename ) case default ; umfpack_load_numeric = umfpack_di_load_numeric ( Numeric , filename ) end select end function subroutine s_umfpack_load_numeric ( Numeric , filename , status , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_load_numeric ( Numeric , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_load_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_di_load_symbolic = c_umfpack_di_load_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_load_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_load_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_load_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_zi_load_symbolic = c_umfpack_zi_load_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_load_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_load_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_load_symbolic ( Symbolic , filename , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_load_symbolic = umfpack_zi_load_symbolic ( Symbolic , filename ) case ( \"ci\" ) ; umfpack_load_symbolic = umfpack_zi_load_symbolic ( Symbolic , filename ) case default ; umfpack_load_symbolic = umfpack_di_load_symbolic ( Symbolic , filename ) end select end function subroutine s_umfpack_load_symbolic ( Symbolic , filename , status , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_load_symbolic ( Symbolic , filename , version ) if ( present ( status )) status = c_status end subroutine ! ====================================================================== ! Basic UMFPACK interface: Fortran wrappers ! ====================================================================== subroutine umf4def ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control ) end subroutine subroutine umf4zdef ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control , \"zi\" ) end subroutine subroutine umf4cdef ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control , \"zi\" ) end subroutine subroutine umf4pcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control ) end subroutine subroutine umf4zpcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control , \"zi\" ) end subroutine subroutine umf4cpcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control , \"zi\" ) end subroutine subroutine umf4sym ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) end subroutine subroutine umf4zsym ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) end subroutine subroutine umf4csym ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) end subroutine subroutine umf4sym_ip ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zsym_ip ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Az , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4csym_ip ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4num ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4znum ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4cnum ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4num_ip ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4znum_ip ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , Az , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4cnum_ip ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4solr ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) end subroutine subroutine umf4zsolr ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) end subroutine subroutine umf4csolr ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) end subroutine subroutine umf4solr_ip ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , c_Numeric , Control , Info ) end subroutine subroutine umf4zsolr_ip ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , c_Numeric , Control , Info ) end subroutine subroutine umf4csolr_ip ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , c_Numeric , Control , Info ) end subroutine subroutine umf4sol ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,Numeric,c_Control,Info) call s_umfpack_solve ( sys , x = x , b = b , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4zsol ( sys , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,xz,b,bz,Numeric,c_Control,Info) call s_umfpack_solve ( sys , xx = x , xz = xz , bx = b , bz = bz , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4csol ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,Numeric,c_Control,Info) call s_umfpack_solve ( sys , xx = x , bx = b , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4sol_ip ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,c_Numeric,c_Control,Info) call s_umfpack_solve ( sys , x = x , b = b , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4zsol_ip ( sys , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,xz,b,bz,c_Numeric,c_Control,Info) call s_umfpack_zi_solve ( sys , xx = x , xz = xz , bx = b , bz = bz , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4csol_ip ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,c_Numeric,c_Control,Info) call s_umfpack_ci_solve ( sys , xx = x , bx = b , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4scal ( x , b , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , b , Numeric ) end subroutine subroutine umf4zscal ( x , xz , b , bz , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , xz , b , bz , Numeric ) end subroutine subroutine umf4cscal ( x , b , Numeric , status ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , b , Numeric ) end subroutine subroutine umf4scal_ip ( x , b , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , b , c_Numeric ) end subroutine subroutine umf4zscal_ip ( x , xz , b , bz , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , xz , b , bz , c_Numeric ) end subroutine subroutine umf4cscal_ip ( x , b , Numeric , status ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , b , c_Numeric ) end subroutine subroutine umf4pinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info ) end subroutine subroutine umf4zpinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info , \"zi\" ) end subroutine subroutine umf4cpinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info , \"ci\" ) end subroutine subroutine umf4fnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric ) end subroutine subroutine umf4zfnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric , \"zi\" ) end subroutine subroutine umf4cfnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric , \"ci\" ) end subroutine subroutine umf4fnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4zfnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric , \"zi\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4cfnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric , \"ci\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4fsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic ) end subroutine subroutine umf4zfsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic , \"zi\" ) end subroutine subroutine umf4cfsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic , \"ci\" ) end subroutine subroutine umf4fsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zfsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic , \"zi\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4cfsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic , \"ci\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4snum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename ) end subroutine subroutine umf4zsnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename , \"zi\" ) end subroutine subroutine umf4csnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename , \"ci\" ) end subroutine subroutine umf4snum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename ) end subroutine subroutine umf4zsnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename , \"zi\" ) end subroutine subroutine umf4csnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename , \"ci\" ) end subroutine subroutine umf4ssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename ) end subroutine subroutine umf4zssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename , \"zi\" ) end subroutine subroutine umf4cssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename , \"ci\" ) end subroutine subroutine umf4ssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename ) end subroutine subroutine umf4zssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename , \"zi\" ) end subroutine subroutine umf4cssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename , \"ci\" ) end subroutine subroutine umf4lnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename ) end subroutine subroutine umf4zlnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename , \"zi\" ) end subroutine subroutine umf4clnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename , \"ci\" ) end subroutine subroutine umf4lnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4zlnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename , \"zi\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4clnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename , \"ci\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4lsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename ) end subroutine subroutine umf4zlsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename , \"zi\" ) end subroutine subroutine umf4clsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename , \"ci\" ) end subroutine subroutine umf4lsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zlsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename , \"zi\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4clsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename , \"ci\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine ! ====================================================================== ! Defined operator .umfpack.: associated procedures ! ====================================================================== function umfpack_di_operator_CSC ( A , B ) result ( X ) type ( tCSC_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B ( * ) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_CSC ( A , B ) result ( X ) type ( tCSC_zi ), intent ( in ) :: A type ( tVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_CSC ( A , B ) result ( X ) type ( tCSC_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_CSR ( A , B ) result ( X ) type ( tCSR_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B ( * ) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_CSR ( A , B ) result ( X ) type ( tCSR_zi ), intent ( in ) :: A type ( tVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_CSR ( A , B ) result ( X ) type ( tCSR_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_pCSC ( A , B ) result ( X ) type ( pCSC_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B (:) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_pCSC ( A , B ) result ( X ) type ( pCSC_zi ), intent ( in ) :: A type ( pVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_pCSC ( A , B ) result ( X ) type ( pCSC_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_pCSR ( A , B ) result ( X ) type ( pCSR_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B (:) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_pCSR ( A , B ) result ( X ) type ( pCSR_zi ), intent ( in ) :: A type ( pVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_pCSR ( A , B ) result ( X ) type ( pCSR_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function type ( pCSC_di ) function make_CSC_di ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSC_zi ) function make_CSC_zi ( Ap , Ai , Ax , Az ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:), Az (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax result % Az => Az end function type ( pCSC_ci ) function make_CSC_ci ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) complex ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSR_di ) function make_CSR_di ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSR_zi ) function make_CSR_zi ( Ap , Ai , Ax , Az ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:), Az (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax result % Az => Az end function type ( pCSR_ci ) function make_CSR_ci ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) complex ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pVec_zi ) function make_Vec_zi ( bx , bz ) result ( result ) real ( r8 ), target , intent ( in ) :: bx (:), bz (:) result % x => bx result % z => bz end function ! ====================================================================== endmodule mumfpack ! ======================================================================","tags":""},{"title":"mod_num_par.f90 – MSOLV-fortran","loc":"sourcefile/mod_num_par.f90.html","text":"This file depends on sourcefile~~mod_num_par.f90~~EfferentGraph sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_num_par.f90~~AfferentGraph sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_num_par.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_num_par.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules num_param Source Code mod_num_par.f90 Source Code !< author: Noël Brunetière<br/>&emsp;Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **MUSST general parameters** !  </span> !@note !        The type *NUM_PAR* is not used in **MSOLV**, it is a type related to the iterative process of **MUSST** !@endnote module num_param use iso_fortran_env , only : input_unit , output_unit use data_arch , only : I4 , R8 implicit none ! codes for message integer ( kind = I4 ), parameter :: NO_MESS = 0 !! *code for no message on screen during problem solving* integer ( kind = I4 ), parameter :: PRINT_MESS = 1 !! *code for printing message during problem solving* integer ( kind = I4 ) :: SOLV_MESS !! *Solver output detail control* integer ( kind = I4 ) :: OPU = output_unit !! *Output unit* integer ( kind = I4 ) :: IPU = input_unit !! *Input unit* integer ( kind = I4 ) :: VERBOSE !! *Output detail control* character ( len = 128 ) :: OUTPUT_FILE !! *When needed, output file* ! num_par definition type NUM_PAR real ( kind = R8 ) :: relax !! *relaxation parameter* real ( kind = R8 ) :: eps !! *error for convergence* integer ( kind = I4 ) :: it_max !! *maximal number of iterations* integer ( kind = I4 ) :: mess !! *message* integer ( kind = I4 ) :: free_threads !! *number of free threads in case of open_MP computation* endtype NUM_PAR endmodule num_param","tags":""},{"title":"mod_data_arch.f90 – MSOLV-fortran","loc":"sourcefile/mod_data_arch.f90.html","text":"Files dependent on this one sourcefile~~mod_data_arch.f90~~AfferentGraph sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_sort.f90 mod_sort.f90 sourcefile~mod_sort.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_num_par.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_data_arch.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 sourcefile~prg.f90->sourcefile~mod_num_par.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules data_arch Source Code mod_data_arch.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **General type definition** !  </span> module data_arch use , intrinsic :: iso_fortran_env , only : output_unit , input_unit , error_unit , & int32 , int64 , & real32 , real64 implicit none public ! don't keep global iso_fortran_env parameters integer ( kind = int32 ), parameter :: I4 = int32 integer ( kind = I4 ), parameter :: I8 = int64 integer ( kind = I4 ), parameter :: R4 = real32 integer ( kind = I4 ), parameter :: R8 = real64 integer ( kind = I4 ), parameter :: IN_U = input_unit integer ( kind = I4 ), parameter :: OUT_U = output_unit integer ( kind = I4 ), parameter :: ERR_U = error_unit integer ( kind = I4 ), parameter :: HIG_I4 = huge ( 1 ) real ( kind = R4 ), parameter :: PI_R4 = acos ( - 1._R4 ) real ( kind = R8 ), parameter :: PI_R8 = acos ( - 1._R8 ) real ( kind = R4 ), parameter :: EPS_R4 = tiny ( 1._R4 ) real ( kind = R8 ), parameter :: EPS_R8 = tiny ( 1._R8 ) real ( kind = R8 ), parameter :: HIG_R8 = huge ( 1._R8 ) real ( kind = R8 ), parameter :: HIG_E8 = log ( HIG_R8 ) real ( kind = R8 ), parameter :: EPS_E8 = log ( EPS_R8 ) integer ( kind = I4 ), parameter :: EXPO_MAX = exponent ( HIG_R8 ) integer ( kind = I4 ) :: NB_THREADS_MAX private :: output_unit , input_unit , error_unit , int32 , int64 , real32 , real64 contains !> @note from [John Burkardt website](https://people.sc.fsu.edu/~jburkardt/f_src) subroutine get_unit ( iunit ) implicit none integer ( kind = I4 ), intent ( out ) :: iunit integer ( kind = I4 ) :: i integer ( kind = I4 ) :: ios logical ( kind = I4 ) :: lopen iunit = 0 do i = 10 , 99 if ( i /= OUT_U . and . i /= IN_U . and . i /= ERR_U ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return endif endif endif enddo return endsubroutine get_unit endmodule data_arch","tags":""},{"title":"mod_sort.f90 – MSOLV-fortran","loc":"sourcefile/mod_sort.f90.html","text":"This file depends on sourcefile~~mod_sort.f90~~EfferentGraph sourcefile~mod_sort.f90 mod_sort.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_sort.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_sort.f90~~AfferentGraph sourcefile~mod_sort.f90 mod_sort.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sort_arrays Source Code mod_sort.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 23 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **Various routines to sort real/integer arrays** !  </span> module sort_arrays use data_arch , only : I4 , R8 implicit none private public :: sort_real_1real , sort_real_2real , sort_int_1real , sort_int_1int_1real contains !========================================================================================= !<@note !   Subroutine to sort a vector of reals, according a vector of reals ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_real_1real ( g , d , rtabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_1real ( g , j , rtabref , rtab1 ) if ( d > i ) call sort_real_1real ( i , d , rtabref , rtab1 ) return endsubroutine sort_real_1real !========================================================================================= !<@note !   Subroutine to sort 2 vectors of reals, according a vector of realq ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_real_2real ( g , d , rtabref , rtab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_2real ( g , j , rtabref , rtab1 , rtab2 ) if ( d > i ) call sort_real_2real ( i , d , rtabref , rtab1 , rtab2 ) return endsubroutine sort_real_2real !========================================================================================= !<@note !   Subroutine to sort a vector of reals and a vector of integers, according a vector of integers ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_int_1int_1real ( g , d , itabref , itab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref integer ( kind = I4 ), dimension (:), intent ( inout ) :: itab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 2 itmp = itab1 ( i ) itab1 ( i ) = itab1 ( j ) itab1 ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1int_1real ( g , j , itabref , itab1 , rtab2 ) if ( d > i ) call sort_int_1int_1real ( i , d , itabref , itab1 , rtab2 ) return endsubroutine sort_int_1int_1real !========================================================================================= !<@note !   Subroutine to sort a vector of reals, according a vector of integers ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_int_1real ( g , d , itabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1real ( g , j , itabref , rtab1 ) if ( d > i ) call sort_int_1real ( i , d , itabref , rtab1 ) return endsubroutine sort_int_1real endmodule sort_arrays","tags":""},{"title":"DMUMPS_STRUC – MSOLV-fortran ","loc":"type/dmumps_struc.html","text":"type, public :: DMUMPS_STRUC sequence Inherits type~~dmumps_struc~~InheritsGraph type~dmumps_struc DMUMPS_STRUC DMUMPS_ROOT_STRUC DMUMPS_ROOT_STRUC type~dmumps_struc->DMUMPS_ROOT_STRUC root Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables COMM SYM PAR JOB N NZ NNZ A IRN JCN COLSCA ROWSCA pad0 NZ_loc pad1 NNZ_loc IRN_loc JCN_loc A_loc pad2 NELT pad3 ELTPTR ELTVAR A_ELT pad4 PERM_IN RHS REDRHS RHS_SPARSE SOL_loc IRHS_SPARSE IRHS_PTR ISOL_loc LRHS NRHS NZ_RHS LSOL_loc LREDRHS pad5 ICNTL INFO INFOG COST_SUBTREES CNTL RINFO RINFOG SYM_PERM UNS_PERM NPROW NPCOL MBLOCK NBLOCK SCHUR_MLOC SCHUR_NLOC SCHUR_LLD SIZE_SCHUR SCHUR SCHUR_CINTERFACE LISTVAR_SCHUR MAPPING VERSION_NUMBER OOC_TMPDIR OOC_PREFIX WRITE_PROBLEM SAVE_DIR SAVE_PREFIX pad8 KEEP8 MAX_SURF_MASTER INST_Number COMM_NODES MYID_NODES COMM_LOAD MYID NPROCS NSLAVES ASS_IRECV LBUFR LBUFR_BYTES BUFR IS IS1 MAXIS1 Deficiency KEEP LNA NBSA STEP NE_STEPS ND_STEPS Step2node FRERE_STEPS DAD_STEPS FILS FRTPTR FRTELT PTRAR NA PROCNODE_STEPS PTLUST_S PTRFAC S PROCNODE INTARR DBLARR NELT_loc LELTVAR ELTPROC CANDIDATES ISTEP_TO_INIV2 FUTURE_NIV2 TAB_POS_IN_PERE I_AM_CAND MEM_DIST POSINRHSCOMP_ROW POSINRHSCOMP_COL_ALLOC pad11 POSINRHSCOMP_COL RHSCOMP MEM_SUBTREE COST_TRAV MY_ROOT_SBTR MY_FIRST_LEAF MY_NB_LEAF DEPTH_FIRST DEPTH_FIRST_SEQ SBTR_ID SCHED_DEP SCHED_GRP SCHED_SBTR CROIX_MANU WK_USER NBSA_LOCAL LWK_USER DKEEP CB_SON_SIZE INSTANCE_NUMBER OOC_MAX_NB_NODES_FOR_ZONE OOC_INODE_SEQUENCE OOC_SIZE_OF_BLOCK OOC_VADDR OOC_TOTAL_NB_NODES OOC_NB_FILES OOC_NB_FILE_TYPE pad12 OOC_FILE_NAME_LENGTH OOC_FILE_NAMES PIVNUL_LIST SUP_PROC pad14 IPTR_WORKING WORKING root LRGROUPS NBGRP pad13 FDM_F_ENCODING BLRARRAY_ENCODING LPOOL_AFTER_L0_OMP LPOOL_BEFORE_L0_OMP L_PHYS_L0_OMP L_VIRT_L0_OMP LL0_OMP_MAPPING pad15 THREAD_LA IPOOL_BEFORE_L0_OMP IPOOL_AFTER_L0_OMP PHYS_L0_OMP VIRT_L0_OMP PERM_L0_OMP PTR_LEAFS_L0_OMP L0_OMP_MAPPING SINGULAR_VALUES NB_SINGULAR_VALUES ASSOCIATED_OOC_FILES Source Code DMUMPS_STRUC Components Type Visibility Attributes Name Initial integer, public :: COMM integer, public :: SYM integer, public :: PAR integer, public :: JOB integer, public :: N integer, public :: NZ integer(kind=8), public :: NNZ double precision, public, DIMENSION(:), POINTER :: A integer, public, DIMENSION(:), POINTER :: IRN integer, public, DIMENSION(:), POINTER :: JCN double precision, public, DIMENSION(:), POINTER :: COLSCA double precision, public, DIMENSION(:), POINTER :: ROWSCA double precision, public, DIMENSION(:), POINTER :: pad0 integer, public :: NZ_loc integer, public :: pad1 integer(kind=8), public :: NNZ_loc integer, public, DIMENSION(:), POINTER :: IRN_loc integer, public, DIMENSION(:), POINTER :: JCN_loc double precision, public, DIMENSION(:), POINTER :: A_loc double precision, public, DIMENSION(:), POINTER :: pad2 integer, public :: NELT integer, public :: pad3 integer, public, DIMENSION(:), POINTER :: ELTPTR integer, public, DIMENSION(:), POINTER :: ELTVAR double precision, public, DIMENSION(:), POINTER :: A_ELT double precision, public, DIMENSION(:), POINTER :: pad4 integer, public, DIMENSION(:), POINTER :: PERM_IN double precision, public, DIMENSION(:), POINTER :: RHS double precision, public, DIMENSION(:), POINTER :: REDRHS double precision, public, DIMENSION(:), POINTER :: RHS_SPARSE double precision, public, DIMENSION(:), POINTER :: SOL_loc integer, public, DIMENSION(:), POINTER :: IRHS_SPARSE integer, public, DIMENSION(:), POINTER :: IRHS_PTR integer, public, DIMENSION(:), POINTER :: ISOL_loc integer, public :: LRHS integer, public :: NRHS integer, public :: NZ_RHS integer, public :: LSOL_loc integer, public :: LREDRHS integer, public :: pad5 integer, public :: ICNTL (40) integer, public :: INFO (40) integer, public :: INFOG (40) double precision, public :: COST_SUBTREES double precision, public :: CNTL (15) double precision, public :: RINFO (40) double precision, public :: RINFOG (40) integer, public, DIMENSION(:), POINTER :: SYM_PERM integer, public, DIMENSION(:), POINTER :: UNS_PERM integer, public :: NPROW integer, public :: NPCOL integer, public :: MBLOCK integer, public :: NBLOCK integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC integer, public :: SCHUR_LLD integer, public :: SIZE_SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR_CINTERFACE integer, public, DIMENSION(:), POINTER :: LISTVAR_SCHUR integer, public, DIMENSION(:), POINTER :: MAPPING character(len=30), public :: VERSION_NUMBER character(len=255), public :: OOC_TMPDIR character(len=63), public :: OOC_PREFIX character(len=255), public :: WRITE_PROBLEM character(len=255), public :: SAVE_DIR character(len=255), public :: SAVE_PREFIX character(len=7), public :: pad8 integer(kind=8), public :: KEEP8 (150) integer(kind=8), public :: MAX_SURF_MASTER integer, public :: INST_Number integer, public :: COMM_NODES integer, public :: MYID_NODES integer, public :: COMM_LOAD integer, public :: MYID integer, public :: NPROCS integer, public :: NSLAVES integer, public :: ASS_IRECV integer, public :: LBUFR integer, public :: LBUFR_BYTES integer, public, DIMENSION(:), POINTER :: BUFR integer, public, DIMENSION(:), POINTER :: IS integer, public, DIMENSION(:), POINTER :: IS1 integer, public :: MAXIS1 integer, public :: Deficiency integer, public :: KEEP (500) integer, public :: LNA integer, public :: NBSA integer, public, POINTER, DIMENSION(:) :: STEP integer, public, POINTER, DIMENSION(:) :: NE_STEPS integer, public, POINTER, DIMENSION(:) :: ND_STEPS integer, public, POINTER, DIMENSION(:) :: Step2node integer, public, POINTER, DIMENSION(:) :: FRERE_STEPS integer, public, POINTER, DIMENSION(:) :: DAD_STEPS integer, public, POINTER, DIMENSION(:) :: FILS integer, public, POINTER, DIMENSION(:) :: FRTPTR integer, public, POINTER, DIMENSION(:) :: FRTELT integer(kind=8), public, POINTER, DIMENSION(:) :: PTRAR integer, public, POINTER, DIMENSION(:) :: NA integer, public, POINTER, DIMENSION(:) :: PROCNODE_STEPS integer, public, DIMENSION(:), POINTER :: PTLUST_S integer(kind=8), public, DIMENSION(:), POINTER :: PTRFAC double precision, public, DIMENSION(:), POINTER :: S integer, public, DIMENSION(:), POINTER :: PROCNODE integer, public, DIMENSION(:), POINTER :: INTARR double precision, public, DIMENSION(:), POINTER :: DBLARR integer, public :: NELT_loc integer, public :: LELTVAR integer, public, DIMENSION(:), POINTER :: ELTPROC integer, public, DIMENSION(:,:), POINTER :: CANDIDATES integer, public, DIMENSION(:), POINTER :: ISTEP_TO_INIV2 integer, public, DIMENSION(:), POINTER :: FUTURE_NIV2 integer, public, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE logical, public, DIMENSION(:), POINTER :: I_AM_CAND integer, public, DIMENSION(:), POINTER :: MEM_DIST integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_ROW logical, public :: POSINRHSCOMP_COL_ALLOC logical, public :: pad11 integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_COL double precision, public, DIMENSION(:), POINTER :: RHSCOMP double precision, public, DIMENSION(:), POINTER :: MEM_SUBTREE double precision, public, DIMENSION(:), POINTER :: COST_TRAV integer, public, DIMENSION(:), POINTER :: MY_ROOT_SBTR integer, public, DIMENSION(:), POINTER :: MY_FIRST_LEAF integer, public, DIMENSION(:), POINTER :: MY_NB_LEAF integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST_SEQ integer, public, DIMENSION(:), POINTER :: SBTR_ID integer, public, DIMENSION(:), POINTER :: SCHED_DEP integer, public, DIMENSION(:), POINTER :: SCHED_GRP integer, public, DIMENSION(:), POINTER :: SCHED_SBTR integer, public, DIMENSION(:), POINTER :: CROIX_MANU double precision, public, DIMENSION(:), POINTER :: WK_USER integer, public :: NBSA_LOCAL integer, public :: LWK_USER double precision, public :: DKEEP (230) double precision, public, DIMENSION(:), POINTER :: CB_SON_SIZE integer, public :: INSTANCE_NUMBER integer, public :: OOC_MAX_NB_NODES_FOR_ZONE integer, public, DIMENSION(:,:), POINTER :: OOC_INODE_SEQUENCE integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_VADDR integer, public, DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES integer, public, DIMENSION(:), POINTER :: OOC_NB_FILES integer, public :: OOC_NB_FILE_TYPE integer, public :: pad12 integer, public, DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH character, public, DIMENSION(:,:), POINTER :: OOC_FILE_NAMES integer, public, DIMENSION(:), POINTER :: PIVNUL_LIST integer, public, DIMENSION(:,:), POINTER :: SUP_PROC integer, public, DIMENSION(:,:), POINTER :: pad14 integer, public, DIMENSION(:), POINTER :: IPTR_WORKING integer, public, DIMENSION(:), POINTER :: WORKING type(DMUMPS_ROOT_STRUC), public :: root integer, public, POINTER, DIMENSION(:) :: LRGROUPS integer, public :: NBGRP integer, public :: pad13 character(len=1), public, DIMENSION(:), POINTER :: FDM_F_ENCODING character(len=1), public, DIMENSION(:), POINTER :: BLRARRAY_ENCODING integer, public :: LPOOL_AFTER_L0_OMP integer, public :: LPOOL_BEFORE_L0_OMP integer, public :: L_PHYS_L0_OMP integer, public :: L_VIRT_L0_OMP integer, public :: LL0_OMP_MAPPING integer, public :: pad15 integer(kind=8), public :: THREAD_LA integer, public, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP integer, public, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP integer, public, DIMENSION(:), POINTER :: PHYS_L0_OMP integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: PERM_L0_OMP integer, public, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP integer, public, DIMENSION(:), POINTER :: L0_OMP_MAPPING double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES integer, public :: NB_SINGULAR_VALUES logical, public :: ASSOCIATED_OOC_FILES Source Code TYPE DMUMPS_STRUC SEQUENCE ! ! This structure contains all parameters ! for the interface to the user, plus internal ! information from the solver ! ! ***************** ! INPUT PARAMETERS ! ***************** !    ----------------- !    MPI Communicator !    ----------------- INTEGER :: COMM !    ------------------ !    Problem definition !    ------------------ !    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, !        SYM=2 general symmetric) !    Type of parallelism (PAR=1 host working, PAR=0 host not working) INTEGER :: SYM , PAR INTEGER :: JOB !    -------------------- !    Order of Input matrix !    -------------------- INTEGER :: N ! !    ---------------------------------------- !    Assembled input matrix : User interface !    ---------------------------------------- INTEGER :: NZ ! Standard integer input + bwd. compat. INTEGER ( 8 ) :: NNZ ! 64-bit integer input DOUBLE PRECISION , DIMENSION (:), POINTER :: A INTEGER , DIMENSION (:), POINTER :: IRN , JCN DOUBLE PRECISION , DIMENSION (:), POINTER :: COLSCA , ROWSCA , pad0 ! !       ------------------------------------ !       Case of distributed assembled matrix !       matrix on entry: !       ------------------------------------ INTEGER :: NZ_loc ! Standard integer input + bwd. compat. INTEGER :: pad1 INTEGER ( 8 ) :: NNZ_loc ! 64-bit integer input INTEGER , DIMENSION (:), POINTER :: IRN_loc , JCN_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: A_loc , pad2 ! !    ---------------------------------------- !    Unassembled input matrix: User interface !    ---------------------------------------- INTEGER :: NELT , pad3 INTEGER , DIMENSION (:), POINTER :: ELTPTR INTEGER , DIMENSION (:), POINTER :: ELTVAR DOUBLE PRECISION , DIMENSION (:), POINTER :: A_ELT , pad4 ! !    --------------------------------------------- !    Symmetric permutation : !               PERM_IN if given by user (optional) !    --------------------------------------------- INTEGER , DIMENSION (:), POINTER :: PERM_IN ! ! ! ****************** ! INPUT/OUTPUT data ! ****************** !    -------------------------------------------------------- !    RHS / SOL_loc !    ------------- !       right-hand side and solution !    ------------------------------------------------------- DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS , REDRHS DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_SPARSE DOUBLE PRECISION , DIMENSION (:), POINTER :: SOL_loc INTEGER , DIMENSION (:), POINTER :: IRHS_SPARSE INTEGER , DIMENSION (:), POINTER :: IRHS_PTR INTEGER , DIMENSION (:), POINTER :: ISOL_loc INTEGER :: LRHS , NRHS , NZ_RHS , LSOL_loc , LREDRHS INTEGER :: pad5 !    ---------------------------- !    Control parameters, !    statistics and output data !    --------------------------- INTEGER :: ICNTL ( 40 ) INTEGER :: INFO ( 40 ) INTEGER :: INFOG ( 40 ) DOUBLE PRECISION :: COST_SUBTREES DOUBLE PRECISION :: CNTL ( 15 ) DOUBLE PRECISION :: RINFO ( 40 ) DOUBLE PRECISION :: RINFOG ( 40 ) !    --------------------------------------------------------- !    Permutations computed during analysis: !       SYM_PERM: Symmetric permutation !       UNS_PERM: Column permutation (optional) !    --------------------------------------------------------- INTEGER , DIMENSION (:), POINTER :: SYM_PERM , UNS_PERM ! !    ----- !    Schur !    ----- INTEGER :: NPROW , NPCOL , MBLOCK , NBLOCK INTEGER :: SCHUR_MLOC , SCHUR_NLOC , SCHUR_LLD INTEGER :: SIZE_SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR_CINTERFACE INTEGER , DIMENSION (:), POINTER :: LISTVAR_SCHUR !    ------------------------------------- !    Case of distributed matrix on entry: !    DMUMPS potentially provides mapping !    ------------------------------------- INTEGER , DIMENSION (:), POINTER :: MAPPING !    -------------- !    Version number !    -------------- CHARACTER ( LEN = 30 ) :: VERSION_NUMBER !    ----------- !    Out-of-core !    ----------- CHARACTER ( LEN = 255 ) :: OOC_TMPDIR CHARACTER ( LEN = 63 ) :: OOC_PREFIX !    ------------------------------------------ !    To save the matrix in matrix market format !    ------------------------------------------ CHARACTER ( LEN = 255 ) :: WRITE_PROBLEM !    ----------- !    Save/Restore !    ----------- CHARACTER ( LEN = 255 ) :: SAVE_DIR CHARACTER ( LEN = 255 ) :: SAVE_PREFIX CHARACTER ( LEN = 7 ) :: pad8 ! ! ! ********************** ! INTERNAL Working data ! ********************* INTEGER ( 8 ) :: KEEP8 ( 150 ), MAX_SURF_MASTER INTEGER :: INST_Number !       For MPI INTEGER :: COMM_NODES , MYID_NODES , COMM_LOAD INTEGER :: MYID , NPROCS , NSLAVES INTEGER :: ASS_IRECV INTEGER :: LBUFR INTEGER :: LBUFR_BYTES INTEGER , DIMENSION (:), POINTER :: BUFR !       IS is used for the factors + workspace for contrib. blocks INTEGER , DIMENSION (:), POINTER :: IS !       IS1 (maxis1) contains working arrays computed !       and used only during analysis INTEGER , DIMENSION (:), POINTER :: IS1 !       For analysis/facto/solve phases INTEGER :: MAXIS1 , Deficiency INTEGER :: KEEP ( 500 ) !       The following data/arrays are computed during the analysis !       phase and used during the factorization and solve phases. INTEGER :: LNA INTEGER :: NBSA INTEGER , POINTER , DIMENSION (:) :: STEP , NE_STEPS , ND_STEPS !  Info for pruning tree INTEGER , POINTER , DIMENSION (:) :: Step2node !  --------------------- INTEGER , POINTER , DIMENSION (:) :: FRERE_STEPS , DAD_STEPS INTEGER , POINTER , DIMENSION (:) :: FILS , FRTPTR , FRTELT INTEGER ( 8 ), POINTER , DIMENSION (:) :: PTRAR INTEGER , POINTER , DIMENSION (:) :: NA , PROCNODE_STEPS !       The two pointer arrays computed in facto and used by the solve !          (except the factors) are PTLUST_S and PTRFAC. INTEGER , DIMENSION (:), POINTER :: PTLUST_S INTEGER ( 8 ), DIMENSION (:), POINTER :: PTRFAC !       main real working arrays for factorization/solve phases DOUBLE PRECISION , DIMENSION (:), POINTER :: S !       Information on mapping INTEGER , DIMENSION (:), POINTER :: PROCNODE !       Input matrix ready for numerical assembly !           -arrowhead format in case of assembled matrix !           -element format otherwise INTEGER , DIMENSION (:), POINTER :: INTARR DOUBLE PRECISION , DIMENSION (:), POINTER :: DBLARR !       Element entry: internal data INTEGER :: NELT_loc , LELTVAR INTEGER , DIMENSION (:), POINTER :: ELTPROC !       Candidates and node partitionning INTEGER , DIMENSION (:,:), POINTER :: CANDIDATES INTEGER , DIMENSION (:), POINTER :: ISTEP_TO_INIV2 INTEGER , DIMENSION (:), POINTER :: FUTURE_NIV2 INTEGER , DIMENSION (:,:), POINTER :: TAB_POS_IN_PERE LOGICAL , DIMENSION (:), POINTER :: I_AM_CAND !       For heterogeneous architecture INTEGER , DIMENSION (:), POINTER :: MEM_DIST !       Compressed RHS INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_ROW LOGICAL :: POSINRHSCOMP_COL_ALLOC , pad11 INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_COL DOUBLE PRECISION , DIMENSION (:), POINTER :: RHSCOMP !       Info on the subtrees to be used during factorization DOUBLE PRECISION , DIMENSION (:), POINTER :: MEM_SUBTREE DOUBLE PRECISION , DIMENSION (:), POINTER :: COST_TRAV INTEGER , DIMENSION (:), POINTER :: MY_ROOT_SBTR INTEGER , DIMENSION (:), POINTER :: MY_FIRST_LEAF INTEGER , DIMENSION (:), POINTER :: MY_NB_LEAF INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST_SEQ INTEGER , DIMENSION (:), POINTER :: SBTR_ID INTEGER , DIMENSION (:), POINTER :: SCHED_DEP INTEGER , DIMENSION (:), POINTER :: SCHED_GRP INTEGER , DIMENSION (:), POINTER :: SCHED_SBTR INTEGER , DIMENSION (:), POINTER :: CROIX_MANU DOUBLE PRECISION , DIMENSION (:), POINTER :: WK_USER INTEGER :: NBSA_LOCAL INTEGER :: LWK_USER !    Internal control array DOUBLE PRECISION :: DKEEP ( 230 ) !    For simulating parallel out-of-core stack. DOUBLE PRECISION , DIMENSION (:), POINTER :: CB_SON_SIZE !    Instance number used/managed by the C/F77 interface INTEGER :: INSTANCE_NUMBER !    OOC management data that must persist from factorization to solve. INTEGER :: OOC_MAX_NB_NODES_FOR_ZONE INTEGER , DIMENSION (:,:), POINTER :: OOC_INODE_SEQUENCE INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_SIZE_OF_BLOCK INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_VADDR INTEGER , DIMENSION (:), POINTER :: OOC_TOTAL_NB_NODES INTEGER , DIMENSION (:), POINTER :: OOC_NB_FILES INTEGER :: OOC_NB_FILE_TYPE , pad12 INTEGER , DIMENSION (:), POINTER :: OOC_FILE_NAME_LENGTH CHARACTER , DIMENSION (:,:), POINTER :: OOC_FILE_NAMES !    Indices of nul pivots INTEGER , DIMENSION (:), POINTER :: PIVNUL_LIST !    Array needed to manage additionnal candidate processor INTEGER , DIMENSION (:,:), POINTER :: SUP_PROC , pad14 !    Lists of nodes where processors work. Built/used in solve phase. INTEGER , DIMENSION (:), POINTER :: IPTR_WORKING , WORKING !    Root structure(internal) TYPE ( DMUMPS_ROOT_STRUC ) :: root !    Low-rank INTEGER , POINTER , DIMENSION (:) :: LRGROUPS INTEGER :: NBGRP , pad13 !    Pointer encoding for FDM_F data CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: FDM_F_ENCODING !    Pointer array encoding BLR factors pointers CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: BLRARRAY_ENCODING !    Multicore INTEGER :: LPOOL_AFTER_L0_OMP , LPOOL_BEFORE_L0_OMP INTEGER :: L_PHYS_L0_OMP INTEGER :: L_VIRT_L0_OMP INTEGER :: LL0_OMP_MAPPING , pad15 INTEGER ( 8 ) :: THREAD_LA ! Pool before L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_BEFORE_L0_OMP ! Pool after L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_AFTER_L0_OMP ! Subtrees INTEGER , DIMENSION (:), POINTER :: PHYS_L0_OMP ! Amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP ! From heaviest to lowest subtree INTEGER , DIMENSION (:), POINTER :: PERM_L0_OMP ! To get leafs in global pool INTEGER , DIMENSION (:), POINTER :: PTR_LEAFS_L0_OMP ! Mapping of the subtrees INTEGER , DIMENSION (:), POINTER :: L0_OMP_MAPPING ! for RR on root DOUBLE PRECISION , DIMENSION (:), POINTER :: SINGULAR_VALUES INTEGER :: NB_SINGULAR_VALUES ! To know if OOC files are associated to a saved and so if they should be removed. LOGICAL :: ASSOCIATED_OOC_FILES END TYPE DMUMPS_STRUC","tags":""},{"title":"MAT_MA48 – MSOLV-fortran ","loc":"type/mat_ma48.html","text":"type, public :: MAT_MA48 All the stuff needed by HSL_MA48 Inherits type~~mat_ma48~~InheritsGraph type~mat_ma48 MAT_MA48 MA48_AINFO MA48_AINFO type~mat_ma48->MA48_AINFO ainf MA48_CONTROL MA48_CONTROL type~mat_ma48->MA48_CONTROL ctrl MA48_SINFO MA48_SINFO type~mat_ma48->MA48_SINFO sinf ZD11_TYPE ZD11_TYPE type~mat_ma48->ZD11_TYPE zmat MA48_FINFO MA48_FINFO type~mat_ma48->MA48_FINFO finf MA48_FACTORS MA48_FACTORS type~mat_ma48->MA48_FACTORS fact Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~mat_ma48~~InheritedByGraph type~mat_ma48 MAT_MA48 type~mat_solv MAT_SOLV type~mat_solv->type~mat_ma48 matma48 type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables zmat ctrl ainf finf sinf fact fast resid Source Code MAT_MA48 Components Type Visibility Attributes Name Initial type(ZD11_TYPE), public :: zmat type(MA48_CONTROL), public :: ctrl type(MA48_AINFO), public :: ainf type(MA48_FINFO), public :: finf type(MA48_SINFO), public :: sinf type(MA48_FACTORS), public :: fact integer(kind=I4), public :: fast real(kind=R8), public, dimension(2) :: resid Source Code type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48","tags":""},{"title":"MAT_UMFP – MSOLV-fortran ","loc":"type/mat_umfp.html","text":"type, public :: MAT_UMFP All the stuff needed by UMFPACK Inherits type~~mat_umfp~~InheritsGraph type~mat_umfp MAT_UMFP c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~mat_umfp~~InheritedByGraph type~mat_umfp MAT_UMFP type~mat_solv MAT_SOLV type~mat_solv->type~mat_umfp matumfp type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables c_symbolic c_numeric c_control c_info Source Code MAT_UMFP Components Type Visibility Attributes Name Initial type(c_ptr), public :: c_symbolic type(c_ptr), public :: c_numeric real(kind=R8), public, dimension(0:UMFPACK_CONTROL-1) :: c_control real(kind=R8), public, dimension(0:UMFPACK_INFO   -1) :: c_info Source Code type MAT_UMFP !! <span style=\"color:green\">All the stuff needed by *UMFPACK*</span> type ( c_ptr ) :: c_symbolic type ( c_ptr ) :: c_numeric real ( kind = R8 ), dimension ( 0 : UMFPACK_CONTROL - 1 ) :: c_control real ( kind = R8 ), dimension ( 0 : UMFPACK_INFO - 1 ) :: c_info endtype MAT_UMFP","tags":""},{"title":"MAT_SOLV – MSOLV-fortran ","loc":"type/mat_solv.html","text":"type, public :: MAT_SOLV MUSST high level system type Inherits type~~mat_solv~~InheritsGraph type~mat_solv MAT_SOLV MAT_SULU MAT_SULU type~mat_solv->MAT_SULU matsulu MAT_MUMP MAT_MUMP type~mat_solv->MAT_MUMP matmump type~mat_umfp MAT_UMFP type~mat_solv->type~mat_umfp matumfp type~mat_ma48 MAT_MA48 type~mat_solv->type~mat_ma48 matma48 c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric MA48_AINFO MA48_AINFO type~mat_ma48->MA48_AINFO ainf MA48_CONTROL MA48_CONTROL type~mat_ma48->MA48_CONTROL ctrl MA48_SINFO MA48_SINFO type~mat_ma48->MA48_SINFO sinf ZD11_TYPE ZD11_TYPE type~mat_ma48->ZD11_TYPE zmat MA48_FINFO MA48_FINFO type~mat_ma48->MA48_FINFO finf MA48_FACTORS MA48_FACTORS type~mat_ma48->MA48_FACTORS fact Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~mat_solv~~InheritedByGraph type~mat_solv MAT_SOLV type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables slv_t first nn ne nt nz nvar code error mess matmump matma48 matsulu matumfp eltvar eltptr a_elt irow jcol jptr b x Source Code MAT_SOLV Components Type Visibility Attributes Name Initial integer(kind=I4), public :: slv_t solver type logical(kind=I4), public :: first = .true. analysis of the system to be done? integer(kind=I4), public :: nn number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: nt number of a priori non-zero terms in the matrix integer(kind=I4), public :: nz number of non-zero terms in the matrix integer(kind=I4), public :: nvar eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices) integer(kind=I4), public :: code error code [not used yet] real(kind=R8), public :: error error value [not used yet] character(len=1024), public :: mess message [not used yet] type(MAT_MUMP), public :: matmump matrices for mumps solver type( MAT_MA48 ), public :: matma48 matrices for ma48 solver type(MAT_SULU), public :: matsulu matrices for SuperLu solver type( MAT_UMFP ), public :: matumfp matrices for Umfpack solver integer(kind=I4), public, dimension(:), allocatable :: eltvar rows in assembled matrix integer(kind=I4), public, dimension(:), allocatable :: eltptr element rows pointer real(kind=R8), public, dimension(:), allocatable :: a_elt unassembled rigidity matrix integer(kind=I4), public, dimension(:), allocatable :: irow line number integer(kind=I4), public, dimension(:), allocatable :: jcol column number integer(kind=I4), public, dimension(:), allocatable :: jptr line pointer real(kind=R8), public, dimension(:), allocatable :: b right hand side vector real(kind=R8), public, dimension(:), allocatable :: x unknwon vector Source Code type MAT_SOLV !! <span style=\"color:green\">MUSST high level system type</span> integer ( kind = I4 ) :: slv_t !! *solver type* logical ( kind = I4 ) :: first = . true . !! *analysis of the system to be done?* integer ( kind = I4 ) :: nn !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: nt !! *number of **a priori** non-zero terms in the matrix* integer ( kind = I4 ) :: nz !! *number of non-zero terms in the matrix* integer ( kind = I4 ) :: nvar !! *eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices)* integer ( kind = I4 ) :: code !! *error code*   [not used yet] real ( kind = R8 ) :: error !! *error value*  [not used yet] character ( len = 1024 ) :: mess !! *message*      [not used yet] !..................................................... type ( MAT_MUMP ) :: matmump !! *matrices for mumps solver* type ( MAT_MA48 ) :: matma48 !! *matrices for ma48 solver* type ( MAT_SULU ) :: matsulu !! *matrices for SuperLu solver* type ( MAT_UMFP ) :: matumfp !! *matrices for Umfpack solver* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *rows in assembled matrix* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *element rows pointer* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *unassembled rigidity matrix* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: irow !! *line number* integer ( kind = I4 ), dimension (:), allocatable :: jcol !! *column number* integer ( kind = I4 ), dimension (:), allocatable :: jptr !! *line pointer* !..................................................... real ( kind = R8 ), dimension (:), allocatable :: b !! *right hand side vector* real ( kind = R8 ), dimension (:), allocatable :: x !! *unknwon vector* endtype MAT_SOLV","tags":""},{"title":"MS_MAT_SOLV – MSOLV-fortran ","loc":"type/ms_mat_solv.html","text":"type, public :: MS_MAT_SOLV MUSST multiscale high level solver type Note MS_MAT_SOLV is needed by MUSST, but it is useless for the present module Inherits type~~ms_mat_solv~~InheritsGraph type~ms_mat_solv MS_MAT_SOLV type~mat_solv MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat MAT_SULU MAT_SULU type~mat_solv->MAT_SULU matsulu MAT_MUMP MAT_MUMP type~mat_solv->MAT_MUMP matmump type~mat_umfp MAT_UMFP type~mat_solv->type~mat_umfp matumfp type~mat_ma48 MAT_MA48 type~mat_solv->type~mat_ma48 matma48 c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric MA48_AINFO MA48_AINFO type~mat_ma48->MA48_AINFO ainf MA48_CONTROL MA48_CONTROL type~mat_ma48->MA48_CONTROL ctrl MA48_SINFO MA48_SINFO type~mat_ma48->MA48_SINFO sinf ZD11_TYPE ZD11_TYPE type~mat_ma48->ZD11_TYPE zmat MA48_FINFO MA48_FINFO type~mat_ma48->MA48_FINFO finf MA48_FACTORS MA48_FACTORS type~mat_ma48->MA48_FACTORS fact var pantypems_mat_solvInheritsGraph = svgPanZoom('#typems_mat_solvInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ts_mat bs_mat ass_loc_in_mat Source Code MS_MAT_SOLV Components Type Visibility Attributes Name Initial type( MAT_SOLV ), public :: ts_mat top-scale solver type matrices type( MAT_SOLV ), public, dimension(:), allocatable :: bs_mat bottom-scale solver type matrices (table) integer(kind=I4), public, dimension(:), allocatable :: ass_loc_in_mat table for assembly location (for parallel computation) Source Code type MS_MAT_SOLV type ( MAT_SOLV ) :: ts_mat !! *top-scale solver type matrices* type ( MAT_SOLV ), dimension (:), allocatable :: bs_mat !! *bottom-scale solver type matrices (table)* integer ( kind = I4 ), dimension (:), allocatable :: ass_loc_in_mat !! *table for assembly location (for parallel computation)* endtype ms_mat_solv","tags":""},{"title":"LU_STACK_T – MSOLV-fortran ","loc":"type/lu_stack_t.html","text":"type, private, bind(c) :: LU_STACK_T Inherits type~~lu_stack_t~~InheritsGraph type~lu_stack_t LU_STACK_T C_PTR C_PTR type~lu_stack_t->C_PTR array Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~lu_stack_t~~InheritedByGraph type~lu_stack_t LU_STACK_T type~globallu_t GLOBALLU_T type~globallu_t->type~lu_stack_t stack type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables size used top1 top2 array Source Code LU_STACK_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size integer(kind=C_INT), public :: used integer(kind=C_INT), public :: top1 integer(kind=C_INT), public :: top2 type(C_PTR), public :: array Source Code type , bind ( c ) :: LU_STACK_T integer ( kind = C_INT ) :: size integer ( kind = C_INT ) :: used integer ( kind = C_INT ) :: top1 integer ( kind = C_INT ) :: top2 type ( C_PTR ) :: array endtype LU_STACK_T","tags":""},{"title":"EXPHEADER – MSOLV-fortran ","loc":"type/expheader.html","text":"type, private, bind(c) :: EXPHEADER Inherits type~~expheader~~InheritsGraph type~expheader EXPHEADER C_PTR C_PTR type~expheader->C_PTR mem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~expheader~~InheritedByGraph type~expheader EXPHEADER type~globallu_t GLOBALLU_T type~globallu_t->type~expheader expanders type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables size mem Source Code EXPHEADER Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size type(C_PTR), public :: mem Source Code type , bind ( c ) :: EXPHEADER integer ( kind = C_INT ) :: size type ( C_PTR ) :: mem endtype EXPHEADER","tags":""},{"title":"GLOBALLU_T – MSOLV-fortran ","loc":"type/globallu_t.html","text":"type, private, bind(c) :: GLOBALLU_T Inherits type~~globallu_t~~InheritsGraph type~globallu_t GLOBALLU_T type~expheader EXPHEADER type~globallu_t->type~expheader expanders C_PTR C_PTR type~globallu_t->C_PTR lusup, ucol type~lu_stack_t LU_STACK_T type~globallu_t->type~lu_stack_t stack type~expheader->C_PTR mem type~lu_stack_t->C_PTR array Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~globallu_t~~InheritedByGraph type~globallu_t GLOBALLU_T type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables xsup supno lsub xlsub lusup xlusup ucol usub xusub nzlmax nzumax nzlumax MemModel num_expansions expanders stack Source Code GLOBALLU_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: xsup integer(kind=C_INT), public :: supno integer(kind=C_INT), public :: lsub integer(kind=C_INT), public :: xlsub type(C_PTR), public :: lusup integer(kind=C_INT), public :: xlusup type(C_PTR), public :: ucol integer(kind=C_INT), public :: usub integer(kind=C_INT), public :: xusub integer(kind=C_INT), public :: nzlmax integer(kind=C_INT), public :: nzumax integer(kind=C_INT), public :: nzlumax integer(kind=C_INT), public :: MemModel = 0 integer(kind=C_INT), public :: num_expansions type( EXPHEADER ), public :: expanders type( LU_STACK_T ), public :: stack Source Code type , bind ( c ) :: GLOBALLU_T integer ( kind = C_INT ) :: xsup integer ( kind = C_INT ) :: supno integer ( kind = C_INT ) :: lsub integer ( kind = C_INT ) :: xlsub type ( C_PTR ) :: lusup integer ( kind = C_INT ) :: xlusup type ( C_PTR ) :: ucol integer ( kind = C_INT ) :: usub integer ( kind = C_INT ) :: xusub integer ( kind = C_INT ) :: nzlmax integer ( kind = C_INT ) :: nzumax integer ( kind = C_INT ) :: nzlumax integer ( kind = C_INT ) :: MemModel = 0 integer ( kind = C_INT ) :: num_expansions type ( EXPHEADER ) :: expanders type ( LU_STACK_T ) :: stack endtype GLOBALLU_T","tags":""},{"title":"SUPERLUSTAT_T – MSOLV-fortran ","loc":"type/superlustat_t.html","text":"type, private, bind(c) :: SUPERLUSTAT_T Inherits type~~superlustat_t~~InheritsGraph type~superlustat_t SUPERLUSTAT_T C_PTR C_PTR type~superlustat_t->C_PTR panel_histo, utime, ops Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~superlustat_t~~InheritedByGraph type~superlustat_t SUPERLUSTAT_T type~sulu_env SULU_ENV type~sulu_env->type~superlustat_t stat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables panel_histo utime ops TinyPivots RefineSteps expansions Source Code SUPERLUSTAT_T Components Type Visibility Attributes Name Initial type(C_PTR), public :: panel_histo histogram of panel size distribution type(C_PTR), public :: utime running time at various phases type(C_PTR), public :: ops operation count at various phases integer(kind=C_INT), public :: TinyPivots number of tiny pivots integer(kind=C_INT), public :: RefineSteps number of iterative refinement steps integer(kind=C_INT), public :: expansions number of memory expansions Source Code type , bind ( c ) :: SUPERLUSTAT_T type ( C_PTR ) :: panel_histo !! *histogram of panel size distribution* type ( C_PTR ) :: utime !! *running time at various phases* type ( C_PTR ) :: ops !! *operation count at various phases* integer ( kind = C_INT ) :: TinyPivots !! *number of tiny pivots* integer ( kind = C_INT ) :: RefineSteps !! *number of iterative refinement steps* integer ( kind = C_INT ) :: expansions !! *number of memory expansions* endtype SUPERLUSTAT_T","tags":""},{"title":"MEM_USAGE_T – MSOLV-fortran ","loc":"type/mem_usage_t.html","text":"type, private, bind(c) :: MEM_USAGE_T Inherited by type~~mem_usage_t~~InheritedByGraph type~mem_usage_t MEM_USAGE_T type~sulu_env SULU_ENV type~sulu_env->type~mem_usage_t mem_usage Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables for_lu total_needed Source Code MEM_USAGE_T Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: for_lu real(kind=C_FLOAT), public :: total_needed Source Code type , bind ( c ) :: MEM_USAGE_T real ( kind = C_FLOAT ) :: for_lu real ( kind = C_FLOAT ) :: total_needed endtype MEM_USAGE_T","tags":""},{"title":"NCFORMAT – MSOLV-fortran ","loc":"type/ncformat.html","text":"type, private, bind(c) :: NCFORMAT Note Stype == SLU_NC (Also known as Harwell-Boeing sparse matrix format) Zero-based indexing is used; colptr[] has ncol+1 entries, the last one pointing beyond the last column,\n so that colptr[ncol] = nnz. Inherits type~~ncformat~~InheritsGraph type~ncformat NCFORMAT C_PTR C_PTR type~ncformat->C_PTR nzval, rowind, colptr Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nnz nzval rowind colptr Source Code NCFORMAT Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: nnz number of nonzeros in the matrix type(C_PTR), public :: nzval pointer to array of nonzero values, packed by column type(C_PTR), public :: rowind pointer to array of row indices of the nonzeros type(C_PTR), public :: colptr pointer to array of beginning of columns in nzval[] and rowind[] Source Code type , bind ( c ) :: NCFORMAT integer ( kind = C_INT ) :: nnz !! *number of nonzeros in the matrix* type ( C_PTR ) :: nzval !! *pointer to array of nonzero values, packed by column* type ( C_PTR ) :: rowind !! *pointer to array of row indices of the nonzeros* type ( C_PTR ) :: colptr !! *pointer to array of beginning of columns in nzval[] and rowind[]* endtype NCFORMAT","tags":""},{"title":"SUPERMATRIX – MSOLV-fortran ","loc":"type/supermatrix.html","text":"type, private, bind(c) :: SUPERMATRIX Inherits type~~supermatrix~~InheritsGraph type~supermatrix SUPERMATRIX C_PTR C_PTR type~supermatrix->C_PTR Store Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~supermatrix~~InheritedByGraph type~supermatrix SUPERMATRIX type~sulu_env SULU_ENV type~sulu_env->type~supermatrix sma, smb, smx, sml, smu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Stype Dtype Mtype nrow ncol Store Source Code SUPERMATRIX Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Stype Storage type: interprets the storage structure pointed to by Store integer(kind=C_INT), public :: Dtype Data type integer(kind=C_INT), public :: Mtype Matrix type: describes the mathematical property of the matrix integer(kind=C_INT), public :: nrow number of rows integer(kind=C_INT), public :: ncol number of columns type(C_PTR), public :: Store pointer to the actual storage of the matrix, here, pointer to NCFORMAT Source Code type , bind ( c ) :: SUPERMATRIX integer ( kind = C_INT ) :: Stype !! *Storage type: interprets the storage structure pointed to by Store* integer ( kind = C_INT ) :: Dtype !! *Data type* integer ( kind = C_INT ) :: Mtype !! *Matrix type: describes the mathematical property of the matrix* integer ( kind = C_INT ) :: nrow !! *number of rows* integer ( kind = C_INT ) :: ncol !! *number of columns* type ( C_PTR ) :: Store !! *pointer to the actual storage of the matrix, here, pointer to [[NCformat]]* endtype SUPERMATRIX","tags":""},{"title":"SUPERLU_OPTIONS_T – MSOLV-fortran ","loc":"type/superlu_options_t.html","text":"type, private, bind(c) :: SUPERLU_OPTIONS_T = FACTORED: On entry, L, U, perm_r and perm_c contain the Inherited by type~~superlu_options_t~~InheritedByGraph type~superlu_options_t SUPERLU_OPTIONS_T type~sulu_env SULU_ENV type~sulu_env->type~superlu_options_t options Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Fact Equil ColPerm Trans IterRefine DiagPivotThresh SymmetricMode PivotGrowth ConditionNumber RowPerm ILU_DropRule ILU_DropTol ILU_FillFactor ILU_Norm ILU_FillTol ILU_MILU ILU_MILU_Dim ParSymbFact ReplaceTinyPivot SolveInitialized RefineInitialized PrintStat nnzL nnzU num_lookaheads lookahead_etree SymPattern Source Code SUPERLU_OPTIONS_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Fact integer(kind=C_INT), public :: Equil integer(kind=C_INT), public :: ColPerm integer(kind=C_INT), public :: Trans integer(kind=C_INT), public :: IterRefine real(kind=C_DOUBLE), public :: DiagPivotThresh integer(kind=C_INT), public :: SymmetricMode integer(kind=C_INT), public :: PivotGrowth integer(kind=C_INT), public :: ConditionNumber integer(kind=C_INT), public :: RowPerm integer(kind=C_INT), public :: ILU_DropRule real(kind=C_DOUBLE), public :: ILU_DropTol real(kind=C_DOUBLE), public :: ILU_FillFactor integer(kind=C_INT), public :: ILU_Norm real(kind=C_DOUBLE), public :: ILU_FillTol integer(kind=C_INT), public :: ILU_MILU real(kind=C_DOUBLE), public :: ILU_MILU_Dim integer(kind=C_INT), public :: ParSymbFact integer(kind=C_INT), public :: ReplaceTinyPivot integer(kind=C_INT), public :: SolveInitialized integer(kind=C_INT), public :: RefineInitialized integer(kind=C_INT), public :: PrintStat integer(kind=C_INT), public :: nnzL used to store nnzs for now integer(kind=C_INT), public :: nnzU used to store nnzs for now integer(kind=C_INT), public :: num_lookaheads num of levels in look-ahead integer(kind=C_INT), public :: lookahead_etree use etree computed from the serial symbolic factorization integer(kind=C_INT), public :: SymPattern symmetric factorization Source Code type , bind ( c ) :: SUPERLU_OPTIONS_T !/* ! *-- This contains the options used to control the solution process. ! * ! * Fact   (fact_t) ! *        Specifies whether or not the factored form of the matrix ! *        A is supplied on entry, and if not, how the matrix A should ! *        be factorizaed. ! *        = DOFACT: The matrix A will be factorized from scratch, and the ! *             factors will be stored in L and U. ! *        = SamePattern: The matrix A will be factorized assuming ! *             that a factorization of a matrix with the same sparsity ! *             pattern was performed prior to this one. Therefore, this ! *             factorization will reuse column permutation vector ! *             ScalePermstruct->perm_c and the column elimination tree ! *             LUstruct->etree. ! *        = SamePattern_SameRowPerm: The matrix A will be factorized ! *             assuming that a factorization of a matrix with the same ! *             sparsity   pattern and similar numerical values was performed ! *             prior to this one. Therefore, this factorization will reuse ! *             both row and column scaling factors R and C, both row and ! *             column permutation vectors perm_r and perm_c, and the ! *             L & U data structures set up from the previous factorization. !! *        = FACTORED: On entry, L, U, perm_r and perm_c contain the ! *              factored form of A. If DiagScale is not NOEQUIL, the matrix ! *              A has been equilibrated with scaling factors R and C. ! * ! * Equil  (yes_no_t) ! *        Specifies whether to equilibrate the system (scale A's row and ! *        columns to have unit norm). ! * ! * ColPerm (colperm_t) ! *        Specifies what type of column permutation to use to reduce fill. ! *        = NATURAL: use the natural ordering ! *        = MMD_ATA: use minimum degree ordering on structure of A'*A ! *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A ! *        = COLAMD: use approximate minimum degree column ordering ! *        = MY_PERMC: use the ordering specified by the user ! * ! * Trans  (trans_t) ! *        Specifies the form of the system of equations: ! *        = NOTRANS: A * X = B        (No transpose) ! *        = TRANS:   A**T * X = B     (Transpose) ! *        = CONJ:    A**H * X = B     (Transpose) ! * ! * IterRefine (IterRefine_t) ! *        Specifies whether to perform iterative refinement. ! *        = NO: no iterative refinement ! *        = SLU_SINGLE: perform iterative refinement in single precision ! *        = SLU_DOUBLE: perform iterative refinement in double precision ! *        = SLU_EXTRA: perform iterative refinement in extra precision ! * ! * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU) ! *        Specifies the threshold used for a diagonal entry to be an ! *        acceptable pivot. ! * ! * SymmetricMode (yest_no_t) ! *        Specifies whether to use symmetric mode. Symmetric mode gives ! *        preference to diagonal pivots, and uses an (A'+A)-based column ! *        permutation algorithm. ! * ! * PivotGrowth (yes_no_t) ! *        Specifies whether to compute the reciprocal pivot growth. ! * ! * ConditionNumber (ues_no_t) ! *        Specifies whether to compute the reciprocal condition number. ! * ! * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU) ! *        Specifies whether to permute rows of the original matrix. ! *        = NO: not to permute the rows ! *        = LargeDiag: make the diagonal large relative to the off-diagonal ! *        = MY_PERMR: use the permutation given by the user ! * ! * ILU_DropRule (int) ! *        Specifies the dropping rule: ! *     = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau). ! *     = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n. ! *     = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column, ! *                     p = gamma * nnz(A(:,j)). ! *     = DROP_AREA:    Variation of ILUTP, for j-th column, use ! *                     nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory. ! *     = DROP_DYNAMIC: Modify the threshold tau during factorizaion: ! *                     If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma ! *                         tau_L(j) := MIN(tau_0, tau_L(j-1) * 2); ! *                     Otherwise ! *                         tau_L(j) := MAX(tau_0, tau_L(j-1) / 2); ! *                     tau_U(j) uses the similar rule. ! *                     NOTE: the thresholds used by L and U are separate. ! *     = DROP_INTERP:  Compute the second dropping threshold by ! *                     interpolation instead of sorting (default). ! *                     In this case, the actual fill ratio is not ! *                     guaranteed to be smaller than gamma. ! *                     Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive. ! *    ( Default: DROP_BASIC | DROP_AREA ) ! * ! * ILU_DropTol (double) ! *        numerical threshold for dropping. ! * ! * ILU_FillFactor (double) ! *        Gamma in the secondary dropping. ! * ! * ILU_Norm (norm_t) ! *        Specify which norm to use to measure the row size in a ! *        supernode: infinity-norm, 1-norm, or 2-norm. ! * ! * ILU_FillTol (double) ! *        numerical threshold for zero pivot perturbation. ! * ! * ILU_MILU (milu_t) ! *        Specifies which version of MILU to use. ! * ! * ILU_MILU_Dim (double) ! *        Dimension of the PDE if available. ! * ! * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether to replace the tiny diagonals by ! *        sqrt(epsilon)*||A|| during LU factorization. ! * ! * SolveInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        triangular solve. ! * ! * RefineInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        sparse matrix-vector multiplication routine needed in iterative ! *        refinement. ! * ! * PrintStat (yes_no_t) ! *        Specifies whether to print the solver's statistics. ! */ integer ( kind = C_INT ) :: Fact integer ( kind = C_INT ) :: Equil integer ( kind = C_INT ) :: ColPerm integer ( kind = C_INT ) :: Trans integer ( kind = C_INT ) :: IterRefine real ( kind = C_DOUBLE ) :: DiagPivotThresh integer ( kind = C_INT ) :: SymmetricMode integer ( kind = C_INT ) :: PivotGrowth integer ( kind = C_INT ) :: ConditionNumber integer ( kind = C_INT ) :: RowPerm integer ( kind = C_INT ) :: ILU_DropRule real ( kind = C_DOUBLE ) :: ILU_DropTol real ( kind = C_DOUBLE ) :: ILU_FillFactor integer ( kind = C_INT ) :: ILU_Norm real ( kind = C_DOUBLE ) :: ILU_FillTol integer ( kind = C_INT ) :: ILU_MILU real ( kind = C_DOUBLE ) :: ILU_MILU_Dim integer ( kind = C_INT ) :: ParSymbFact integer ( kind = C_INT ) :: ReplaceTinyPivot integer ( kind = C_INT ) :: SolveInitialized integer ( kind = C_INT ) :: RefineInitialized integer ( kind = C_INT ) :: PrintStat integer ( kind = C_INT ) :: nnzL , nnzU !! *used to store nnzs for now* integer ( kind = C_INT ) :: num_lookaheads !! *num of levels in look-ahead* integer ( kind = C_INT ) :: lookahead_etree !! *use etree computed from the serial symbolic factorization* integer ( kind = C_INT ) :: SymPattern !! *symmetric factorization* endtype SUPERLU_OPTIONS_T","tags":""},{"title":"SULU_ENV – MSOLV-fortran ","loc":"type/sulu_env.html","text":"type, public :: SULU_ENV Global type for SuperLU which covers all the stuff needed Inherits type~~sulu_env~~InheritsGraph type~sulu_env SULU_ENV C_PTR C_PTR type~sulu_env->C_PTR work type~mem_usage_t MEM_USAGE_T type~sulu_env->type~mem_usage_t mem_usage type~globallu_t GLOBALLU_T type~sulu_env->type~globallu_t Glu type~superlustat_t SUPERLUSTAT_T type~sulu_env->type~superlustat_t stat type~supermatrix SUPERMATRIX type~sulu_env->type~supermatrix sma, smb, smx, sml, smu type~superlu_options_t SUPERLU_OPTIONS_T type~sulu_env->type~superlu_options_t options type~globallu_t->C_PTR lusup, ucol type~expheader EXPHEADER type~globallu_t->type~expheader expanders type~lu_stack_t LU_STACK_T type~globallu_t->type~lu_stack_t stack type~superlustat_t->C_PTR panel_histo, utime, ops type~supermatrix->C_PTR Store type~expheader->C_PTR mem type~lu_stack_t->C_PTR array var pantypesulu_envInheritsGraph = svgPanZoom('#typesulu_envInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n nrhs nz info lwork first b x a_elt irow jptr ferr berr RR CC rpg rcond perm_c perm_r etree equed work options sma smb smx sml smu stat Glu mem_usage Source Code SULU_ENV Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n system size integer(kind=C_INT), public :: nrhs number of right hand sides integer(kind=C_INT), public :: nz number on non-zero entries integer(kind=C_INT), public :: info info returned by dgssvx integer(kind=C_INT), public :: lwork size of workspace, not used here logical(kind=I4), public :: first if false the system has been factorized at least once real(kind=R8), public, dimension(:), pointer :: b right hand side: points to b real(kind=R8), public, allocatable, dimension(:) :: x solution real(kind=R8), public, dimension(:), pointer :: a_elt CC system matrix: points to a_elt integer(kind=I4), public, dimension(:), pointer :: irow matrix line of an a_elt element: points to irow integer(kind=I4), public, dimension(:), pointer :: jptr matrix column pointers: points to jptr real(kind=C_DOUBLE), public, allocatable, dimension(:) :: ferr estimated forward error bound for each solution vector real(kind=C_DOUBLE), public, allocatable, dimension(:) :: berr componentwise relative backward error of each solution real(kind=C_DOUBLE), public, allocatable, dimension(:) :: RR *row scale factors for A * real(kind=C_DOUBLE), public, allocatable, dimension(:) :: CC column scale factors for A real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rpg reciprocal pivot growth factor real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rcond estimate of the reciprocal condition number of the matrix A integer(kind=C_INT), public, allocatable, dimension(:) :: perm_c If A->Stype = SLU_NC , Column permutation vector of size A->ncol integer(kind=C_INT), public, allocatable, dimension(:) :: perm_r If A->Stype = SLU_NC , row permutation vector of size A->nrow integer(kind=C_INT), public, allocatable, dimension(:) :: etree Elimination tree character(kind=len=1,C_CHAR), public :: equed form of equilibration type(C_PTR), public :: work User supplied workspace type( SUPERLU_OPTIONS_T ), public :: options LU controls type( SUPERMATRIX ), public :: sma Matrix A in A X=B* type( SUPERMATRIX ), public :: smb On entry, the right hand side matrix type( SUPERMATRIX ), public :: smx olution matrix to the original system type( SUPERMATRIX ), public :: sml factor L from the factorization type( SUPERMATRIX ), public :: smu factor U from the factorization type( SUPERLUSTAT_T ), public :: stat statistics on runtime and floating-point operation count type( GLOBALLU_T ), public :: Glu first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity type( MEM_USAGE_T ), public :: mem_usage memory usage statistics Source Code type SULU_ENV !! <span style=\"color:green\">Global type for *SuperLU* which covers all the stuff needed</span> integer ( kind = C_INT ) :: n !! *system size* integer ( kind = C_INT ) :: nrhs !! *number of right hand sides* integer ( kind = C_INT ) :: nz !! *number on non-zero entries* integer ( kind = C_INT ) :: info !! *info returned by [[dgssvx]]* integer ( kind = C_INT ) :: lwork !! *size of workspace, not used here* logical ( kind = I4 ) :: first !! *if ```false``` the system has been factorized at least once* real ( kind = R8 ), dimension (:), pointer :: b !! *right hand side: points to [[MAT_SOLV:b]]* real ( kind = R8 ), allocatable , dimension (:) :: x !! *solution* real ( kind = R8 ), dimension (:), pointer :: a_elt !! *CC system matrix: points to [[MAT_SOLV:a_elt]]* integer ( kind = I4 ), dimension (:), pointer :: irow !! *matrix line of an a_elt element: points to [[MAT_SOLV:irow]]* integer ( kind = I4 ), dimension (:), pointer :: jptr !! *matrix column pointers: points to [[MAT_SOLV:jptr]]* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: ferr !! *estimated forward error bound for each solution vector* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: berr !! *componentwise relative backward error of each solution* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: RR !! *row scale factors for A * real ( kind = C_DOUBLE ), allocatable , dimension (:) :: CC !!*column scale factors for A* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rpg !! *reciprocal pivot growth factor* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rcond !!*estimate of the reciprocal condition number of the matrix A* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_c !!*If A->Stype = ```SLU_NC```, Column permutation vector of size A->ncol* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_r !!*If A->Stype = ```SLU_NC```, row permutation vector of size A->nrow* integer ( kind = C_INT ), allocatable , dimension (:) :: etree !! *Elimination tree* character ( len = 1 , kind = C_CHAR ) :: equed !! *form of equilibration* type ( C_PTR ) :: work !! *User supplied workspace* type ( SUPERLU_OPTIONS_T ) :: options !! *LU controls* type ( SUPERMATRIX ) :: sma !! *Matrix A in A*X=B* type ( SUPERMATRIX ) :: smb !! *On entry, the right hand side matrix* type ( SUPERMATRIX ) :: smx !! *olution matrix to the original system* type ( SUPERMATRIX ) :: sml !! *factor L from the factorization* type ( SUPERMATRIX ) :: smu !! *factor U from the factorization* type ( SUPERLUSTAT_T ) :: stat !! *statistics on runtime and floating-point operation count* type ( GLOBALLU_T ) :: Glu !! *first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity* type ( MEM_USAGE_T ) :: mem_usage !! *memory usage statistics* endtype SULU_ENV","tags":""},{"title":"tCSC_di – MSOLV-fortran ","loc":"type/tcsc_di.html","text":"type, public :: tCSC_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:)","tags":""},{"title":"tCSC_zi – MSOLV-fortran ","loc":"type/tcsc_zi.html","text":"type, public :: tCSC_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:)","tags":""},{"title":"tCSC_ci – MSOLV-fortran ","loc":"type/tcsc_ci.html","text":"type, public :: tCSC_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:)","tags":""},{"title":"tCSR_di – MSOLV-fortran ","loc":"type/tcsr_di.html","text":"type, public :: tCSR_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:)","tags":""},{"title":"tCSR_zi – MSOLV-fortran ","loc":"type/tcsr_zi.html","text":"type, public :: tCSR_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:)","tags":""},{"title":"tCSR_ci – MSOLV-fortran ","loc":"type/tcsr_ci.html","text":"type, public :: tCSR_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:)","tags":""},{"title":"tVec_zi – MSOLV-fortran ","loc":"type/tvec_zi.html","text":"type, public :: tVec_zi Contents Variables x z Components Type Visibility Attributes Name Initial real(kind=r8), public, allocatable :: x (:) real(kind=r8), public, allocatable :: z (:)","tags":""},{"title":"pCSC_di – MSOLV-fortran ","loc":"type/pcsc_di.html","text":"type, public :: pCSC_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:)","tags":""},{"title":"pCSC_zi – MSOLV-fortran ","loc":"type/pcsc_zi.html","text":"type, public :: pCSC_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:)","tags":""},{"title":"pCSC_ci – MSOLV-fortran ","loc":"type/pcsc_ci.html","text":"type, public :: pCSC_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:)","tags":""},{"title":"pCSR_di – MSOLV-fortran ","loc":"type/pcsr_di.html","text":"type, public :: pCSR_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:)","tags":""},{"title":"pCSR_zi – MSOLV-fortran ","loc":"type/pcsr_zi.html","text":"type, public :: pCSR_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:)","tags":""},{"title":"pCSR_ci – MSOLV-fortran ","loc":"type/pcsr_ci.html","text":"type, public :: pCSR_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:)","tags":""},{"title":"pVec_zi – MSOLV-fortran ","loc":"type/pvec_zi.html","text":"type, public :: pVec_zi Contents Variables x z Components Type Visibility Attributes Name Initial real(kind=r8), public, pointer :: x (:) real(kind=r8), public, pointer :: z (:)","tags":""},{"title":"NUM_PAR – MSOLV-fortran ","loc":"type/num_par.html","text":"type, public :: NUM_PAR Contents Variables relax eps it_max mess free_threads Source Code NUM_PAR Components Type Visibility Attributes Name Initial real(kind=R8), public :: relax relaxation parameter real(kind=R8), public :: eps error for convergence integer(kind=I4), public :: it_max maximal number of iterations integer(kind=I4), public :: mess message integer(kind=I4), public :: free_threads number of free threads in case of open_MP computation Source Code type NUM_PAR real ( kind = R8 ) :: relax !! *relaxation parameter* real ( kind = R8 ) :: eps !! *error for convergence* integer ( kind = I4 ) :: it_max !! *maximal number of iterations* integer ( kind = I4 ) :: mess !! *message* integer ( kind = I4 ) :: free_threads !! *number of free threads in case of open_MP computation* endtype NUM_PAR","tags":""},{"title":"solve_syst – MSOLV-fortran","loc":"proc/solve_syst.html","text":"public subroutine solve_syst(mat, step) Note General hat subroutine that handles the resolution steps: * ini solver initialization * ana solver analyzis when it's proposed by the solver * fac solver factorization * sol solver solution * fre solver memory release when it's proposed by the solver * end solver end Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type character(len=*), intent(in) :: step 'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver Calls proc~~solve_syst~~CallsGraph proc~solve_syst solve_syst proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver mpi_finalize mpi_finalize proc~solution_solver->mpi_finalize proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu dmumps dmumps proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~factorize_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~close_solver->dmumps proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~analyse_solver->dmumps proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~init_solver->mpi_finalize mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~init_solver->dmumps ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~close_superlu->interface~destroy_compcol_matrix interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric var panprocsolve_systCallsGraph = svgPanZoom('#procsolve_systCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solve_syst~~CalledByGraph proc~solve_syst solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solve_syst Source Code subroutine solve_syst ( mat , step ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* character ( len =* ), intent ( in ) :: step !! *'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver* if ( index ( step , 'ini' ) /= 0 ) then ; call init_solver ( mat ) ; return ; endif if ( index ( step , 'ana' ) /= 0 ) then ; call analyse_solver ( mat ) ; return ; endif if ( index ( step , 'fac' ) /= 0 ) then ; call factorize_solver ( mat ) ; return ; endif if ( index ( step , 'sol' ) /= 0 ) then ; call solution_solver ( mat ) ; return ; endif if ( index ( step , 'fre' ) /= 0 ) then ; call freefact_solver ( mat ) ; return ; endif if ( index ( step , 'end' ) /= 0 ) then ; call close_solver ( mat ) ; return ; endif stop 'Bad step chosen in SOLVE_SYST' return endsubroutine solve_syst","tags":""},{"title":"init_solver – MSOLV-fortran","loc":"proc/init_solver.html","text":"public subroutine init_solver(mat) Note Subroutine to initialize the matrices of the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~init_solver~~CallsGraph proc~init_solver init_solver proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_finalize mpi_finalize proc~init_solver->mpi_finalize mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control dmumps dmumps proc~init_solver->dmumps proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults ma48_initialize ma48_initialize proc~init_solver->ma48_initialize interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_solver~~CalledByGraph proc~init_solver init_solver proc~solve_syst solve_syst proc~solve_syst->proc~init_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_solver Source Code subroutine init_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr ! allocation of the system vectors: rhs and unknown allocate ( mat % b ( mat % nn ), mat % x ( mat % nn ) ) mat % b = HIG_R8 mat % x = HIG_R8 ! check solver type select case ( mat % slv_t ) case ( MA48 ) call ma48_initialize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matma48 % ctrl % wp = - 1 mat % matma48 % ctrl % mp = - 1 mat % matma48 % ctrl % ldiag = - 1 case ( PRINT_MESS :) mat % matma48 % ctrl % ldiag = + 2 endselect case ( MUMP ) call mpi_init ( ierr ) mat % matmump % comm = MPI_COMM_WORLD mat % matmump % job = - 1 ! initialisation mat % matmump % sym = 0 ! no symetry mat % matmump % par = 1 ! MPI, host working call dmumps ( mat % matmump ) mat % matmump % icntl ( 5 ) = 1 ! Specify element entry : elemental matrices if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'MUMP error, INIT_SOLVER' endif select case ( SOLV_MESS ) case ( NO_MESS ) mat % matmump % icntl ( 4 ) = 1 ! error output only case ( PRINT_MESS :) mat % matmump % icntl ( 4 ) = 3 ! all error output endselect case ( SULU ) call init_superlu ( sulu = mat % matsulu ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matsulu % options % PrintStat = 0 case ( PRINT_MESS :) mat % matsulu % options % PrintStat = 1 endselect case ( UMFP ) mat % matumfp % c_numeric = C_NULL_PTR call umfpack_di_defaults ( mat % matumfp % c_control ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matumfp % c_control ( UMFPACK_PRL ) = 1 case ( PRINT_MESS :) mat % matumfp % c_control ( UMFPACK_PRL ) = 2 endselect call umfpack_di_report_control ( mat % matumfp % c_control ) case default stop 'Unknown solver type, INIT_SOLVER' endselect return endsubroutine init_solver","tags":""},{"title":"analyse_solver – MSOLV-fortran","loc":"proc/analyse_solver.html","text":"public subroutine analyse_solver(mat) Note Subroutine to analyse, factorize (symbolic) the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~analyse_solver~~CallsGraph proc~analyse_solver analyse_solver ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse dmumps dmumps proc~analyse_solver->dmumps proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~analyse_solver~~CalledByGraph proc~analyse_solver analyse_solver proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code analyse_solver Source Code subroutine analyse_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) mat % matma48 % zmat % row => mat % irow mat % matma48 % zmat % col => mat % jcol mat % matma48 % zmat % val => mat % a_elt mat % matma48 % zmat % n = mat % nn mat % matma48 % zmat % m = mat % nn mat % matma48 % zmat % ne = mat % nz call ma48_analyse ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & ainfo = mat % matma48 % ainf , & finfo = mat % matma48 % finf ) if ( mat % matma48 % ainf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_analyse with ainfop%flag = ' , mat % matma48 % ainf % flag stop endif case ( MUMP ) mat % matmump % eltptr => mat % eltptr mat % matmump % eltvar => mat % eltvar mat % matmump % a_elt => mat % a_elt mat % matmump % rhs => mat % b mat % matmump % n = mat % nn mat % matmump % nelt = mat % ne mat % matmump % job = 1 ! performs the analysis call dmumps ( mat % matmump ) case ( SULU ) mat % matsulu % irow => mat % irow mat % matsulu % jptr => mat % jptr mat % matsulu % a_elt => mat % a_elt mat % matsulu % b => mat % b mat % matsulu % n = mat % nn mat % matsulu % nz = mat % nz mat % matsulu % nrhs = 1 mat % matsulu % first = . true . call prep_superlu ( sulu = mat % matsulu ) case ( UMFP ) call s_umfpack_di_symbolic ( n_row = mat % nn , & n_col = mat % nn , & Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'ANALYSE_SOLVER : unknown solver type' endselect return endsubroutine analyse_solver","tags":""},{"title":"factorize_solver – MSOLV-fortran","loc":"proc/factorize_solver.html","text":"public subroutine factorize_solver(mat) Note Subroutine to factorize the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~factorize_solver~~CallsGraph proc~factorize_solver factorize_solver proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize dmumps dmumps proc~factorize_solver->dmumps proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~factorize_solver~~CalledByGraph proc~factorize_solver factorize_solver proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code factorize_solver Source Code subroutine factorize_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) call ma48_factorize ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & finfo = mat % matma48 % finf , & fast = mat % matma48 % fast ) if ( mat % matma48 % finf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_factorize with finfo%flag = ' , mat % matma48 % finf % flag stop endif case ( MUMP ) mat % matmump % job = 2 call dmumps ( mat % matmump ) case ( SULU ) ! Just factorize once, in the case that the matrix doesn't change much if ( mat % matsulu % first ) call fact_superlu ( sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! first release memory call s_umfpack_di_numeric ( Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Numeric = mat % matumfp % c_numeric , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'Unknown solver type, FACTORIZE_SOLVER' endselect return endsubroutine factorize_solver","tags":""},{"title":"solution_solver – MSOLV-fortran","loc":"proc/solution_solver.html","text":"public subroutine solution_solver(mat) Note Subroutine to solve the system [A]\\{x\\} = \\{b\\} (sparse A) Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~solution_solver~~CallsGraph proc~solution_solver solution_solver ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu mpi_finalize mpi_finalize proc~solution_solver->mpi_finalize dmumps dmumps proc~solution_solver->dmumps proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statfree StatFree proc~solv_superlu->interface~statfree proc~prep_superlu prep_superlu proc~solv_superlu->proc~prep_superlu interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solution_solver~~CalledByGraph proc~solution_solver solution_solver proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solution_solver Source Code subroutine solution_solver ( mat ) implicit none type ( MAT_SOLV ), target , intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr select case ( mat % slv_t ) case ( MA48 ) call ma48_solve ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & rhs = mat % b , & x = mat % x , & control = mat % matma48 % ctrl , & sinfo = mat % matma48 % sinf , & resid = mat % matma48 % resid , & error = mat % error ) case ( MUMP ) mat % matmump % job = 3 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error in SOLUTION_SOLVER' endif ! solution has been assembled on the host if ( mat % matmump % myid == 0 ) then mat % x ( 1 : mat % nn ) = mat % matmump % rhs ( 1 : mat % nn ) endif case ( SULU ) call solv_superlu ( sol_x = mat % x , & sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) mat % matsulu % first = . false . case ( UMFP ) ! Numeric factors must exist if (. not . C_ASSOCIATED ( mat % matumfp % c_numeric )) call solve_syst ( mat , 'fac' ) mat % matumfp % c_control ( UMFPACK_IRSTEP ) = 0 ! solve ax=b, without iterative refinement ! If you want to evaluate the required RAM (Go) ! write(*,*) mat%matumfp%c_info(UMFPACK_PEAK_MEMORY_ESTIMATE)/mat%matumfp%c_info(UMFPACK_SIZE_OF_UNIT)/1e9 ! write(*,*) sizeof(mat%a_elt)/1e9 call s_umfpack_di_solve ( sys = UMFPACK_A , & x = mat % x , & b = mat % b , & numeric = mat % matumfp % c_numeric , & control = mat % matumfp % c_control , & info = mat % matumfp % c_info ) if ( mat % matumfp % c_info ( UMFPACK_STATUS ) < 0 ) then write ( OPU , * ) 'error occurred in umfpack_di_solve: ' , mat % matumfp % c_info ( UMFPACK_STATUS ) stop 'Error in SOLUTION_SOLVER' endif case default stop 'Unknown solver type, SOLUTION_SOLVER' endselect return endsubroutine solution_solver","tags":""},{"title":"freefact_solver – MSOLV-fortran","loc":"proc/freefact_solver.html","text":"public subroutine freefact_solver(mat) Note Subroutine to free the factors if applicable Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~freefact_solver~~CallsGraph proc~freefact_solver freefact_solver proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~freefact_solver~~CalledByGraph proc~freefact_solver freefact_solver proc~solve_syst solve_syst proc~solve_syst->proc~freefact_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code freefact_solver Source Code subroutine freefact_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) continue case ( MUMP ) continue case ( SULU ) call free_superlu () case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization case default stop 'unknown solver type, FREEFACT_SOLVER' endselect return endsubroutine freefact_solver","tags":""},{"title":"close_solver – MSOLV-fortran","loc":"proc/close_solver.html","text":"public subroutine close_solver(mat) Note Subroutine to close the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~close_solver~~CallsGraph proc~close_solver close_solver mpi_finalize mpi_finalize proc~close_solver->mpi_finalize proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info dmumps dmumps proc~close_solver->dmumps proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_solver~~CalledByGraph proc~close_solver close_solver proc~solve_syst solve_syst proc~solve_syst->proc~close_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_solver Source Code subroutine close_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr deallocate ( mat % eltptr ) deallocate ( mat % eltvar ) select case ( mat % slv_t ) case ( MA48 ) nullify ( mat % matma48 % zmat % row ) nullify ( mat % matma48 % zmat % col ) nullify ( mat % matma48 % zmat % val ) call ma48_finalize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & info = ierr ) deallocate ( mat % b , mat % x ) case ( MUMP ) if ( mat % matmump % myid == 0 ) then nullify ( mat % matmump % rhs ) nullify ( mat % matmump % eltptr ) nullify ( mat % matmump % eltvar ) nullify ( mat % matmump % a_elt ) endif ! destroy the instance (deallocate internal data structures) mat % matmump % job = - 2 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error MUMP in close_solver' endif call mpi_finalize ( ierr ) deallocate ( mat % b , mat % x ) case ( SULU ) call close_superlu ( sulu = mat % matsulu ) nullify ( mat % matsulu % b ) nullify ( mat % matsulu % irow ) nullify ( mat % matsulu % jptr ) nullify ( mat % matsulu % a_elt ) case ( UMFP ) deallocate ( mat % jptr , mat % irow ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization ! no lu factors (numeric) are in memory at this point. call umfpack_di_free_symbolic ( Symbolic = mat % matumfp % c_symbolic ) ! free the symbolic analysis call umfpack_di_report_info ( Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) ! print final statistics deallocate ( mat % b , mat % x ) case default stop 'Unknown solver type, close_solver' endselect return endsubroutine close_solver","tags":""},{"title":"convert_matrice_format – MSOLV-fortran","loc":"proc/convert_matrice_format.html","text":"public subroutine convert_matrice_format(mat) Note Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~convert_matrice_format~~CallsGraph proc~convert_matrice_format convert_matrice_format proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~convert_matrice_format~~CalledByGraph proc~convert_matrice_format convert_matrice_format program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code convert_matrice_format Source Code subroutine convert_matrice_format ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ) :: i ! ======================================================================================================================= ! Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. ! ************************************************ ! Elemental entries (example provided by MUMP): ! A1 = 1|-1  2  3| A2 = 3|2 -1  3| !      2| 2  1  1|      4|1  2 -1| !      3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) ! ! A  = 1|-1  2  3  0  0| !      2| 2  1  1  0  0| !      3| 1  1  3 -1  3| !      4| 0  0  1  2 -1| !      5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix !                        => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last !                                               position being size(eltvar)+1) ! ! ************************************************ ! Assembled matrix : ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jptr = (1, 4, 7, 12, 15, 18) ! ! ======================================================================================================================= ! Triplet form ! ************************************************ ! For each non zero a_elt entry, returns its row and column number ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) call from_elemental_to_assembled ( mat = mat ) select case ( mat % slv_t ) case ( MA48 ) ! Triplet form: irow, jcol, a_elt continue case ( MUMP ) ! Compressed row, elemental entries chosen: eltptr, eltvar, a_elt continue case ( UMFP , SULU ) ! Compressed row, assembled form: irow, jptr, a_elt deallocate ( mat % jcol ) ! no more needed ! UMFP and SULU allocations begin at 0 (C convention) do i = 1 , mat % nn + 1 mat % jptr ( i ) = mat % jptr ( i ) - 1 enddo if ( mat % slv_t == SULU ) mat % matsulu % jptr => mat % jptr ! otherwise, matsulu%jptr will be associated to ! a deallocated part of memory do i = 1 , mat % nz mat % irow ( i ) = mat % irow ( i ) - 1 enddo case default stop 'Unknown solver type, CONVERT_MATRICE_FORMAT' endselect return endsubroutine convert_matrice_format","tags":""},{"title":"from_elemental_to_assembled – MSOLV-fortran","loc":"proc/from_elemental_to_assembled.html","text":"public subroutine from_elemental_to_assembled(mat) Note Subroutine to transform the elemental entries into assembled CC vectors Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Called by proc~~from_elemental_to_assembled~~CalledByGraph proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code from_elemental_to_assembled Source Code subroutine from_elemental_to_assembled ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ), pointer :: solver , nb_elt , n , ntot , nz integer ( kind = I4 ), dimension (:), pointer :: eltptr integer ( kind = I4 ), dimension (:), pointer :: eltvar real ( kind = R8 ), dimension (:), pointer :: a_elt integer ( kind = I4 ), dimension (:), pointer :: irow , jcol integer ( kind = I4 ), dimension (:), pointer :: jptr integer ( kind = I4 ) :: inelt , imatorder , i , j , ii , jj , i1 , i2 , ir1 , ir2 , jr1 , jr2 , itmp , innz , state solver => mat % slv_t nb_elt => mat % ne n => mat % nn ntot => mat % nt nz => mat % nz if ( solver == MUMP ) return ! conversion from elemental form to triplet form, perhaps with null a_elts !-------------------------------------------------------------------------- state = 0 if (. not . allocated ( mat % irow )) allocate ( mat % irow ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' if (. not . allocated ( mat % jcol )) allocate ( mat % jcol ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' eltptr => mat % eltptr eltvar => mat % eltvar a_elt => mat % a_elt irow => mat % irow jcol => mat % jcol jptr => mat % jptr irow ( 1 : ntot ) = - 1 jcol ( 1 : ntot ) = - 1 ii = 1 do inelt = 1 , nb_elt imatorder = eltptr ( inelt + 1 ) - eltptr ( inelt ) do i = 1 , imatorder irow ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ): eltptr ( inelt + 1 ) - 1 ) jcol ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ) + i - 1 ) ii = ii + imatorder enddo enddo ! where a_elt brings no contribution, rows and columns are zeroed !----------------------------------------------------------------- where ( abs ( a_elt ) < EPS_R8 ) irow = 0 jcol = 0 endwhere ! the triplet irow, jcol and a_elt is sorted according jcol !----------------------------------------------------------- call sort_int_1int_1real ( g = 1 , d = ntot , itabref = jcol ( 1 : ntot ), itab1 = irow ( 1 : ntot ), rtab2 = a_elt ( 1 : ntot )) ! column pointer determination for each new value !---------------------------------------------- if ( allocated ( mat % jptr )) deallocate ( mat % jptr ) ; allocate ( mat % jptr ( n + 1 ) ) ; jptr => mat % jptr ii = 1 do if ( jcol ( ii ) > 0 ) exit ! zeroed terms are ignored ii = ii + 1 enddo jptr ( 1 ) = ii do i = 1 , n - 1 itmp = jcol ( ii ) do ii = ii + 1 if ( jcol ( ii ) /= itmp ) exit enddo jptr ( i + 1 ) = ii enddo jptr ( n + 1 ) = ntot + 1 ! columns are already sorted; rows are now sorted for each row value !-------------------------------------------------------------------- do i = 1 , n i1 = jptr ( i ) i2 = jptr ( i + 1 ) - 1 call sort_int_1real ( g = 1 , d = i2 - i1 + 1 , itabref = irow ( i1 : i2 ), rtab1 = a_elt ( i1 : i2 )) enddo ! assembly starting from the jcol, irow and a_elt top ! for identical matrix locations, a_elts are added !----------------------------------------------------- innz = 1 jj = jptr ( 1 ) ! first non-zero element jr1 = jcol ( jj ) ir1 = irow ( jj ) jcol ( innz ) = jr1 irow ( innz ) = ir1 a_elt ( innz ) = a_elt ( jj ) do j = jj + 1 , ntot jr2 = jcol ( j ) ir2 = irow ( j ) if ( ( jr2 /= jr1 ). or .( ir2 /= ir1 ) ) then ! if row or column index has changed innz = innz + 1 ! a non-zero term is added jcol ( innz ) = jr2 irow ( innz ) = ir2 a_elt ( innz ) = a_elt ( j ) else a_elt ( innz ) = a_elt ( innz ) + a_elt ( j ) ! row and column indexes are the same, stiffness terms are added endif jr1 = jr2 ! stores (i-1) and (j-1) for further comparison ir1 = ir2 enddo nz = innz jcol ( nz + 1 : ntot ) = - 1 irow ( nz + 1 : ntot ) = - 1 a_elt ( nz + 1 : ntot ) = huge ( 1._R8 ) ! col pointer update !---------------------------------------------- jj = 1 jptr ( 1 ) = 1 do j = 1 , n - 1 itmp = jcol ( jj ) do jj = jj + 1 if ( jcol ( jj ) /= itmp ) exit enddo jptr ( j + 1 ) = jj enddo jptr ( n + 1 ) = nz + 1 nullify ( eltptr , eltvar , a_elt , irow , jcol , jptr ) return endsubroutine from_elemental_to_assembled","tags":""},{"title":"verif_solution – MSOLV-fortran","loc":"proc/verif_solution.html","text":"subroutine verif_solution(slv_struct, a_elt, b, error) Note The product \\{y\\} of the system matrix [A] by the solution \\{x\\} , is\n        calculated, and compared to the right hand side \\{b\\} .\n        The calculated error is the absolute error in %. Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(in) :: slv_struct real(kind=R8), intent(in), dimension(:) :: a_elt real(kind=R8), intent(in), dimension(:) :: b real(kind=R8), intent(out) :: error Calls proc~~verif_solution~~CallsGraph proc~verif_solution verif_solution proc~prod_elemental_x prod_elemental_x proc~verif_solution->proc~prod_elemental_x proc~prod_a_x prod_a_x proc~verif_solution->proc~prod_a_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~verif_solution~~CalledByGraph proc~verif_solution verif_solution program~test_solvers test_solvers program~test_solvers->proc~verif_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code verif_solution Source Code subroutine verif_solution ( slv_struct , a_elt , b , error ) implicit none type ( MAT_SOLV ), intent ( in ) :: slv_struct real ( kind = R8 ), dimension (:), intent ( in ) :: a_elt real ( kind = R8 ), dimension (:), intent ( in ) :: b real ( kind = R8 ), intent ( out ) :: error real ( kind = R8 ), dimension ( slv_struct % nn ) :: y ! to assess the accuracy, the solution is applied to the ! system matrix and compared to the rhs. if ( slv_struct % slv_t == MUMP ) then call prod_elemental_x ( n = slv_struct % nn , & nz = slv_struct % nt , & nelt = slv_struct % ne , & nvar = slv_struct % nvar , & x = slv_struct % x , & y = y , & a_elt = a_elt , & eltptr = slv_struct % eltptr , & eltvar = slv_struct % eltvar ) else call prod_a_x ( n = slv_struct % nn , & nz = slv_struct % nz , & x = slv_struct % x , & y = y , & a_elt = a_elt , & irow = slv_struct % irow , & jptr = slv_struct % jptr , & slvt = slv_struct % slv_t ) endif error = 100 * maxval ( abs ( y ( 1 : slv_struct % nn ) - b ( 1 : slv_struct % nn )) ) / & maxval ( abs ( y ( 1 : slv_struct % nn ) + b ( 1 : slv_struct % nn )) ) return endsubroutine verif_solution","tags":""},{"title":"modify_a_elt – MSOLV-fortran","loc":"proc/modify_a_elt.html","text":"subroutine modify_a_elt(tab, nz) Note multiplication of the system coefficient by a random factor Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout) :: tab (1:nz) integer(kind=I4), intent(in) :: nz Called by proc~~modify_a_elt~~CalledByGraph proc~modify_a_elt modify_a_elt program~test_solvers test_solvers program~test_solvers->proc~modify_a_elt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code modify_a_elt Source Code subroutine modify_a_elt ( tab , nz ) implicit none integer ( kind = I4 ), intent ( in ) :: nz real ( kind = R8 ), intent ( inout ) :: tab ( 1 : nz ) real ( kind = R8 ), allocatable :: tmp (:) allocate ( tmp ( 1 : nz )) call random_number ( harvest = tmp ( 1 : nz )) tmp ( 1 : nz ) = 2 * tmp ( 1 : nz ) - 1.0_R8 tab ( 1 : nz ) = tab ( 1 : nz ) * tmp ( 1 : nz ) deallocate ( tmp ) return endsubroutine modify_a_elt","tags":""},{"title":"prod_a_x – MSOLV-fortran","loc":"proc/prod_a_x.html","text":"subroutine prod_a_x(n, nz, x, y, a_elt, irow, jptr, slvt) Note [A] \\{x\\} , assembled CC format Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz) :: a_elt integer(kind=I4), intent(in), dimension(nz ) :: irow integer(kind=I4), intent(in), dimension(n+1) :: jptr integer(kind=I4), intent(in) :: slvt Called by proc~~prod_a_x~~CalledByGraph proc~prod_a_x prod_a_x proc~verif_solution verif_solution proc~verif_solution->proc~prod_a_x program~test_solvers test_solvers program~test_solvers->proc~verif_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code prod_a_x Source Code subroutine prod_a_x ( n , nz , x , y , a_elt , irow , jptr , slvt ) implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , slvt real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nz ), intent ( in ) :: irow integer ( kind = I4 ), dimension ( n + 1 ), intent ( in ) :: jptr real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , k , dec y ( 1 : n ) = 0._R8 dec = 0 if ( slvt == UMFP . or . slvt == SULU ) dec = 1 do i = 1 , n do k = jptr ( i ), jptr ( i + 1 ) - 1 y ( irow ( k + dec ) + dec ) = y ( irow ( k + dec ) + dec ) + x ( i ) * a_elt ( k + dec ) enddo enddo return endsubroutine prod_a_x","tags":""},{"title":"prod_elemental_x – MSOLV-fortran","loc":"proc/prod_elemental_x.html","text":"subroutine prod_elemental_x(n, nz, nelt, nvar, x, y, a_elt, eltptr, eltvar) Note [A] \\{x\\} , elemental CC format Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz integer(kind=I4), intent(in) :: nelt integer(kind=I4), intent(in) :: nvar real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz     ) :: a_elt integer(kind=I4), intent(in), dimension(nelt +1) :: eltptr integer(kind=I4), intent(in), dimension(nvar   ) :: eltvar Called by proc~~prod_elemental_x~~CalledByGraph proc~prod_elemental_x prod_elemental_x proc~verif_solution verif_solution proc~verif_solution->proc~prod_elemental_x program~test_solvers test_solvers program~test_solvers->proc~verif_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code prod_elemental_x Source Code subroutine prod_elemental_x ( n , nz , nelt , nvar , x , y , a_elt , eltptr , eltvar ) implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , nelt , nvar real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nelt + 1 ), intent ( in ) :: eltptr integer ( kind = I4 ), dimension ( nvar ), intent ( in ) :: eltvar real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , j , k , kk , inc_nz , inc_nn , n_elem , i_elem , max_n_elem real ( kind = R8 ), dimension (:), allocatable :: a_elt_tmp , x_tmp , y_tmp inc_nz = 0 inc_nn = 0 n_elem = 0 y = 0._R8 max_n_elem = 0 do i_elem = 1 , nelt max_n_elem = max ( max_n_elem , eltptr ( i_elem + 1 ) - eltptr ( i_elem )) enddo allocate ( a_elt_tmp ( 1 : max_n_elem ** 2 ) ) allocate ( x_tmp ( 1 : max_n_elem ) ) allocate ( y_tmp ( 1 : max_n_elem ) ) do i_elem = 1 , nelt ! browse all elemental matrices inc_nn = inc_nn + n_elem ! step in eltvar for matrix number i_elem inc_nz = inc_nz + n_elem ** 2 ! step in a_elt for matrix number i_elem n_elem = eltptr ( i_elem + 1 ) - eltptr ( i_elem ) ! elemental matrix size a_elt_tmp ( 1 : n_elem ** 2 ) = a_elt ( inc_nz + 1 : inc_nz + n_elem ** 2 ) ! elemental matrix coefficients ! --- elemental rhs kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 x_tmp ( kk ) = x ( eltvar ( k )) enddo ! --- elemental product y_tmp ( 1 : n_elem ) = 0._R8 do i = 1 , n_elem do j = 1 , n_elem y_tmp ( i ) = y_tmp ( i ) + a_elt_tmp ( i + n_elem * ( j - 1 )) * x_tmp ( j ) enddo enddo ! --- elemental product in global vector y kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 y ( eltvar ( k )) = y ( eltvar ( k )) + y_tmp ( kk ) enddo enddo deallocate ( a_elt_tmp , x_tmp , y_tmp ) return endsubroutine prod_elemental_x","tags":""},{"title":"init_superlu – MSOLV-fortran","loc":"proc/init_superlu.html","text":"public subroutine init_superlu(sulu) Note Subroutine to set the default LU behaviour sulu%options%Fact               = DOFACT sulu%options%Equil              = YES sulu%options%ColPerm            = COLAMD sulu%options%DiagPivotThresh    = 1.0 sulu%options%Trans              = NOTRANS sulu%options%IterRefine         = NOREFINE sulu%options%SymmetricMode      = NO sulu%options%PivotGrowth        = NO sulu%options%ConditionNumber    = NO sulu%options%PrintStat          = YES Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~init_superlu~~CallsGraph proc~init_superlu init_superlu interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_superlu~~CalledByGraph proc~init_superlu init_superlu proc~init_solver init_solver proc~init_solver->proc~init_superlu proc~solve_syst solve_syst proc~solve_syst->proc~init_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_superlu Source Code subroutine init_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call set_default_options ( sulu % options ) return endsubroutine init_superlu","tags":""},{"title":"prep_superlu – MSOLV-fortran","loc":"proc/prep_superlu.html","text":"public subroutine prep_superlu(sulu) Note Subroutine to prepare the SULU_ENV components Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~prep_superlu~~CallsGraph proc~prep_superlu prep_superlu interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~prep_superlu~~CalledByGraph proc~prep_superlu prep_superlu proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solv_superlu program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code prep_superlu Source Code subroutine prep_superlu ( sulu ) implicit none type ( sulu_env ), intent ( inout ) :: sulu integer ( kind = I4 ) :: nn , nz , nb nn = sulu % n nz = sulu % nz nb = sulu % nrhs if (. not . allocated ( sulu % perm_c )) then allocate ( sulu % perm_c ( 1 : nn ) ) allocate ( sulu % perm_r ( 1 : nn ) ) allocate ( sulu % etree ( 1 : nn ) ) allocate ( sulu % RR ( 1 : nn ) ) allocate ( sulu % CC ( 1 : nn ) ) allocate ( sulu % ferr ( 1 : nb ) ) allocate ( sulu % berr ( 1 : nb ) ) allocate ( sulu % rpg ( 1 : nb ) ) allocate ( sulu % rcond ( 1 : nb ) ) allocate ( sulu % x ( 1 : nn ) ) endif sulu % x ( 1 : nn ) = 0 call dCreate_CompCol_Matrix ( A = sulu % SMA , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % n , & ! in int nnz = sulu % nz , & ! in int nzval = sulu % a_elt , & ! in double dimension() rowind = sulu % irow , & ! in int dimension() colptr = sulu % jptr , & ! in int dimension() stype = SLU_NC , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smb , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % b , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smx , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % x , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) return endsubroutine prep_superlu","tags":""},{"title":"fact_superlu – MSOLV-fortran","loc":"proc/fact_superlu.html","text":"public subroutine fact_superlu(sulu, verbose) Note Subroutine to factorize the system note the directives: sulu%options%Fact = DOFACT sulu%SMB%ncol     = 0 Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose Calls proc~~fact_superlu~~CallsGraph proc~fact_superlu fact_superlu interface~dgssvx dgssvx proc~fact_superlu->interface~dgssvx interface~statfree StatFree proc~fact_superlu->interface~statfree interface~statinit StatInit proc~fact_superlu->interface~statinit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fact_superlu Source Code subroutine fact_superlu ( sulu , verbose ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose sulu % lwork = 0 call StatInit ( sulu % stat ) sulu % options % Fact = DOFACT sulu % SMB % ncol = 0 call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) return endsubroutine fact_superlu","tags":""},{"title":"solv_superlu – MSOLV-fortran","loc":"proc/solv_superlu.html","text":"public subroutine solv_superlu(sol_x, sulu, verbose) Note Subroutine to solve the system If no resolution has yet occured, sulu%first= true sulu%options%Fact = FACTORED sulu%SMB%ncol     = sulu%nrhs (usually 1 ) otherwise sulu%options%Fact = SAMEPATTERN sma, smb and smx are recreated but do not forget that we still have: mat%matsulu%irow   => mat%irow mat%matsulu%jptr   => mat%jptr mat%matsulu%a_elt  => mat%a_elt mat%matsulu%b      => mat%b Note The solution is retrieved with the pointer store of type NCFORMAT which\n gives access to nzval Warning At the end, the memory is released with the dstruction of sml and smu Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(:) :: sol_x type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose Calls proc~~solv_superlu~~CallsGraph proc~solv_superlu solv_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statfree StatFree proc~solv_superlu->interface~statfree proc~prep_superlu prep_superlu proc~solv_superlu->proc~prep_superlu interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solv_superlu~~CalledByGraph proc~solv_superlu solv_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solv_superlu Source Code subroutine solv_superlu ( sol_x , sulu , verbose ) implicit none real ( kind = R8 ), dimension (:), intent ( inout ) :: sol_x type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose type ( NCFORMAT ), pointer :: Xstore real ( kind = R8 ), pointer :: tabX (:) integer ( kind = I4 ) :: i call StatInit ( sulu % stat ) if ( sulu % first ) then sulu % options % Fact = FACTORED sulu % SMB % ncol = sulu % nrhs else sulu % options % Fact = SAMEPATTERN call prep_superlu ( sulu ) endif call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) call c_f_pointer ( sulu % SMX % Store , XStore ) call c_f_pointer ( XStore % nzval , tabX , [ XStore % nnz ]) do i = 1 , sulu % n sol_x ( i ) = tabX ( i ) enddo nullify ( Xstore , tabX ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) call Destroy_SuperNode_Matrix ( sulu % SML ) call Destroy_CompCol_Matrix ( sulu % SMU ) return endsubroutine solv_superlu","tags":""},{"title":"free_superlu – MSOLV-fortran","loc":"proc/free_superlu.html","text":"public subroutine free_superlu() Note Subroutine that actually does nothing yet. Maybe, there will be extra memory that\n could be released here? Arguments None Called by proc~~free_superlu~~CalledByGraph proc~free_superlu free_superlu proc~freefact_solver freefact_solver proc~freefact_solver->proc~free_superlu proc~solve_syst solve_syst proc~solve_syst->proc~freefact_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code free_superlu Source Code subroutine free_superlu () implicit none !type(SULU_ENV), intent(inout) :: sulu return endsubroutine free_superlu","tags":""},{"title":"close_superlu – MSOLV-fortran","loc":"proc/close_superlu.html","text":"public subroutine close_superlu(sulu) Note Subroutine to close the SuperLU process, with memory release Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~close_superlu~~CallsGraph proc~close_superlu close_superlu interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_superlu~~CalledByGraph proc~close_superlu close_superlu proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~close_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_superlu Source Code subroutine close_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call Destroy_CompCol_Matrix ( sulu % SMA ) call Destroy_Dense_Matrix ( sulu % smb ) call Destroy_Dense_Matrix ( sulu % smx ) deallocate ( sulu % perm_c ) deallocate ( sulu % perm_r ) deallocate ( sulu % etree ) deallocate ( sulu % RR ) deallocate ( sulu % CC ) deallocate ( sulu % ferr ) deallocate ( sulu % berr ) deallocate ( sulu % rpg ) deallocate ( sulu % rcond ) return endsubroutine close_superlu","tags":""},{"title":"Destroy_SuperNode_Matrix – MSOLV-fortran","loc":"interface/destroy_supernode_matrix.html","text":"interface Called by interface~~destroy_supernode_matrix~~CalledByGraph interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu solv_superlu proc~solv_superlu->interface~destroy_supernode_matrix proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Destroy_SuperNode_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":""},{"title":"Destroy_SuperMatrix_Store – MSOLV-fortran","loc":"interface/destroy_supermatrix_store.html","text":"interface private subroutine Destroy_SuperMatrix_Store(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":""},{"title":"Destroy_CompCol_Matrix – MSOLV-fortran","loc":"interface/destroy_compcol_matrix.html","text":"interface Called by interface~~destroy_compcol_matrix~~CalledByGraph interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu close_superlu proc~close_superlu->interface~destroy_compcol_matrix proc~solv_superlu solv_superlu proc~solv_superlu->interface~destroy_compcol_matrix proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_syst->proc~close_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Destroy_CompCol_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":""},{"title":"Destroy_Dense_Matrix – MSOLV-fortran","loc":"interface/destroy_dense_matrix.html","text":"interface Called by interface~~destroy_dense_matrix~~CalledByGraph interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu close_superlu proc~close_superlu->interface~destroy_dense_matrix proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~close_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine Destroy_Dense_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":""},{"title":"StatInit – MSOLV-fortran","loc":"interface/statinit.html","text":"interface Called by interface~~statinit~~CalledByGraph interface~statinit StatInit proc~fact_superlu fact_superlu proc~fact_superlu->interface~statinit proc~solv_superlu solv_superlu proc~solv_superlu->interface~statinit proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine StatInit(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(out) :: stat","tags":""},{"title":"StatFree – MSOLV-fortran","loc":"interface/statfree.html","text":"interface Called by interface~~statfree~~CalledByGraph interface~statfree StatFree proc~fact_superlu fact_superlu proc~fact_superlu->interface~statfree proc~solv_superlu solv_superlu proc~solv_superlu->interface~statfree proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine StatFree(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat","tags":""},{"title":"dCreate_CompCol_Matrix – MSOLV-fortran","loc":"interface/dcreate_compcol_matrix.html","text":"interface Called by interface~~dcreate_compcol_matrix~~CalledByGraph interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu prep_superlu proc~prep_superlu->interface~dcreate_compcol_matrix proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solv_superlu program~test_solvers test_solvers program~test_solvers->proc~solve_syst var paninterfacedcreate_compcol_matrixCalledByGraph = svgPanZoom('#interfacedcreate_compcol_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine dCreate_CompCol_Matrix(A, m, n, nnz, nzval, rowind, colptr, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: A integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n integer(kind=C_INT), intent(in), value :: nnz real(kind=C_DOUBLE), intent(in) :: nzval (*) integer(kind=C_INT), intent(in) :: rowind (*) integer(kind=C_INT), intent(in) :: colptr (*) integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype","tags":""},{"title":"dCreate_Dense_Matrix – MSOLV-fortran","loc":"interface/dcreate_dense_matrix.html","text":"interface Called by interface~~dcreate_dense_matrix~~CalledByGraph interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu prep_superlu proc~prep_superlu->interface~dcreate_dense_matrix proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solv_superlu program~test_solvers test_solvers program~test_solvers->proc~solve_syst var paninterfacedcreate_dense_matrixCalledByGraph = svgPanZoom('#interfacedcreate_dense_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine dCreate_Dense_Matrix(BX, m, n, x, ldx, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: BX integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n real(kind=C_DOUBLE), intent(in) :: x (*) integer(kind=C_INT), intent(in), value :: ldx integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype","tags":""},{"title":"set_default_options – MSOLV-fortran","loc":"interface/set_default_options.html","text":"interface Called by interface~~set_default_options~~CalledByGraph interface~set_default_options set_default_options proc~init_superlu init_superlu proc~init_superlu->interface~set_default_options proc~init_solver init_solver proc~init_solver->proc~init_superlu proc~solve_syst solve_syst proc~solve_syst->proc~init_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine set_default_options(options) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(inout) :: options","tags":""},{"title":"dgssvx – MSOLV-fortran","loc":"interface/dgssvx.html","text":"interface Called by interface~~dgssvx~~CalledByGraph interface~dgssvx dgssvx proc~fact_superlu fact_superlu proc~fact_superlu->interface~dgssvx proc~solv_superlu solv_superlu proc~solv_superlu->interface~dgssvx proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine dgssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, U, work, lwork, B, X, recip_pivot_growth, rcond, ferr, berr, Glu, mem_usage, stat, info) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(in) :: options type( SUPERMATRIX ), intent(inout) :: A integer(kind=C_INT), intent(inout) :: perm_c (*) integer(kind=C_INT), intent(inout) :: perm_r (*) integer(kind=C_INT), intent(inout) :: etree (*) character(kind=C_CHAR), intent(inout) :: equed (*) real(kind=C_DOUBLE), intent(inout) :: R (*) real(kind=C_DOUBLE), intent(inout) :: C (*) type( SUPERMATRIX ), intent(inout) :: L type( SUPERMATRIX ), intent(inout) :: U type(C_PTR), intent(out) :: work integer(kind=C_INT), intent(in), value :: lwork type( SUPERMATRIX ), intent(inout) :: B type( SUPERMATRIX ), intent(out) :: X real(kind=C_DOUBLE), intent(out) :: recip_pivot_growth (*) real(kind=C_DOUBLE), intent(out) :: rcond (*) real(kind=C_DOUBLE), intent(out) :: ferr (*) real(kind=C_DOUBLE), intent(out) :: berr (*) type( GLOBALLU_T ), intent(inout) :: Glu type( MEM_USAGE_T ), intent(out) :: mem_usage type( SUPERLUSTAT_T ), intent(out) :: stat integer(kind=C_INT), intent(out) :: info","tags":""},{"title":"StatPrint – MSOLV-fortran","loc":"interface/statprint.html","text":"interface private subroutine StatPrint(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat","tags":""},{"title":"umfpack_di_symbolic – MSOLV-fortran","loc":"proc/umfpack_di_symbolic.html","text":"public function umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_symbolic~~CallsGraph proc~umfpack_di_symbolic umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_symbolic~~CalledByGraph proc~umfpack_di_symbolic umfpack_di_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym var panprocumfpack_di_symbolicCalledByGraph = svgPanZoom('#procumfpack_di_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_symbolic – MSOLV-fortran","loc":"proc/umfpack_zi_symbolic.html","text":"public function umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_symbolic~~CallsGraph proc~umfpack_zi_symbolic umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_zi_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_symbolic – MSOLV-fortran","loc":"proc/umfpack_ci_symbolic.html","text":"public function umfpack_ci_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_symbolic~~CallsGraph proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_symbolic~~CalledByGraph proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym var panprocumfpack_ci_symbolicCalledByGraph = svgPanZoom('#procumfpack_ci_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_numeric – MSOLV-fortran","loc":"proc/umfpack_di_numeric.html","text":"public function umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_numeric~~CallsGraph proc~umfpack_di_numeric umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_numeric~~CalledByGraph proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum var panprocumfpack_di_numericCalledByGraph = svgPanZoom('#procumfpack_di_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_numeric – MSOLV-fortran","loc":"proc/umfpack_zi_numeric.html","text":"public function umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_numeric~~CallsGraph proc~umfpack_zi_numeric umfpack_zi_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_zi_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_numeric – MSOLV-fortran","loc":"proc/umfpack_ci_numeric.html","text":"public function umfpack_ci_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_numeric~~CallsGraph proc~umfpack_ci_numeric umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_numeric~~CalledByGraph proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum var panprocumfpack_ci_numericCalledByGraph = svgPanZoom('#procumfpack_ci_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_solve – MSOLV-fortran","loc":"proc/umfpack_di_solve.html","text":"public function umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_solve~~CallsGraph proc~umfpack_di_solve umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_solve~~CalledByGraph proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_di_solve proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr var panprocumfpack_di_solveCalledByGraph = svgPanZoom('#procumfpack_di_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_solve – MSOLV-fortran","loc":"proc/umfpack_zi_solve.html","text":"public function umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), optional target :: Az (*) real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_solve~~CallsGraph proc~umfpack_zi_solve umfpack_zi_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_zi_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_solve – MSOLV-fortran","loc":"proc/umfpack_ci_solve.html","text":"public function umfpack_ci_solve(sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_solve~~CallsGraph proc~umfpack_ci_solve umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_solve~~CalledByGraph proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_ci_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr var panprocumfpack_ci_solveCalledByGraph = svgPanZoom('#procumfpack_ci_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_scale – MSOLV-fortran","loc":"proc/umfpack_di_scale.html","text":"public function umfpack_di_scale(X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_di_scale~~CallsGraph proc~umfpack_di_scale umfpack_di_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_scale~~CalledByGraph proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale s_umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_di_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_scale – MSOLV-fortran","loc":"proc/umfpack_zi_scale.html","text":"public function umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_zi_scale~~CallsGraph proc~umfpack_zi_scale umfpack_zi_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_zi_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_scale – MSOLV-fortran","loc":"proc/umfpack_ci_scale.html","text":"public function umfpack_ci_scale(Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_ci_scale~~CallsGraph proc~umfpack_ci_scale umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_scale~~CalledByGraph proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_save_numeric – MSOLV-fortran","loc":"proc/umfpack_di_save_numeric.html","text":"public function umfpack_di_save_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_save_numeric~~CallsGraph proc~umfpack_di_save_numeric umfpack_di_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_save_numeric~~CalledByGraph proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_save_numeric – MSOLV-fortran","loc":"proc/umfpack_zi_save_numeric.html","text":"public function umfpack_zi_save_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_save_numeric~~CallsGraph proc~umfpack_zi_save_numeric umfpack_zi_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_save_numeric~~CalledByGraph proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_save_numeric – MSOLV-fortran","loc":"proc/umfpack_save_numeric.html","text":"public function umfpack_save_numeric(Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_save_numeric~~CallsGraph proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_save_numeric~~CalledByGraph proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_save_symbolic – MSOLV-fortran","loc":"proc/umfpack_di_save_symbolic.html","text":"public function umfpack_di_save_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_save_symbolic~~CallsGraph proc~umfpack_di_save_symbolic umfpack_di_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_save_symbolic~~CalledByGraph proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_save_symbolic – MSOLV-fortran","loc":"proc/umfpack_zi_save_symbolic.html","text":"public function umfpack_zi_save_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_save_symbolic~~CallsGraph proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_save_symbolic~~CalledByGraph proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_save_symbolic – MSOLV-fortran","loc":"proc/umfpack_save_symbolic.html","text":"public function umfpack_save_symbolic(Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_save_symbolic~~CallsGraph proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_save_symbolic~~CalledByGraph proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_load_numeric – MSOLV-fortran","loc":"proc/umfpack_di_load_numeric.html","text":"public function umfpack_di_load_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_load_numeric~~CallsGraph proc~umfpack_di_load_numeric umfpack_di_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_load_numeric~~CalledByGraph proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_load_numeric – MSOLV-fortran","loc":"proc/umfpack_zi_load_numeric.html","text":"public function umfpack_zi_load_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_load_numeric~~CallsGraph proc~umfpack_zi_load_numeric umfpack_zi_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_load_numeric~~CalledByGraph proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_load_numeric – MSOLV-fortran","loc":"proc/umfpack_load_numeric.html","text":"public function umfpack_load_numeric(Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_load_numeric~~CallsGraph proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_load_numeric~~CalledByGraph proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_load_symbolic – MSOLV-fortran","loc":"proc/umfpack_di_load_symbolic.html","text":"public function umfpack_di_load_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_load_symbolic~~CallsGraph proc~umfpack_di_load_symbolic umfpack_di_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_load_symbolic~~CalledByGraph proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_load_symbolic – MSOLV-fortran","loc":"proc/umfpack_zi_load_symbolic.html","text":"public function umfpack_zi_load_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_load_symbolic~~CallsGraph proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_load_symbolic~~CalledByGraph proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_load_symbolic – MSOLV-fortran","loc":"proc/umfpack_load_symbolic.html","text":"public function umfpack_load_symbolic(Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_load_symbolic~~CallsGraph proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_load_symbolic~~CalledByGraph proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_operator_CSC – MSOLV-fortran","loc":"proc/umfpack_di_operator_csc.html","text":"public function umfpack_di_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_csc~~CallsGraph proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocumfpack_di_operator_cscCallsGraph = svgPanZoom('#procumfpack_di_operator_cscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_csc~~CalledByGraph proc~umfpack_di_operator_csc umfpack_di_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_operator_CSC – MSOLV-fortran","loc":"proc/umfpack_zi_operator_csc.html","text":"public function umfpack_zi_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_csc~~CallsGraph proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_cscCallsGraph = svgPanZoom('#procumfpack_zi_operator_cscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_csc~~CalledByGraph proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_operator_CSC – MSOLV-fortran","loc":"proc/umfpack_ci_operator_csc.html","text":"public function umfpack_ci_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_csc~~CallsGraph proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumfpack_ci_operator_cscCallsGraph = svgPanZoom('#procumfpack_ci_operator_cscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_csc~~CalledByGraph proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_operator_CSR – MSOLV-fortran","loc":"proc/umfpack_di_operator_csr.html","text":"public function umfpack_di_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_csr~~CallsGraph proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocumfpack_di_operator_csrCallsGraph = svgPanZoom('#procumfpack_di_operator_csrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_csr~~CalledByGraph proc~umfpack_di_operator_csr umfpack_di_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_operator_CSR – MSOLV-fortran","loc":"proc/umfpack_zi_operator_csr.html","text":"public function umfpack_zi_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_csr~~CallsGraph proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_csrCallsGraph = svgPanZoom('#procumfpack_zi_operator_csrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_csr~~CalledByGraph proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_operator_CSR – MSOLV-fortran","loc":"proc/umfpack_ci_operator_csr.html","text":"public function umfpack_ci_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_csr~~CallsGraph proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumfpack_ci_operator_csrCallsGraph = svgPanZoom('#procumfpack_ci_operator_csrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_csr~~CalledByGraph proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_operator_pCSC – MSOLV-fortran","loc":"proc/umfpack_di_operator_pcsc.html","text":"public function umfpack_di_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_pcsc~~CallsGraph proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocumfpack_di_operator_pcscCallsGraph = svgPanZoom('#procumfpack_di_operator_pcscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_pcsc~~CalledByGraph proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_operator_pCSC – MSOLV-fortran","loc":"proc/umfpack_zi_operator_pcsc.html","text":"public function umfpack_zi_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_pcsc~~CallsGraph proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_pcscCallsGraph = svgPanZoom('#procumfpack_zi_operator_pcscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_pcsc~~CalledByGraph proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_operator_pCSC – MSOLV-fortran","loc":"proc/umfpack_ci_operator_pcsc.html","text":"public function umfpack_ci_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_pcsc~~CallsGraph proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumfpack_ci_operator_pcscCallsGraph = svgPanZoom('#procumfpack_ci_operator_pcscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_pcsc~~CalledByGraph proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_operator_pCSR – MSOLV-fortran","loc":"proc/umfpack_di_operator_pcsr.html","text":"public function umfpack_di_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_pcsr~~CallsGraph proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocumfpack_di_operator_pcsrCallsGraph = svgPanZoom('#procumfpack_di_operator_pcsrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_pcsr~~CalledByGraph proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_operator_pCSR – MSOLV-fortran","loc":"proc/umfpack_zi_operator_pcsr.html","text":"public function umfpack_zi_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_pcsr~~CallsGraph proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_pcsrCallsGraph = svgPanZoom('#procumfpack_zi_operator_pcsrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_pcsr~~CalledByGraph proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_ci_operator_pCSR – MSOLV-fortran","loc":"proc/umfpack_ci_operator_pcsr.html","text":"public function umfpack_ci_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_pcsr~~CallsGraph proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumfpack_ci_operator_pcsrCallsGraph = svgPanZoom('#procumfpack_ci_operator_pcsrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_pcsr~~CalledByGraph proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_CSC_di – MSOLV-fortran","loc":"proc/make_csc_di.html","text":"public function make_CSC_di(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) Called by proc~~make_csc_di~~CalledByGraph proc~make_csc_di make_CSC_di interface~pcsc pCSC interface~pcsc->proc~make_csc_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_CSC_zi – MSOLV-fortran","loc":"proc/make_csc_zi.html","text":"public function make_CSC_zi(Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) Called by proc~~make_csc_zi~~CalledByGraph proc~make_csc_zi make_CSC_zi interface~pcsc pCSC interface~pcsc->proc~make_csc_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_CSC_ci – MSOLV-fortran","loc":"proc/make_csc_ci.html","text":"public function make_CSC_ci(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) Called by proc~~make_csc_ci~~CalledByGraph proc~make_csc_ci make_CSC_ci interface~pcsc pCSC interface~pcsc->proc~make_csc_ci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_CSR_di – MSOLV-fortran","loc":"proc/make_csr_di.html","text":"public function make_CSR_di(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) Called by proc~~make_csr_di~~CalledByGraph proc~make_csr_di make_CSR_di interface~pcsr pCSR interface~pcsr->proc~make_csr_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_CSR_zi – MSOLV-fortran","loc":"proc/make_csr_zi.html","text":"public function make_CSR_zi(Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) Called by proc~~make_csr_zi~~CalledByGraph proc~make_csr_zi make_CSR_zi interface~pcsr pCSR interface~pcsr->proc~make_csr_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_CSR_ci – MSOLV-fortran","loc":"proc/make_csr_ci.html","text":"public function make_CSR_ci(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) Called by proc~~make_csr_ci~~CalledByGraph proc~make_csr_ci make_CSR_ci interface~pcsr pCSR interface~pcsr->proc~make_csr_ci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"make_Vec_zi – MSOLV-fortran","loc":"proc/make_vec_zi.html","text":"public function make_Vec_zi(bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) Called by proc~~make_vec_zi~~CalledByGraph proc~make_vec_zi make_Vec_zi interface~pvec pVec interface~pvec->proc~make_vec_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_di_symbolic.html","text":"public subroutine s_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_symbolic~~CallsGraph proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_symbolic~~CalledByGraph proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_zi_symbolic.html","text":"public subroutine s_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_symbolic~~CallsGraph proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_ci_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_ci_symbolic.html","text":"public subroutine s_umfpack_ci_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_symbolic~~CallsGraph proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_symbolic~~CalledByGraph proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_numeric – MSOLV-fortran","loc":"proc/s_umfpack_di_numeric.html","text":"public subroutine s_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_numeric~~CallsGraph proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_numeric~~CalledByGraph proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_numeric – MSOLV-fortran","loc":"proc/s_umfpack_zi_numeric.html","text":"public subroutine s_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_numeric~~CallsGraph proc~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~umfpack_zi_numeric umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_ci_numeric – MSOLV-fortran","loc":"proc/s_umfpack_ci_numeric.html","text":"public subroutine s_umfpack_ci_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_numeric~~CallsGraph proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_numeric~~CalledByGraph proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_solve – MSOLV-fortran","loc":"proc/s_umfpack_di_solve.html","text":"public subroutine s_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_solve~~CallsGraph proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_solve~~CalledByGraph proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_solve – MSOLV-fortran","loc":"proc/s_umfpack_zi_solve.html","text":"public subroutine s_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in), optional :: Az (*) real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_solve~~CallsGraph proc~s_umfpack_zi_solve s_umfpack_zi_solve interface~umfpack_zi_solve umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_ci_solve – MSOLV-fortran","loc":"proc/s_umfpack_ci_solve.html","text":"public subroutine s_umfpack_ci_solve(sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_solve~~CallsGraph proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_solve~~CalledByGraph proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_free_symbolic – MSOLV-fortran","loc":"proc/umfpack_di_free_symbolic.html","text":"public subroutine umfpack_di_free_symbolic(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic Calls proc~~umfpack_di_free_symbolic~~CallsGraph proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_free_symbolic~~CalledByGraph proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_free_symbolic – MSOLV-fortran","loc":"proc/umfpack_zi_free_symbolic.html","text":"public subroutine umfpack_zi_free_symbolic(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic Calls proc~~umfpack_zi_free_symbolic~~CallsGraph proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_free_symbolic~~CalledByGraph proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_free_symbolic – MSOLV-fortran","loc":"proc/umfpack_free_symbolic.html","text":"public subroutine umfpack_free_symbolic(Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version Calls proc~~umfpack_free_symbolic~~CallsGraph proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_free_symbolic~~CalledByGraph proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_free_numeric – MSOLV-fortran","loc":"proc/umfpack_di_free_numeric.html","text":"public subroutine umfpack_di_free_numeric(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric Calls proc~~umfpack_di_free_numeric~~CallsGraph proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_free_numeric~~CalledByGraph proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~umfpack_di_free_numeric interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~freefact_solver freefact_solver proc~freefact_solver->proc~umfpack_di_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~close_solver proc~solve_syst->proc~freefact_solver proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_free_numeric – MSOLV-fortran","loc":"proc/umfpack_zi_free_numeric.html","text":"public subroutine umfpack_zi_free_numeric(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric Calls proc~~umfpack_zi_free_numeric~~CallsGraph proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_free_numeric~~CalledByGraph proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_free_numeric – MSOLV-fortran","loc":"proc/umfpack_free_numeric.html","text":"public subroutine umfpack_free_numeric(Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version Calls proc~~umfpack_free_numeric~~CallsGraph proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_free_numeric~~CalledByGraph proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_scale – MSOLV-fortran","loc":"proc/s_umfpack_di_scale.html","text":"public subroutine s_umfpack_di_scale(X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_di_scale~~CallsGraph proc~s_umfpack_di_scale s_umfpack_di_scale proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_scale~~CalledByGraph proc~s_umfpack_di_scale s_umfpack_di_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_scale – MSOLV-fortran","loc":"proc/s_umfpack_zi_scale.html","text":"public subroutine s_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_zi_scale~~CallsGraph proc~s_umfpack_zi_scale s_umfpack_zi_scale interface~umfpack_zi_scale umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_ci_scale – MSOLV-fortran","loc":"proc/s_umfpack_ci_scale.html","text":"public subroutine s_umfpack_ci_scale(Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_ci_scale~~CallsGraph proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_scale~~CalledByGraph proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_defaults – MSOLV-fortran","loc":"proc/umfpack_di_defaults.html","text":"public subroutine umfpack_di_defaults(Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_di_defaults~~CallsGraph proc~umfpack_di_defaults umfpack_di_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_defaults~~CalledByGraph proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver init_solver proc~init_solver->proc~umfpack_di_defaults interface~s_umfpack_di_defaults s_umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_defaults – MSOLV-fortran","loc":"proc/umfpack_zi_defaults.html","text":"public subroutine umfpack_zi_defaults(Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_zi_defaults~~CallsGraph proc~umfpack_zi_defaults umfpack_zi_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_defaults~~CalledByGraph proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~s_umfpack_zi_defaults s_umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_defaults – MSOLV-fortran","loc":"proc/umfpack_defaults.html","text":"public subroutine umfpack_defaults(Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version Calls proc~~umfpack_defaults~~CallsGraph proc~umfpack_defaults umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_defaults~~CalledByGraph proc~umfpack_defaults umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_report_control – MSOLV-fortran","loc":"proc/umfpack_di_report_control.html","text":"public subroutine umfpack_di_report_control(Control) Uses iso_fortran_env proc~~umfpack_di_report_control~~UsesGraph proc~umfpack_di_report_control umfpack_di_report_control iso_fortran_env iso_fortran_env proc~umfpack_di_report_control->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_di_report_control~~CallsGraph proc~umfpack_di_report_control umfpack_di_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_report_control~~CalledByGraph proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver init_solver proc~init_solver->proc~umfpack_di_report_control interface~s_umfpack_di_report_control s_umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~solve_syst solve_syst proc~solve_syst->proc~init_solver interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_report_control – MSOLV-fortran","loc":"proc/umfpack_zi_report_control.html","text":"public subroutine umfpack_zi_report_control(Control) Uses iso_fortran_env proc~~umfpack_zi_report_control~~UsesGraph proc~umfpack_zi_report_control umfpack_zi_report_control iso_fortran_env iso_fortran_env proc~umfpack_zi_report_control->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_zi_report_control~~CallsGraph proc~umfpack_zi_report_control umfpack_zi_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_report_control~~CalledByGraph proc~umfpack_zi_report_control umfpack_zi_report_control interface~s_umfpack_zi_report_control s_umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_report_control – MSOLV-fortran","loc":"proc/umfpack_report_control.html","text":"public subroutine umfpack_report_control(Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version Calls proc~~umfpack_report_control~~CallsGraph proc~umfpack_report_control umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_report_control~~CalledByGraph proc~umfpack_report_control umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_di_report_info – MSOLV-fortran","loc":"proc/umfpack_di_report_info.html","text":"public subroutine umfpack_di_report_info(Control, Info) Uses iso_fortran_env proc~~umfpack_di_report_info~~UsesGraph proc~umfpack_di_report_info umfpack_di_report_info iso_fortran_env iso_fortran_env proc~umfpack_di_report_info->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) Calls proc~~umfpack_di_report_info~~CallsGraph proc~umfpack_di_report_info umfpack_di_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_report_info~~CalledByGraph proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~s_umfpack_di_report_info s_umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info proc~close_solver close_solver proc~close_solver->proc~umfpack_di_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_zi_report_info – MSOLV-fortran","loc":"proc/umfpack_zi_report_info.html","text":"public subroutine umfpack_zi_report_info(Control, Info) Uses iso_fortran_env proc~~umfpack_zi_report_info~~UsesGraph proc~umfpack_zi_report_info umfpack_zi_report_info iso_fortran_env iso_fortran_env proc~umfpack_zi_report_info->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) Calls proc~~umfpack_zi_report_info~~CallsGraph proc~umfpack_zi_report_info umfpack_zi_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_report_info~~CalledByGraph proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~s_umfpack_zi_report_info s_umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umfpack_report_info – MSOLV-fortran","loc":"proc/umfpack_report_info.html","text":"public subroutine umfpack_report_info(Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version Calls proc~~umfpack_report_info~~CallsGraph proc~umfpack_report_info umfpack_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_report_info~~CalledByGraph proc~umfpack_report_info umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_save_numeric – MSOLV-fortran","loc":"proc/s_umfpack_di_save_numeric.html","text":"public subroutine s_umfpack_di_save_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_save_numeric~~CallsGraph proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_save_numeric – MSOLV-fortran","loc":"proc/s_umfpack_zi_save_numeric.html","text":"public subroutine s_umfpack_zi_save_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_save_numeric~~CallsGraph proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_save_numeric – MSOLV-fortran","loc":"proc/s_umfpack_save_numeric.html","text":"public subroutine s_umfpack_save_numeric(Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_save_numeric~~CallsGraph proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var panprocs_umfpack_save_numericCallsGraph = svgPanZoom('#procs_umfpack_save_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_save_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_di_save_symbolic.html","text":"public subroutine s_umfpack_di_save_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_save_symbolic~~CallsGraph proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_save_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_zi_save_symbolic.html","text":"public subroutine s_umfpack_zi_save_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_save_symbolic~~CallsGraph proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_save_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_save_symbolic.html","text":"public subroutine s_umfpack_save_symbolic(Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_save_symbolic~~CallsGraph proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic var panprocs_umfpack_save_symbolicCallsGraph = svgPanZoom('#procs_umfpack_save_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_load_numeric – MSOLV-fortran","loc":"proc/s_umfpack_di_load_numeric.html","text":"public subroutine s_umfpack_di_load_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_load_numeric~~CallsGraph proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_load_numeric – MSOLV-fortran","loc":"proc/s_umfpack_zi_load_numeric.html","text":"public subroutine s_umfpack_zi_load_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_load_numeric~~CallsGraph proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_load_numeric – MSOLV-fortran","loc":"proc/s_umfpack_load_numeric.html","text":"public subroutine s_umfpack_load_numeric(Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_load_numeric~~CallsGraph proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric var panprocs_umfpack_load_numericCallsGraph = svgPanZoom('#procs_umfpack_load_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_di_load_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_di_load_symbolic.html","text":"public subroutine s_umfpack_di_load_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_load_symbolic~~CallsGraph proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_zi_load_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_zi_load_symbolic.html","text":"public subroutine s_umfpack_zi_load_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_load_symbolic~~CallsGraph proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"s_umfpack_load_symbolic – MSOLV-fortran","loc":"proc/s_umfpack_load_symbolic.html","text":"public subroutine s_umfpack_load_symbolic(Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_load_symbolic~~CallsGraph proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic var panprocs_umfpack_load_symbolicCallsGraph = svgPanZoom('#procs_umfpack_load_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4def – MSOLV-fortran","loc":"proc/umf4def.html","text":"public subroutine umf4def(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4def~~CallsGraph proc~umf4def umf4def proc~umfpack_defaults umfpack_defaults proc~umf4def->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zdef – MSOLV-fortran","loc":"proc/umf4zdef.html","text":"public subroutine umf4zdef(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4zdef~~CallsGraph proc~umf4zdef umf4zdef proc~umfpack_defaults umfpack_defaults proc~umf4zdef->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cdef – MSOLV-fortran","loc":"proc/umf4cdef.html","text":"public subroutine umf4cdef(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4cdef~~CallsGraph proc~umf4cdef umf4cdef proc~umfpack_defaults umfpack_defaults proc~umf4cdef->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4pcon – MSOLV-fortran","loc":"proc/umf4pcon.html","text":"public subroutine umf4pcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4pcon~~CallsGraph proc~umf4pcon umf4pcon proc~umfpack_report_control umfpack_report_control proc~umf4pcon->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zpcon – MSOLV-fortran","loc":"proc/umf4zpcon.html","text":"public subroutine umf4zpcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4zpcon~~CallsGraph proc~umf4zpcon umf4zpcon proc~umfpack_report_control umfpack_report_control proc~umf4zpcon->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cpcon – MSOLV-fortran","loc":"proc/umf4cpcon.html","text":"public subroutine umf4cpcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4cpcon~~CallsGraph proc~umf4cpcon umf4cpcon proc~umfpack_report_control umfpack_report_control proc~umf4cpcon->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4sym – MSOLV-fortran","loc":"proc/umf4sym.html","text":"public subroutine umf4sym(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sym~~CallsGraph proc~umf4sym umf4sym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var panprocumf4symCallsGraph = svgPanZoom('#procumf4symCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsym – MSOLV-fortran","loc":"proc/umf4zsym.html","text":"public subroutine umf4zsym(m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsym~~CallsGraph proc~umf4zsym umf4zsym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var panprocumf4zsymCallsGraph = svgPanZoom('#procumf4zsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csym – MSOLV-fortran","loc":"proc/umf4csym.html","text":"public subroutine umf4csym(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csym~~CallsGraph proc~umf4csym umf4csym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var panprocumf4csymCallsGraph = svgPanZoom('#procumf4csymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4sym_ip – MSOLV-fortran","loc":"proc/umf4sym_ip.html","text":"public subroutine umf4sym_ip(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sym_ip~~CallsGraph proc~umf4sym_ip umf4sym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var panprocumf4sym_ipCallsGraph = svgPanZoom('#procumf4sym_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4sym_ip~~CalledByGraph proc~umf4sym_ip umf4sym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsym_ip – MSOLV-fortran","loc":"proc/umf4zsym_ip.html","text":"public subroutine umf4zsym_ip(m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsym_ip~~CallsGraph proc~umf4zsym_ip umf4zsym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var panprocumf4zsym_ipCallsGraph = svgPanZoom('#procumf4zsym_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsym_ip~~CalledByGraph proc~umf4zsym_ip umf4zsym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csym_ip – MSOLV-fortran","loc":"proc/umf4csym_ip.html","text":"public subroutine umf4csym_ip(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csym_ip~~CallsGraph proc~umf4csym_ip umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var panprocumf4csym_ipCallsGraph = svgPanZoom('#procumf4csym_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csym_ip~~CalledByGraph proc~umf4csym_ip umf4csym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4num – MSOLV-fortran","loc":"proc/umf4num.html","text":"public subroutine umf4num(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4num~~CallsGraph proc~umf4num umf4num interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4numCallsGraph = svgPanZoom('#procumf4numCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4znum – MSOLV-fortran","loc":"proc/umf4znum.html","text":"public subroutine umf4znum(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4znum~~CallsGraph proc~umf4znum umf4znum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4znumCallsGraph = svgPanZoom('#procumf4znumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cnum – MSOLV-fortran","loc":"proc/umf4cnum.html","text":"public subroutine umf4cnum(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cnum~~CallsGraph proc~umf4cnum umf4cnum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4cnumCallsGraph = svgPanZoom('#procumf4cnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4num_ip – MSOLV-fortran","loc":"proc/umf4num_ip.html","text":"public subroutine umf4num_ip(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4num_ip~~CallsGraph proc~umf4num_ip umf4num_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num_ip->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4num_ipCallsGraph = svgPanZoom('#procumf4num_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4num_ip~~CalledByGraph proc~umf4num_ip umf4num_ip interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4znum_ip – MSOLV-fortran","loc":"proc/umf4znum_ip.html","text":"public subroutine umf4znum_ip(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4znum_ip~~CallsGraph proc~umf4znum_ip umf4znum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4znum_ipCallsGraph = svgPanZoom('#procumf4znum_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4znum_ip~~CalledByGraph proc~umf4znum_ip umf4znum_ip interface~umf4num umf4num interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cnum_ip – MSOLV-fortran","loc":"proc/umf4cnum_ip.html","text":"public subroutine umf4cnum_ip(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cnum_ip~~CallsGraph proc~umf4cnum_ip umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4cnum_ipCallsGraph = svgPanZoom('#procumf4cnum_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cnum_ip~~CalledByGraph proc~umf4cnum_ip umf4cnum_ip interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4solr – MSOLV-fortran","loc":"proc/umf4solr.html","text":"public subroutine umf4solr(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4solr~~CallsGraph proc~umf4solr umf4solr interface~s_umfpack_solve s_umfpack_solve proc~umf4solr->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4solrCallsGraph = svgPanZoom('#procumf4solrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsolr – MSOLV-fortran","loc":"proc/umf4zsolr.html","text":"public subroutine umf4zsolr(sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsolr~~CallsGraph proc~umf4zsolr umf4zsolr interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsolrCallsGraph = svgPanZoom('#procumf4zsolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csolr – MSOLV-fortran","loc":"proc/umf4csolr.html","text":"public subroutine umf4csolr(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csolr~~CallsGraph proc~umf4csolr umf4csolr interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4csolrCallsGraph = svgPanZoom('#procumf4csolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4solr_ip – MSOLV-fortran","loc":"proc/umf4solr_ip.html","text":"public subroutine umf4solr_ip(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4solr_ip~~CallsGraph proc~umf4solr_ip umf4solr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4solr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4solr_ipCallsGraph = svgPanZoom('#procumf4solr_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4solr_ip~~CalledByGraph proc~umf4solr_ip umf4solr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsolr_ip – MSOLV-fortran","loc":"proc/umf4zsolr_ip.html","text":"public subroutine umf4zsolr_ip(sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsolr_ip~~CallsGraph proc~umf4zsolr_ip umf4zsolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsolr_ipCallsGraph = svgPanZoom('#procumf4zsolr_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsolr_ip~~CalledByGraph proc~umf4zsolr_ip umf4zsolr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csolr_ip – MSOLV-fortran","loc":"proc/umf4csolr_ip.html","text":"public subroutine umf4csolr_ip(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csolr_ip~~CallsGraph proc~umf4csolr_ip umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4csolr_ipCallsGraph = svgPanZoom('#procumf4csolr_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csolr_ip~~CalledByGraph proc~umf4csolr_ip umf4csolr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4sol – MSOLV-fortran","loc":"proc/umf4sol.html","text":"public subroutine umf4sol(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sol~~CallsGraph proc~umf4sol umf4sol interface~s_umfpack_solve s_umfpack_solve proc~umf4sol->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4solCallsGraph = svgPanZoom('#procumf4solCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsol – MSOLV-fortran","loc":"proc/umf4zsol.html","text":"public subroutine umf4zsol(sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsol~~CallsGraph proc~umf4zsol umf4zsol interface~s_umfpack_solve s_umfpack_solve proc~umf4zsol->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsolCallsGraph = svgPanZoom('#procumf4zsolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csol – MSOLV-fortran","loc":"proc/umf4csol.html","text":"public subroutine umf4csol(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csol~~CallsGraph proc~umf4csol umf4csol interface~s_umfpack_solve s_umfpack_solve proc~umf4csol->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4csolCallsGraph = svgPanZoom('#procumf4csolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4sol_ip – MSOLV-fortran","loc":"proc/umf4sol_ip.html","text":"public subroutine umf4sol_ip(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sol_ip~~CallsGraph proc~umf4sol_ip umf4sol_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4sol_ipCallsGraph = svgPanZoom('#procumf4sol_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4sol_ip~~CalledByGraph proc~umf4sol_ip umf4sol_ip interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsol_ip – MSOLV-fortran","loc":"proc/umf4zsol_ip.html","text":"public subroutine umf4zsol_ip(sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsol_ip~~CallsGraph proc~umf4zsol_ip umf4zsol_ip interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsol_ipCallsGraph = svgPanZoom('#procumf4zsol_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsol_ip~~CalledByGraph proc~umf4zsol_ip umf4zsol_ip interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->proc~umf4zsol_ip interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csol_ip – MSOLV-fortran","loc":"proc/umf4csol_ip.html","text":"public subroutine umf4csol_ip(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csol_ip~~CallsGraph proc~umf4csol_ip umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csol_ip~~CalledByGraph proc~umf4csol_ip umf4csol_ip interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->interface~umf4sol interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4scal – MSOLV-fortran","loc":"proc/umf4scal.html","text":"public subroutine umf4scal(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4scal~~CallsGraph proc~umf4scal umf4scal interface~umfpack_scale_function umfpack_scale_function proc~umf4scal->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var panprocumf4scalCallsGraph = svgPanZoom('#procumf4scalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zscal – MSOLV-fortran","loc":"proc/umf4zscal.html","text":"public subroutine umf4zscal(x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4zscal~~CallsGraph proc~umf4zscal umf4zscal interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var panprocumf4zscalCallsGraph = svgPanZoom('#procumf4zscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cscal – MSOLV-fortran","loc":"proc/umf4cscal.html","text":"public subroutine umf4cscal(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4cscal~~CallsGraph proc~umf4cscal umf4cscal interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var panprocumf4cscalCallsGraph = svgPanZoom('#procumf4cscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4scal_ip – MSOLV-fortran","loc":"proc/umf4scal_ip.html","text":"public subroutine umf4scal_ip(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4scal_ip~~CallsGraph proc~umf4scal_ip umf4scal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4scal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var panprocumf4scal_ipCallsGraph = svgPanZoom('#procumf4scal_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4scal_ip~~CalledByGraph proc~umf4scal_ip umf4scal_ip interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zscal_ip – MSOLV-fortran","loc":"proc/umf4zscal_ip.html","text":"public subroutine umf4zscal_ip(x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4zscal_ip~~CallsGraph proc~umf4zscal_ip umf4zscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var panprocumf4zscal_ipCallsGraph = svgPanZoom('#procumf4zscal_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zscal_ip~~CalledByGraph proc~umf4zscal_ip umf4zscal_ip interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cscal_ip – MSOLV-fortran","loc":"proc/umf4cscal_ip.html","text":"public subroutine umf4cscal_ip(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4cscal_ip~~CallsGraph proc~umf4cscal_ip umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var panprocumf4cscal_ipCallsGraph = svgPanZoom('#procumf4cscal_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cscal_ip~~CalledByGraph proc~umf4cscal_ip umf4cscal_ip interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4pinf – MSOLV-fortran","loc":"proc/umf4pinf.html","text":"public subroutine umf4pinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4pinf~~CallsGraph proc~umf4pinf umf4pinf proc~umfpack_report_info umfpack_report_info proc~umf4pinf->proc~umfpack_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zpinf – MSOLV-fortran","loc":"proc/umf4zpinf.html","text":"public subroutine umf4zpinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zpinf~~CallsGraph proc~umf4zpinf umf4zpinf proc~umfpack_report_info umfpack_report_info proc~umf4zpinf->proc~umfpack_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cpinf – MSOLV-fortran","loc":"proc/umf4cpinf.html","text":"public subroutine umf4cpinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cpinf~~CallsGraph proc~umf4cpinf umf4cpinf proc~umfpack_report_info umfpack_report_info proc~umf4cpinf->proc~umfpack_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4fnum – MSOLV-fortran","loc":"proc/umf4fnum.html","text":"public subroutine umf4fnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4fnum~~CallsGraph proc~umf4fnum umf4fnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zfnum – MSOLV-fortran","loc":"proc/umf4zfnum.html","text":"public subroutine umf4zfnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4zfnum~~CallsGraph proc~umf4zfnum umf4zfnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cfnum – MSOLV-fortran","loc":"proc/umf4cfnum.html","text":"public subroutine umf4cfnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4cfnum~~CallsGraph proc~umf4cfnum umf4cfnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4fnum_ip – MSOLV-fortran","loc":"proc/umf4fnum_ip.html","text":"public subroutine umf4fnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4fnum_ip~~CallsGraph proc~umf4fnum_ip umf4fnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4fnum_ip~~CalledByGraph proc~umf4fnum_ip umf4fnum_ip interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zfnum_ip – MSOLV-fortran","loc":"proc/umf4zfnum_ip.html","text":"public subroutine umf4zfnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4zfnum_ip~~CallsGraph proc~umf4zfnum_ip umf4zfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zfnum_ip~~CalledByGraph proc~umf4zfnum_ip umf4zfnum_ip interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cfnum_ip – MSOLV-fortran","loc":"proc/umf4cfnum_ip.html","text":"public subroutine umf4cfnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4cfnum_ip~~CallsGraph proc~umf4cfnum_ip umf4cfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cfnum_ip~~CalledByGraph proc~umf4cfnum_ip umf4cfnum_ip interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4fsym – MSOLV-fortran","loc":"proc/umf4fsym.html","text":"public subroutine umf4fsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4fsym~~CallsGraph proc~umf4fsym umf4fsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zfsym – MSOLV-fortran","loc":"proc/umf4zfsym.html","text":"public subroutine umf4zfsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4zfsym~~CallsGraph proc~umf4zfsym umf4zfsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cfsym – MSOLV-fortran","loc":"proc/umf4cfsym.html","text":"public subroutine umf4cfsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4cfsym~~CallsGraph proc~umf4cfsym umf4cfsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4fsym_ip – MSOLV-fortran","loc":"proc/umf4fsym_ip.html","text":"public subroutine umf4fsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4fsym_ip~~CallsGraph proc~umf4fsym_ip umf4fsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4fsym_ip~~CalledByGraph proc~umf4fsym_ip umf4fsym_ip interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zfsym_ip – MSOLV-fortran","loc":"proc/umf4zfsym_ip.html","text":"public subroutine umf4zfsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4zfsym_ip~~CallsGraph proc~umf4zfsym_ip umf4zfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zfsym_ip~~CalledByGraph proc~umf4zfsym_ip umf4zfsym_ip interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cfsym_ip – MSOLV-fortran","loc":"proc/umf4cfsym_ip.html","text":"public subroutine umf4cfsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4cfsym_ip~~CallsGraph proc~umf4cfsym_ip umf4cfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cfsym_ip~~CalledByGraph proc~umf4cfsym_ip umf4cfsym_ip interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4snum – MSOLV-fortran","loc":"proc/umf4snum.html","text":"public subroutine umf4snum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4snum~~CallsGraph proc~umf4snum umf4snum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsnum – MSOLV-fortran","loc":"proc/umf4zsnum.html","text":"public subroutine umf4zsnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zsnum~~CallsGraph proc~umf4zsnum umf4zsnum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csnum – MSOLV-fortran","loc":"proc/umf4csnum.html","text":"public subroutine umf4csnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4csnum~~CallsGraph proc~umf4csnum umf4csnum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4snum_ip – MSOLV-fortran","loc":"proc/umf4snum_ip.html","text":"public subroutine umf4snum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4snum_ip~~CallsGraph proc~umf4snum_ip umf4snum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4snum_ip~~CalledByGraph proc~umf4snum_ip umf4snum_ip interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zsnum_ip – MSOLV-fortran","loc":"proc/umf4zsnum_ip.html","text":"public subroutine umf4zsnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zsnum_ip~~CallsGraph proc~umf4zsnum_ip umf4zsnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsnum_ip~~CalledByGraph proc~umf4zsnum_ip umf4zsnum_ip interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4csnum_ip – MSOLV-fortran","loc":"proc/umf4csnum_ip.html","text":"public subroutine umf4csnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4csnum_ip~~CallsGraph proc~umf4csnum_ip umf4csnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csnum_ip~~CalledByGraph proc~umf4csnum_ip umf4csnum_ip interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4ssym – MSOLV-fortran","loc":"proc/umf4ssym.html","text":"public subroutine umf4ssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4ssym~~CallsGraph proc~umf4ssym umf4ssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zssym – MSOLV-fortran","loc":"proc/umf4zssym.html","text":"public subroutine umf4zssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zssym~~CallsGraph proc~umf4zssym umf4zssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cssym – MSOLV-fortran","loc":"proc/umf4cssym.html","text":"public subroutine umf4cssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4cssym~~CallsGraph proc~umf4cssym umf4cssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4ssym_ip – MSOLV-fortran","loc":"proc/umf4ssym_ip.html","text":"public subroutine umf4ssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4ssym_ip~~CallsGraph proc~umf4ssym_ip umf4ssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4ssym_ip~~CalledByGraph proc~umf4ssym_ip umf4ssym_ip interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zssym_ip – MSOLV-fortran","loc":"proc/umf4zssym_ip.html","text":"public subroutine umf4zssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zssym_ip~~CallsGraph proc~umf4zssym_ip umf4zssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zssym_ip~~CalledByGraph proc~umf4zssym_ip umf4zssym_ip interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4cssym_ip – MSOLV-fortran","loc":"proc/umf4cssym_ip.html","text":"public subroutine umf4cssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4cssym_ip~~CallsGraph proc~umf4cssym_ip umf4cssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cssym_ip~~CalledByGraph proc~umf4cssym_ip umf4cssym_ip interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4lnum – MSOLV-fortran","loc":"proc/umf4lnum.html","text":"public subroutine umf4lnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lnum~~CallsGraph proc~umf4lnum umf4lnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zlnum – MSOLV-fortran","loc":"proc/umf4zlnum.html","text":"public subroutine umf4zlnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlnum~~CallsGraph proc~umf4zlnum umf4zlnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4clnum – MSOLV-fortran","loc":"proc/umf4clnum.html","text":"public subroutine umf4clnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clnum~~CallsGraph proc~umf4clnum umf4clnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4lnum_ip – MSOLV-fortran","loc":"proc/umf4lnum_ip.html","text":"public subroutine umf4lnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lnum_ip~~CallsGraph proc~umf4lnum_ip umf4lnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4lnum_ip~~CalledByGraph proc~umf4lnum_ip umf4lnum_ip interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zlnum_ip – MSOLV-fortran","loc":"proc/umf4zlnum_ip.html","text":"public subroutine umf4zlnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlnum_ip~~CallsGraph proc~umf4zlnum_ip umf4zlnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zlnum_ip~~CalledByGraph proc~umf4zlnum_ip umf4zlnum_ip interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4clnum_ip – MSOLV-fortran","loc":"proc/umf4clnum_ip.html","text":"public subroutine umf4clnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clnum_ip~~CallsGraph proc~umf4clnum_ip umf4clnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4clnum_ip~~CalledByGraph proc~umf4clnum_ip umf4clnum_ip interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4lsym – MSOLV-fortran","loc":"proc/umf4lsym.html","text":"public subroutine umf4lsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lsym~~CallsGraph proc~umf4lsym umf4lsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zlsym – MSOLV-fortran","loc":"proc/umf4zlsym.html","text":"public subroutine umf4zlsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlsym~~CallsGraph proc~umf4zlsym umf4zlsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4clsym – MSOLV-fortran","loc":"proc/umf4clsym.html","text":"public subroutine umf4clsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clsym~~CallsGraph proc~umf4clsym umf4clsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4lsym_ip – MSOLV-fortran","loc":"proc/umf4lsym_ip.html","text":"public subroutine umf4lsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lsym_ip~~CallsGraph proc~umf4lsym_ip umf4lsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4lsym_ip~~CalledByGraph proc~umf4lsym_ip umf4lsym_ip interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4zlsym_ip – MSOLV-fortran","loc":"proc/umf4zlsym_ip.html","text":"public subroutine umf4zlsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlsym_ip~~CallsGraph proc~umf4zlsym_ip umf4zlsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zlsym_ip~~CalledByGraph proc~umf4zlsym_ip umf4zlsym_ip interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"umf4clsym_ip – MSOLV-fortran","loc":"proc/umf4clsym_ip.html","text":"public subroutine umf4clsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clsym_ip~~CallsGraph proc~umf4clsym_ip umf4clsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4clsym_ip~~CalledByGraph proc~umf4clsym_ip umf4clsym_ip interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":""},{"title":"c_umfpack_di_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_di_symbolic.html","text":"interface Called by interface~~c_umfpack_di_symbolic~~CalledByGraph interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym var paninterfacec_umfpack_di_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) bind(c,name='umfpack_di_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_zi_symbolic.html","text":"interface Called by interface~~c_umfpack_zi_symbolic~~CalledByGraph interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic proc~umfpack_zi_symbolic umfpack_zi_symbolic proc~umfpack_zi_symbolic->interface~c_umfpack_zi_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym var paninterfacec_umfpack_zi_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) bind(c,name='umfpack_zi_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_numeric – MSOLV-fortran","loc":"interface/c_umfpack_di_numeric.html","text":"interface Called by interface~~c_umfpack_di_numeric~~CalledByGraph interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum var paninterfacec_umfpack_di_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_di_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_numeric – MSOLV-fortran","loc":"interface/c_umfpack_zi_numeric.html","text":"interface Called by interface~~c_umfpack_zi_numeric~~CalledByGraph interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_zi_numeric umfpack_zi_numeric proc~umfpack_zi_numeric->interface~c_umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum var paninterfacec_umfpack_zi_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_zi_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_solve – MSOLV-fortran","loc":"interface/c_umfpack_di_solve.html","text":"interface Called by interface~~c_umfpack_di_solve~~CalledByGraph interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_di_solve proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr var paninterfacec_umfpack_di_solveCalledByGraph = svgPanZoom('#interfacec_umfpack_di_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) bind(c,name='umfpack_di_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_solve – MSOLV-fortran","loc":"interface/c_umfpack_zi_solve.html","text":"interface Called by interface~~c_umfpack_zi_solve~~CalledByGraph interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_zi_solve umfpack_zi_solve proc~umfpack_zi_solve->interface~c_umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_ci_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr var paninterfacec_umfpack_zi_solveCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) bind(c,name='umfpack_zi_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_scale – MSOLV-fortran","loc":"interface/c_umfpack_di_scale.html","text":"interface Called by interface~~c_umfpack_di_scale~~CalledByGraph interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale proc~s_umfpack_di_scale s_umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_di_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal var paninterfacec_umfpack_di_scaleCalledByGraph = svgPanZoom('#interfacec_umfpack_di_scaleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_scale(X, B, Numeric) bind(c,name='umfpack_di_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_scale – MSOLV-fortran","loc":"interface/c_umfpack_zi_scale.html","text":"interface Called by interface~~c_umfpack_zi_scale~~CalledByGraph interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale proc~umfpack_zi_scale umfpack_zi_scale proc~umfpack_zi_scale->interface~c_umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal var paninterfacec_umfpack_zi_scaleCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_scaleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) bind(c,name='umfpack_zi_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_save_numeric – MSOLV-fortran","loc":"interface/c_umfpack_di_save_numeric.html","text":"interface Called by interface~~c_umfpack_di_save_numeric~~CalledByGraph interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum var paninterfacec_umfpack_di_save_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_save_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_save_numeric(Numeric, filename) bind(c,name='umfpack_di_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_save_numeric – MSOLV-fortran","loc":"interface/c_umfpack_zi_save_numeric.html","text":"interface Called by interface~~c_umfpack_zi_save_numeric~~CalledByGraph interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum var paninterfacec_umfpack_zi_save_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_save_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_save_numeric(Numeric, filename) bind(c,name='umfpack_zi_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_save_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_di_save_symbolic.html","text":"interface Called by interface~~c_umfpack_di_save_symbolic~~CalledByGraph interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym var paninterfacec_umfpack_di_save_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_save_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_save_symbolic(Symbolic, filename) bind(c,name='umfpack_di_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_save_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_zi_save_symbolic.html","text":"interface Called by interface~~c_umfpack_zi_save_symbolic~~CalledByGraph interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym var paninterfacec_umfpack_zi_save_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_save_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_save_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_load_numeric – MSOLV-fortran","loc":"interface/c_umfpack_di_load_numeric.html","text":"interface Called by interface~~c_umfpack_di_load_numeric~~CalledByGraph interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum var paninterfacec_umfpack_di_load_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_load_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_load_numeric(Numeric, filename) bind(c,name='umfpack_di_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_load_numeric – MSOLV-fortran","loc":"interface/c_umfpack_zi_load_numeric.html","text":"interface Called by interface~~c_umfpack_zi_load_numeric~~CalledByGraph interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum var paninterfacec_umfpack_zi_load_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_load_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_load_numeric(Numeric, filename) bind(c,name='umfpack_zi_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_load_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_di_load_symbolic.html","text":"interface Called by interface~~c_umfpack_di_load_symbolic~~CalledByGraph interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym var paninterfacec_umfpack_di_load_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_load_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_load_symbolic(Symbolic, filename) bind(c,name='umfpack_di_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_load_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_zi_load_symbolic.html","text":"interface Called by interface~~c_umfpack_zi_load_symbolic~~CalledByGraph interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym var paninterfacec_umfpack_zi_load_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_load_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_load_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_report_numeric – MSOLV-fortran","loc":"interface/c_umfpack_di_report_numeric.html","text":"interface public function c_umfpack_di_report_numeric(Numeric, Control) bind(c,name='umfpack_di_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_report_numeric – MSOLV-fortran","loc":"interface/c_umfpack_zi_report_numeric.html","text":"interface public function c_umfpack_zi_report_numeric(Numeric, Control) bind(c,name='umfpack_zi_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_report_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_di_report_symbolic.html","text":"interface public function c_umfpack_di_report_symbolic(Symbolic, Control) bind(c,name='umfpack_di_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_zi_report_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_zi_report_symbolic.html","text":"interface public function c_umfpack_zi_report_symbolic(Symbolic, Control) bind(c,name='umfpack_zi_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":""},{"title":"c_umfpack_di_free_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_di_free_symbolic.html","text":"interface Called by interface~~c_umfpack_di_free_symbolic~~CalledByGraph interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym var paninterfacec_umfpack_di_free_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_free_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic","tags":""},{"title":"c_umfpack_zi_free_symbolic – MSOLV-fortran","loc":"interface/c_umfpack_zi_free_symbolic.html","text":"interface Called by interface~~c_umfpack_zi_free_symbolic~~CalledByGraph interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym var paninterfacec_umfpack_zi_free_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_free_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic","tags":""},{"title":"c_umfpack_di_free_numeric – MSOLV-fortran","loc":"interface/c_umfpack_di_free_numeric.html","text":"interface Called by interface~~c_umfpack_di_free_numeric~~CalledByGraph interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~umfpack_di_free_numeric interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~freefact_solver freefact_solver proc~freefact_solver->proc~umfpack_di_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~close_solver proc~solve_syst->proc~freefact_solver proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric program~test_solvers test_solvers program~test_solvers->proc~solve_syst interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum var paninterfacec_umfpack_di_free_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_free_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric","tags":""},{"title":"c_umfpack_zi_free_numeric – MSOLV-fortran","loc":"interface/c_umfpack_zi_free_numeric.html","text":"interface Called by interface~~c_umfpack_zi_free_numeric~~CalledByGraph interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum var paninterfacec_umfpack_zi_free_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_free_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric","tags":""},{"title":"c_umfpack_di_defaults – MSOLV-fortran","loc":"interface/c_umfpack_di_defaults.html","text":"interface Called by interface~~c_umfpack_di_defaults~~CalledByGraph interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~init_solver init_solver proc~init_solver->proc~umfpack_di_defaults interface~s_umfpack_di_defaults s_umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults program~test_solvers test_solvers program~test_solvers->proc~solve_syst var paninterfacec_umfpack_di_defaultsCalledByGraph = svgPanZoom('#interfacec_umfpack_di_defaultsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":""},{"title":"c_umfpack_zi_defaults – MSOLV-fortran","loc":"interface/c_umfpack_zi_defaults.html","text":"interface Called by interface~~c_umfpack_zi_defaults~~CalledByGraph interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~s_umfpack_zi_defaults s_umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":""},{"title":"c_umfpack_di_report_status – MSOLV-fortran","loc":"interface/c_umfpack_di_report_status.html","text":"interface public subroutine c_umfpack_di_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status","tags":""},{"title":"c_umfpack_zi_report_status – MSOLV-fortran","loc":"interface/c_umfpack_zi_report_status.html","text":"interface public subroutine c_umfpack_zi_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status","tags":""},{"title":"c_umfpack_di_report_control – MSOLV-fortran","loc":"interface/c_umfpack_di_report_control.html","text":"interface Called by interface~~c_umfpack_di_report_control~~CalledByGraph interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control proc~init_solver init_solver proc~init_solver->proc~umfpack_di_report_control interface~s_umfpack_di_report_control s_umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~solve_syst solve_syst proc~solve_syst->proc~init_solver interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control program~test_solvers test_solvers program~test_solvers->proc~solve_syst var paninterfacec_umfpack_di_report_controlCalledByGraph = svgPanZoom('#interfacec_umfpack_di_report_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":""},{"title":"c_umfpack_zi_report_control – MSOLV-fortran","loc":"interface/c_umfpack_zi_report_control.html","text":"interface Called by interface~~c_umfpack_zi_report_control~~CalledByGraph interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~s_umfpack_zi_report_control s_umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control var paninterfacec_umfpack_zi_report_controlCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_report_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":""},{"title":"c_umfpack_di_report_info – MSOLV-fortran","loc":"interface/c_umfpack_di_report_info.html","text":"interface Called by interface~~c_umfpack_di_report_info~~CalledByGraph interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~s_umfpack_di_report_info s_umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info proc~close_solver close_solver proc~close_solver->proc~umfpack_di_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info program~test_solvers test_solvers program~test_solvers->proc~solve_syst var paninterfacec_umfpack_di_report_infoCalledByGraph = svgPanZoom('#interfacec_umfpack_di_report_infoCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info","tags":""},{"title":"c_umfpack_zi_report_info – MSOLV-fortran","loc":"interface/c_umfpack_zi_report_info.html","text":"interface Called by interface~~c_umfpack_zi_report_info~~CalledByGraph interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~s_umfpack_zi_report_info s_umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info","tags":""},{"title":"umfpack_zi_symbolic – MSOLV-fortran","loc":"interface/umfpack_zi_symbolic.html","text":"public interface umfpack_zi_symbolic Calls interface~~umfpack_zi_symbolic~~CallsGraph interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_symbolic~~CalledByGraph interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_symbolic umfpack_ci_symbolic Module Procedures public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":""},{"title":"s_umfpack_zi_symbolic – MSOLV-fortran","loc":"interface/s_umfpack_zi_symbolic.html","text":"public interface s_umfpack_zi_symbolic Calls interface~~s_umfpack_zi_symbolic~~CallsGraph interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_symbolic~~CalledByGraph interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_symbolic s_umfpack_ci_symbolic Module Procedures public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":""},{"title":"umfpack_symbolic – MSOLV-fortran","loc":"interface/umfpack_symbolic.html","text":"public interface umfpack_symbolic Calls interface~~umfpack_symbolic~~CallsGraph interface~umfpack_symbolic umfpack_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_symbolic umfpack_zi_symbolic umfpack_ci_symbolic Module Procedures public function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":""},{"title":"s_umfpack_symbolic – MSOLV-fortran","loc":"interface/s_umfpack_symbolic.html","text":"public interface s_umfpack_symbolic Calls interface~~s_umfpack_symbolic~~CallsGraph interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var paninterfaces_umfpack_symbolicCallsGraph = svgPanZoom('#interfaces_umfpack_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_symbolic~~CalledByGraph interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_symbolic s_umfpack_zi_symbolic s_umfpack_ci_symbolic Module Procedures public subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":""},{"title":"umfpack_zi_numeric – MSOLV-fortran","loc":"interface/umfpack_zi_numeric.html","text":"public interface umfpack_zi_numeric Calls interface~~umfpack_zi_numeric~~CallsGraph interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_numeric~~CalledByGraph interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_numeric umfpack_ci_numeric Module Procedures public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":""},{"title":"s_umfpack_zi_numeric – MSOLV-fortran","loc":"interface/s_umfpack_zi_numeric.html","text":"public interface s_umfpack_zi_numeric Calls interface~~s_umfpack_zi_numeric~~CallsGraph interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_numeric~~CalledByGraph interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_numeric s_umfpack_ci_numeric Module Procedures public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":""},{"title":"umfpack_numeric – MSOLV-fortran","loc":"interface/umfpack_numeric.html","text":"public interface umfpack_numeric Calls interface~~umfpack_numeric~~CallsGraph interface~umfpack_numeric umfpack_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric proc~umfpack_di_numeric umfpack_di_numeric interface~umfpack_numeric->proc~umfpack_di_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_numeric umfpack_zi_numeric umfpack_ci_numeric Module Procedures public function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":""},{"title":"s_umfpack_numeric – MSOLV-fortran","loc":"interface/s_umfpack_numeric.html","text":"public interface s_umfpack_numeric Calls interface~~s_umfpack_numeric~~CallsGraph interface~s_umfpack_numeric s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaces_umfpack_numericCallsGraph = svgPanZoom('#interfaces_umfpack_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_numeric~~CalledByGraph interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_numeric s_umfpack_zi_numeric s_umfpack_ci_numeric Module Procedures public subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":""},{"title":"umfpack_zi_solve – MSOLV-fortran","loc":"interface/umfpack_zi_solve.html","text":"public interface umfpack_zi_solve Calls interface~~umfpack_zi_solve~~CallsGraph interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_solve~~CalledByGraph interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~s_umfpack_zi_solve s_umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->interface~umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_solve umfpack_ci_solve Module Procedures public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":""},{"title":"s_umfpack_zi_solve – MSOLV-fortran","loc":"interface/s_umfpack_zi_solve.html","text":"public interface s_umfpack_zi_solve Calls interface~~s_umfpack_zi_solve~~CallsGraph interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_solve~~CalledByGraph interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umf4zsol_ip umf4zsol_ip proc~umf4zsol_ip->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4zsol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_solve s_umfpack_ci_solve Module Procedures public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":""},{"title":"umfpack_solve – MSOLV-fortran","loc":"interface/umfpack_solve.html","text":"public interface umfpack_solve Calls interface~~umfpack_solve~~CallsGraph interface~umfpack_solve umfpack_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_solve->interface~umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve interface~umfpack_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_solve umfpack_zi_solve umfpack_ci_solve Module Procedures public function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":""},{"title":"s_umfpack_solve – MSOLV-fortran","loc":"interface/s_umfpack_solve.html","text":"public interface s_umfpack_solve Calls interface~~s_umfpack_solve~~CallsGraph interface~s_umfpack_solve s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaces_umfpack_solveCallsGraph = svgPanZoom('#interfaces_umfpack_solveCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_solve~~CalledByGraph interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_solve s_umfpack_zi_solve s_umfpack_ci_solve Module Procedures public subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":""},{"title":"s_umfpack_free_symbolic – MSOLV-fortran","loc":"interface/s_umfpack_free_symbolic.html","text":"public interface s_umfpack_free_symbolic Calls interface~~s_umfpack_free_symbolic~~CallsGraph interface~s_umfpack_free_symbolic s_umfpack_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaces_umfpack_free_symbolicCallsGraph = svgPanZoom('#interfaces_umfpack_free_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_free_symbolic Module Procedures public subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version","tags":""},{"title":"s_umfpack_di_free_symbolic – MSOLV-fortran","loc":"interface/s_umfpack_di_free_symbolic.html","text":"public interface s_umfpack_di_free_symbolic Calls interface~~s_umfpack_di_free_symbolic~~CallsGraph interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_free_symbolic Module Procedures public subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic","tags":""},{"title":"s_umfpack_zi_free_symbolic – MSOLV-fortran","loc":"interface/s_umfpack_zi_free_symbolic.html","text":"public interface s_umfpack_zi_free_symbolic Calls interface~~s_umfpack_zi_free_symbolic~~CallsGraph interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_free_symbolic Module Procedures public subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic","tags":""},{"title":"s_umfpack_free_numeric – MSOLV-fortran","loc":"interface/s_umfpack_free_numeric.html","text":"public interface s_umfpack_free_numeric Calls interface~~s_umfpack_free_numeric~~CallsGraph interface~s_umfpack_free_numeric s_umfpack_free_numeric proc~umfpack_free_numeric umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaces_umfpack_free_numericCallsGraph = svgPanZoom('#interfaces_umfpack_free_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_free_numeric Module Procedures public subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version","tags":""},{"title":"s_umfpack_di_free_numeric – MSOLV-fortran","loc":"interface/s_umfpack_di_free_numeric.html","text":"public interface s_umfpack_di_free_numeric Calls interface~~s_umfpack_di_free_numeric~~CallsGraph interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_free_numeric Module Procedures public subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric","tags":""},{"title":"s_umfpack_zi_free_numeric – MSOLV-fortran","loc":"interface/s_umfpack_zi_free_numeric.html","text":"public interface s_umfpack_zi_free_numeric Calls interface~~s_umfpack_zi_free_numeric~~CallsGraph interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_free_numeric Module Procedures public subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric","tags":""},{"title":"s_umfpack_defaults – MSOLV-fortran","loc":"interface/s_umfpack_defaults.html","text":"public interface s_umfpack_defaults Calls interface~~s_umfpack_defaults~~CallsGraph interface~s_umfpack_defaults s_umfpack_defaults proc~umfpack_defaults umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_defaults Module Procedures public subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version","tags":""},{"title":"s_umfpack_di_defaults – MSOLV-fortran","loc":"interface/s_umfpack_di_defaults.html","text":"public interface s_umfpack_di_defaults Calls interface~~s_umfpack_di_defaults~~CallsGraph interface~s_umfpack_di_defaults s_umfpack_di_defaults proc~umfpack_di_defaults umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_defaults Module Procedures public subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","tags":""},{"title":"s_umfpack_zi_defaults – MSOLV-fortran","loc":"interface/s_umfpack_zi_defaults.html","text":"public interface s_umfpack_zi_defaults Calls interface~~s_umfpack_zi_defaults~~CallsGraph interface~s_umfpack_zi_defaults s_umfpack_zi_defaults proc~umfpack_zi_defaults umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_defaults Module Procedures public subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","tags":""},{"title":"umfpack_zi_scale – MSOLV-fortran","loc":"interface/umfpack_zi_scale.html","text":"public interface umfpack_zi_scale Calls interface~~umfpack_zi_scale~~CallsGraph interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_scale~~CalledByGraph interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~s_umfpack_zi_scale s_umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_scale umfpack_ci_scale Module Procedures public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer","tags":""},{"title":"umfpack_scale_function – MSOLV-fortran","loc":"interface/umfpack_scale_function.html","text":"public interface umfpack_scale_function Calls interface~~umfpack_scale_function~~CallsGraph interface~umfpack_scale_function umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_scale_function~~CalledByGraph interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_scale umfpack_zi_scale umfpack_ci_scale Module Procedures public function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer","tags":""},{"title":"s_umfpack_zi_scale – MSOLV-fortran","loc":"interface/s_umfpack_zi_scale.html","text":"public interface s_umfpack_zi_scale Calls interface~~s_umfpack_zi_scale~~CallsGraph interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_scale~~CalledByGraph interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_scale s_umfpack_ci_scale Module Procedures public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status","tags":""},{"title":"s_umfpack_scale – MSOLV-fortran","loc":"interface/s_umfpack_scale.html","text":"public interface s_umfpack_scale Calls interface~~s_umfpack_scale~~CallsGraph interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale proc~s_umfpack_di_scale s_umfpack_di_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var paninterfaces_umfpack_scaleCallsGraph = svgPanZoom('#interfaces_umfpack_scaleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_scale s_umfpack_zi_scale s_umfpack_ci_scale Module Procedures public subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status","tags":""},{"title":"s_umfpack_report_control – MSOLV-fortran","loc":"interface/s_umfpack_report_control.html","text":"public interface s_umfpack_report_control Calls interface~~s_umfpack_report_control~~CallsGraph interface~s_umfpack_report_control s_umfpack_report_control proc~umfpack_report_control umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control var paninterfaces_umfpack_report_controlCallsGraph = svgPanZoom('#interfaces_umfpack_report_controlCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_report_control Module Procedures public subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version","tags":""},{"title":"s_umfpack_di_report_control – MSOLV-fortran","loc":"interface/s_umfpack_di_report_control.html","text":"public interface s_umfpack_di_report_control Calls interface~~s_umfpack_di_report_control~~CallsGraph interface~s_umfpack_di_report_control s_umfpack_di_report_control proc~umfpack_di_report_control umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_report_control Module Procedures public subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","tags":""},{"title":"s_umfpack_zi_report_control – MSOLV-fortran","loc":"interface/s_umfpack_zi_report_control.html","text":"public interface s_umfpack_zi_report_control Calls interface~~s_umfpack_zi_report_control~~CallsGraph interface~s_umfpack_zi_report_control s_umfpack_zi_report_control proc~umfpack_zi_report_control umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_report_control Module Procedures public subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","tags":""},{"title":"s_umfpack_report_info – MSOLV-fortran","loc":"interface/s_umfpack_report_info.html","text":"public interface s_umfpack_report_info Calls interface~~s_umfpack_report_info~~CallsGraph interface~s_umfpack_report_info s_umfpack_report_info proc~umfpack_report_info umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_report_info Module Procedures public subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version","tags":""},{"title":"s_umfpack_di_report_info – MSOLV-fortran","loc":"interface/s_umfpack_di_report_info.html","text":"public interface s_umfpack_di_report_info Calls interface~~s_umfpack_di_report_info~~CallsGraph interface~s_umfpack_di_report_info s_umfpack_di_report_info proc~umfpack_di_report_info umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_report_info Module Procedures public subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"s_umfpack_zi_report_info – MSOLV-fortran","loc":"interface/s_umfpack_zi_report_info.html","text":"public interface s_umfpack_zi_report_info Calls interface~~s_umfpack_zi_report_info~~CallsGraph interface~s_umfpack_zi_report_info s_umfpack_zi_report_info proc~umfpack_zi_report_info umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_report_info Module Procedures public subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4csym – MSOLV-fortran","loc":"interface/umf4csym.html","text":"public interface umf4csym Calls interface~~umf4csym~~CallsGraph interface~umf4csym umf4csym interface~umf4csym->interface~umf4csym proc~umf4csym_ip umf4csym_ip interface~umf4csym->proc~umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var paninterfaceumf4csymCallsGraph = svgPanZoom('#interfaceumf4csymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4csym~~CalledByGraph interface~umf4csym umf4csym interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csym umf4csym_ip Module Procedures public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4zsym – MSOLV-fortran","loc":"interface/umf4zsym.html","text":"public interface umf4zsym Calls interface~~umf4zsym~~CallsGraph interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4zsym proc~umf4zsym_ip umf4zsym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4csym umf4csym interface~umf4zsym->interface~umf4csym proc~umf4csym_ip umf4csym_ip interface~umf4zsym->proc~umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4csym->interface~umf4csym interface~umf4csym->proc~umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var paninterfaceumf4zsymCallsGraph = svgPanZoom('#interfaceumf4zsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zsym~~CalledByGraph interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4zsym interface~umf4sym umf4sym interface~umf4sym->interface~umf4zsym interface~umf4sym->interface~umf4sym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsym umf4zsym_ip umf4csym umf4csym_ip Module Procedures public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4sym – MSOLV-fortran","loc":"interface/umf4sym.html","text":"public interface umf4sym Calls interface~~umf4sym~~CallsGraph interface~umf4sym umf4sym interface~umf4sym->interface~umf4sym proc~umf4zsym_ip umf4zsym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym proc~umf4sym_ip umf4sym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4csym umf4csym interface~umf4sym->interface~umf4csym proc~umf4csym_ip umf4csym_ip interface~umf4sym->proc~umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym interface~umf4zsym->interface~umf4csym interface~umf4zsym->proc~umf4csym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic interface~umf4csym->interface~umf4csym interface~umf4csym->proc~umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic var paninterfaceumf4symCallsGraph = svgPanZoom('#interfaceumf4symCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4sym umf4sym_ip umf4zsym umf4zsym_ip umf4csym umf4csym_ip Module Procedures public interface umf4sym () Arguments None public subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4cnum – MSOLV-fortran","loc":"interface/umf4cnum.html","text":"public interface umf4cnum Calls interface~~umf4cnum~~CallsGraph interface~umf4cnum umf4cnum interface~umf4cnum->interface~umf4cnum proc~umf4cnum_ip umf4cnum_ip interface~umf4cnum->proc~umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceumf4cnumCallsGraph = svgPanZoom('#interfaceumf4cnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4cnum~~CalledByGraph interface~umf4cnum umf4cnum interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cnum umf4cnum_ip Module Procedures public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4znum – MSOLV-fortran","loc":"interface/umf4znum.html","text":"public interface umf4znum Calls interface~~umf4znum~~CallsGraph interface~umf4znum umf4znum interface~umf4znum->interface~umf4znum proc~umf4znum_ip umf4znum_ip interface~umf4znum->proc~umf4znum_ip proc~umf4cnum_ip umf4cnum_ip interface~umf4znum->proc~umf4cnum_ip interface~umf4cnum umf4cnum interface~umf4znum->interface~umf4cnum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceumf4znumCallsGraph = svgPanZoom('#interfaceumf4znumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4znum~~CalledByGraph interface~umf4znum umf4znum interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->interface~umf4znum interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4znum umf4znum_ip umf4cnum umf4cnum_ip Module Procedures public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4num – MSOLV-fortran","loc":"interface/umf4num.html","text":"public interface umf4num Calls interface~~umf4num~~CallsGraph interface~umf4num umf4num interface~umf4num->interface~umf4num proc~umf4num_ip umf4num_ip interface~umf4num->proc~umf4num_ip interface~umf4cnum umf4cnum interface~umf4num->interface~umf4cnum interface~umf4znum umf4znum interface~umf4num->interface~umf4znum proc~umf4znum_ip umf4znum_ip interface~umf4num->proc~umf4znum_ip proc~umf4cnum_ip umf4cnum_ip interface~umf4num->proc~umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num_ip->interface~s_umfpack_numeric interface~umf4cnum->interface~umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum interface~umf4znum->proc~umf4znum_ip interface~umf4znum->proc~umf4cnum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceumf4numCallsGraph = svgPanZoom('#interfaceumf4numCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4num umf4num_ip umf4znum umf4znum_ip umf4cnum umf4cnum_ip Module Procedures public interface umf4num () Arguments None public subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4csolr – MSOLV-fortran","loc":"interface/umf4csolr.html","text":"public interface umf4csolr Calls interface~~umf4csolr~~CallsGraph interface~umf4csolr umf4csolr interface~umf4csolr->interface~umf4csolr proc~umf4csolr_ip umf4csolr_ip interface~umf4csolr->proc~umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4csolrCallsGraph = svgPanZoom('#interfaceumf4csolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4csolr~~CalledByGraph interface~umf4csolr umf4csolr interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csolr umf4csolr_ip Module Procedures public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4zsolr – MSOLV-fortran","loc":"interface/umf4zsolr.html","text":"public interface umf4zsolr Calls interface~~umf4zsolr~~CallsGraph interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4zsolr proc~umf4zsolr_ip umf4zsolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4csolr umf4csolr interface~umf4zsolr->interface~umf4csolr proc~umf4csolr_ip umf4csolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr->interface~umf4csolr interface~umf4csolr->proc~umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4zsolrCallsGraph = svgPanZoom('#interfaceumf4zsolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zsolr~~CalledByGraph interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4zsolr interface~umf4solr umf4solr interface~umf4solr->interface~umf4zsolr interface~umf4solr->interface~umf4solr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsolr umf4zsolr_ip umf4csolr umf4csolr_ip Module Procedures public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4solr – MSOLV-fortran","loc":"interface/umf4solr.html","text":"public interface umf4solr Calls interface~~umf4solr~~CallsGraph interface~umf4solr umf4solr interface~umf4solr->interface~umf4solr proc~umf4zsolr_ip umf4zsolr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4csolr umf4csolr interface~umf4solr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr proc~umf4csolr_ip umf4csolr_ip interface~umf4solr->proc~umf4csolr_ip proc~umf4solr_ip umf4solr_ip interface~umf4solr->proc~umf4solr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr->interface~umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4solrCallsGraph = svgPanZoom('#interfaceumf4solrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4solr umf4solr_ip umf4zsolr umf4zsolr_ip umf4csolr umf4csolr_ip Module Procedures public interface umf4solr () Arguments None public subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4csol – MSOLV-fortran","loc":"interface/umf4csol.html","text":"public interface umf4csol Calls interface~~umf4csol~~CallsGraph interface~umf4csol umf4csol interface~umf4csol->interface~umf4csol proc~umf4csol_ip umf4csol_ip interface~umf4csol->proc~umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4csol~~CalledByGraph interface~umf4csol umf4csol interface~umf4csol->interface~umf4csol interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csol umf4csol_ip Module Procedures public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4zsol – MSOLV-fortran","loc":"interface/umf4zsol.html","text":"public interface umf4zsol Calls interface~~umf4zsol~~CallsGraph interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4zsol interface~umf4csol umf4csol interface~umf4zsol->interface~umf4csol proc~umf4csol_ip umf4csol_ip interface~umf4zsol->proc~umf4csol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4zsol->proc~umf4zsol_ip interface~umf4csol->interface~umf4csol interface~umf4csol->proc~umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4zsolCallsGraph = svgPanZoom('#interfaceumf4zsolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zsol~~CalledByGraph interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->interface~umf4zsol interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsol umf4zsol_ip umf4csol umf4csol_ip Module Procedures public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4sol – MSOLV-fortran","loc":"interface/umf4sol.html","text":"public interface umf4sol Calls interface~~umf4sol~~CallsGraph interface~umf4sol umf4sol interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol interface~umf4csol umf4csol interface~umf4sol->interface~umf4csol proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip proc~umf4csol_ip umf4csol_ip interface~umf4sol->proc~umf4csol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4sol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol interface~umf4zsol->interface~umf4csol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->proc~umf4zsol_ip interface~umf4csol->interface~umf4csol interface~umf4csol->proc~umf4csol_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var paninterfaceumf4solCallsGraph = svgPanZoom('#interfaceumf4solCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4sol umf4sol_ip umf4zsol umf4zsol_ip umf4csol umf4csol_ip Module Procedures public interface umf4sol () Arguments None public subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":""},{"title":"umf4cscal – MSOLV-fortran","loc":"interface/umf4cscal.html","text":"public interface umf4cscal Calls interface~~umf4cscal~~CallsGraph interface~umf4cscal umf4cscal interface~umf4cscal->interface~umf4cscal proc~umf4cscal_ip umf4cscal_ip interface~umf4cscal->proc~umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var paninterfaceumf4cscalCallsGraph = svgPanZoom('#interfaceumf4cscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4cscal~~CalledByGraph interface~umf4cscal umf4cscal interface~umf4cscal->interface~umf4cscal interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cscal umf4cscal_ip Module Procedures public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","tags":""},{"title":"umf4zscal – MSOLV-fortran","loc":"interface/umf4zscal.html","text":"public interface umf4zscal Calls interface~~umf4zscal~~CallsGraph interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4zscal interface~umf4cscal umf4cscal interface~umf4zscal->interface~umf4cscal proc~umf4cscal_ip umf4cscal_ip interface~umf4zscal->proc~umf4cscal_ip proc~umf4zscal_ip umf4zscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var paninterfaceumf4zscalCallsGraph = svgPanZoom('#interfaceumf4zscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zscal~~CalledByGraph interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->interface~umf4zscal interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zscal umf4zscal_ip umf4cscal umf4cscal_ip Module Procedures public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","tags":""},{"title":"umf4scal – MSOLV-fortran","loc":"interface/umf4scal.html","text":"public interface umf4scal Calls interface~~umf4scal~~CallsGraph interface~umf4scal umf4scal interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4scal->interface~umf4cscal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal proc~umf4scal_ip umf4scal_ip interface~umf4scal->proc~umf4scal_ip proc~umf4cscal_ip umf4cscal_ip interface~umf4scal->proc~umf4cscal_ip proc~umf4zscal_ip umf4zscal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale var paninterfaceumf4scalCallsGraph = svgPanZoom('#interfaceumf4scalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4scal umf4scal_ip umf4zscal umf4zscal_ip umf4cscal umf4cscal_ip Module Procedures public interface umf4scal () Arguments None public subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","tags":""},{"title":"umf4cfnum – MSOLV-fortran","loc":"interface/umf4cfnum.html","text":"public interface umf4cfnum Calls interface~~umf4cfnum~~CallsGraph interface~umf4cfnum umf4cfnum interface~umf4cfnum->interface~umf4cfnum proc~umf4cfnum_ip umf4cfnum_ip interface~umf4cfnum->proc~umf4cfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaceumf4cfnumCallsGraph = svgPanZoom('#interfaceumf4cfnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cfnum umf4cfnum_ip Module Procedures public interface umf4cfnum () Arguments None public subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","tags":""},{"title":"umf4zfnum – MSOLV-fortran","loc":"interface/umf4zfnum.html","text":"public interface umf4zfnum Calls interface~~umf4zfnum~~CallsGraph interface~umf4zfnum umf4zfnum interface~umf4zfnum->interface~umf4zfnum proc~umf4zfnum_ip umf4zfnum_ip interface~umf4zfnum->proc~umf4zfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaceumf4zfnumCallsGraph = svgPanZoom('#interfaceumf4zfnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zfnum umf4zfnum_ip Module Procedures public interface umf4zfnum () Arguments None public subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","tags":""},{"title":"umf4fnum – MSOLV-fortran","loc":"interface/umf4fnum.html","text":"public interface umf4fnum Calls interface~~umf4fnum~~CallsGraph interface~umf4fnum umf4fnum interface~umf4fnum->interface~umf4fnum proc~umf4fnum_ip umf4fnum_ip interface~umf4fnum->proc~umf4fnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaceumf4fnumCallsGraph = svgPanZoom('#interfaceumf4fnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4fnum umf4fnum_ip Module Procedures public interface umf4fnum () Arguments None public subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","tags":""},{"title":"umf4cfsym – MSOLV-fortran","loc":"interface/umf4cfsym.html","text":"public interface umf4cfsym Calls interface~~umf4cfsym~~CallsGraph interface~umf4cfsym umf4cfsym interface~umf4cfsym->interface~umf4cfsym proc~umf4cfsym_ip umf4cfsym_ip interface~umf4cfsym->proc~umf4cfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaceumf4cfsymCallsGraph = svgPanZoom('#interfaceumf4cfsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cfsym umf4cfsym_ip Module Procedures public interface umf4cfsym () Arguments None public subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","tags":""},{"title":"umf4zfsym – MSOLV-fortran","loc":"interface/umf4zfsym.html","text":"public interface umf4zfsym Calls interface~~umf4zfsym~~CallsGraph interface~umf4zfsym umf4zfsym interface~umf4zfsym->interface~umf4zfsym proc~umf4zfsym_ip umf4zfsym_ip interface~umf4zfsym->proc~umf4zfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaceumf4zfsymCallsGraph = svgPanZoom('#interfaceumf4zfsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zfsym umf4zfsym_ip Module Procedures public interface umf4zfsym () Arguments None public subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","tags":""},{"title":"umf4fsym – MSOLV-fortran","loc":"interface/umf4fsym.html","text":"public interface umf4fsym Calls interface~~umf4fsym~~CallsGraph interface~umf4fsym umf4fsym interface~umf4fsym->interface~umf4fsym proc~umf4fsym_ip umf4fsym_ip interface~umf4fsym->proc~umf4fsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaceumf4fsymCallsGraph = svgPanZoom('#interfaceumf4fsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4fsym umf4fsym_ip Module Procedures public interface umf4fsym () Arguments None public subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","tags":""},{"title":"umf4csnum – MSOLV-fortran","loc":"interface/umf4csnum.html","text":"public interface umf4csnum Calls interface~~umf4csnum~~CallsGraph interface~umf4csnum umf4csnum interface~umf4csnum->interface~umf4csnum proc~umf4csnum_ip umf4csnum_ip interface~umf4csnum->proc~umf4csnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var paninterfaceumf4csnumCallsGraph = svgPanZoom('#interfaceumf4csnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csnum umf4csnum_ip Module Procedures public interface umf4csnum () Arguments None public subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4zsnum – MSOLV-fortran","loc":"interface/umf4zsnum.html","text":"public interface umf4zsnum Calls interface~~umf4zsnum~~CallsGraph interface~umf4zsnum umf4zsnum interface~umf4zsnum->interface~umf4zsnum proc~umf4zsnum_ip umf4zsnum_ip interface~umf4zsnum->proc~umf4zsnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var paninterfaceumf4zsnumCallsGraph = svgPanZoom('#interfaceumf4zsnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsnum umf4zsnum_ip Module Procedures public interface umf4zsnum () Arguments None public subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4snum – MSOLV-fortran","loc":"interface/umf4snum.html","text":"public interface umf4snum Calls interface~~umf4snum~~CallsGraph interface~umf4snum umf4snum interface~umf4snum->interface~umf4snum proc~umf4snum_ip umf4snum_ip interface~umf4snum->proc~umf4snum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var paninterfaceumf4snumCallsGraph = svgPanZoom('#interfaceumf4snumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4snum umf4snum_ip Module Procedures public interface umf4snum () Arguments None public subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4cssym – MSOLV-fortran","loc":"interface/umf4cssym.html","text":"public interface umf4cssym Calls interface~~umf4cssym~~CallsGraph interface~umf4cssym umf4cssym interface~umf4cssym->interface~umf4cssym proc~umf4cssym_ip umf4cssym_ip interface~umf4cssym->proc~umf4cssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic var paninterfaceumf4cssymCallsGraph = svgPanZoom('#interfaceumf4cssymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cssym umf4cssym_ip Module Procedures public interface umf4cssym () Arguments None public subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4zssym – MSOLV-fortran","loc":"interface/umf4zssym.html","text":"public interface umf4zssym Calls interface~~umf4zssym~~CallsGraph interface~umf4zssym umf4zssym interface~umf4zssym->interface~umf4zssym proc~umf4zssym_ip umf4zssym_ip interface~umf4zssym->proc~umf4zssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic var paninterfaceumf4zssymCallsGraph = svgPanZoom('#interfaceumf4zssymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zssym umf4zssym_ip Module Procedures public interface umf4zssym () Arguments None public subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4ssym – MSOLV-fortran","loc":"interface/umf4ssym.html","text":"public interface umf4ssym Calls interface~~umf4ssym~~CallsGraph interface~umf4ssym umf4ssym interface~umf4ssym->interface~umf4ssym proc~umf4ssym_ip umf4ssym_ip interface~umf4ssym->proc~umf4ssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic var paninterfaceumf4ssymCallsGraph = svgPanZoom('#interfaceumf4ssymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4ssym umf4ssym_ip Module Procedures public interface umf4ssym () Arguments None public subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4clnum – MSOLV-fortran","loc":"interface/umf4clnum.html","text":"public interface umf4clnum Calls interface~~umf4clnum~~CallsGraph interface~umf4clnum umf4clnum interface~umf4clnum->interface~umf4clnum proc~umf4clnum_ip umf4clnum_ip interface~umf4clnum->proc~umf4clnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric var paninterfaceumf4clnumCallsGraph = svgPanZoom('#interfaceumf4clnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4clnum umf4clnum_ip Module Procedures public interface umf4clnum () Arguments None public subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4zlnum – MSOLV-fortran","loc":"interface/umf4zlnum.html","text":"public interface umf4zlnum Calls interface~~umf4zlnum~~CallsGraph interface~umf4zlnum umf4zlnum interface~umf4zlnum->interface~umf4zlnum proc~umf4zlnum_ip umf4zlnum_ip interface~umf4zlnum->proc~umf4zlnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric var paninterfaceumf4zlnumCallsGraph = svgPanZoom('#interfaceumf4zlnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zlnum umf4zlnum_ip Module Procedures public interface umf4zlnum () Arguments None public subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4lnum – MSOLV-fortran","loc":"interface/umf4lnum.html","text":"public interface umf4lnum Calls interface~~umf4lnum~~CallsGraph interface~umf4lnum umf4lnum interface~umf4lnum->interface~umf4lnum proc~umf4lnum_ip umf4lnum_ip interface~umf4lnum->proc~umf4lnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric var paninterfaceumf4lnumCallsGraph = svgPanZoom('#interfaceumf4lnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4lnum umf4lnum_ip Module Procedures public interface umf4lnum () Arguments None public subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4clsym – MSOLV-fortran","loc":"interface/umf4clsym.html","text":"public interface umf4clsym Calls interface~~umf4clsym~~CallsGraph interface~umf4clsym umf4clsym interface~umf4clsym->interface~umf4clsym proc~umf4clsym_ip umf4clsym_ip interface~umf4clsym->proc~umf4clsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic var paninterfaceumf4clsymCallsGraph = svgPanZoom('#interfaceumf4clsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4clsym umf4clsym_ip Module Procedures public interface umf4clsym () Arguments None public subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4zlsym – MSOLV-fortran","loc":"interface/umf4zlsym.html","text":"public interface umf4zlsym Calls interface~~umf4zlsym~~CallsGraph interface~umf4zlsym umf4zlsym interface~umf4zlsym->interface~umf4zlsym proc~umf4zlsym_ip umf4zlsym_ip interface~umf4zlsym->proc~umf4zlsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic var paninterfaceumf4zlsymCallsGraph = svgPanZoom('#interfaceumf4zlsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zlsym umf4zlsym_ip Module Procedures public interface umf4zlsym () Arguments None public subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"umf4lsym – MSOLV-fortran","loc":"interface/umf4lsym.html","text":"public interface umf4lsym Calls interface~~umf4lsym~~CallsGraph interface~umf4lsym umf4lsym interface~umf4lsym->interface~umf4lsym proc~umf4lsym_ip umf4lsym_ip interface~umf4lsym->proc~umf4lsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic var paninterfaceumf4lsymCallsGraph = svgPanZoom('#interfaceumf4lsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4lsym umf4lsym_ip Module Procedures public interface umf4lsym () Arguments None public subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"pCSC – MSOLV-fortran","loc":"interface/pcsc.html","text":"public interface pCSC Calls interface~~pcsc~~CallsGraph interface~pcsc pCSC proc~make_csc_di make_CSC_di interface~pcsc->proc~make_csc_di proc~make_csc_zi make_CSC_zi interface~pcsc->proc~make_csc_zi proc~make_csc_ci make_CSC_ci interface~pcsc->proc~make_csc_ci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures make_CSC_di make_CSC_zi make_CSC_ci Module Procedures public function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci )","tags":""},{"title":"pCSR – MSOLV-fortran","loc":"interface/pcsr.html","text":"public interface pCSR Calls interface~~pcsr~~CallsGraph interface~pcsr pCSR proc~make_csr_zi make_CSR_zi interface~pcsr->proc~make_csr_zi proc~make_csr_ci make_CSR_ci interface~pcsr->proc~make_csr_ci proc~make_csr_di make_CSR_di interface~pcsr->proc~make_csr_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures make_CSR_di make_CSR_zi make_CSR_ci Module Procedures public function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci )","tags":""},{"title":"pVec – MSOLV-fortran","loc":"interface/pvec.html","text":"public interface pVec Calls interface~~pvec~~CallsGraph interface~pvec pVec proc~make_vec_zi make_Vec_zi interface~pvec->proc~make_vec_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures make_Vec_zi Module Procedures public function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi )","tags":""},{"title":"operator(.umfpack.) – MSOLV-fortran","loc":"interface/operator(.umfpack.).html","text":"public interface operator(.umfpack.) Calls interface~~operator(.umfpack.)~~CallsGraph interface~operator(.umfpack.) operator(.umfpack.) proc~umfpack_di_operator_csc umfpack_di_operator_CSC interface~operator(.umfpack.)->proc~umfpack_di_operator_csc proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc proc~umfpack_di_operator_csr umfpack_di_operator_CSR interface~operator(.umfpack.)->proc~umfpack_di_operator_csr proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceoperatorumfpackCallsGraph = svgPanZoom('#interfaceoperatorumfpackCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_operator_CSC umfpack_zi_operator_CSC umfpack_ci_operator_CSC umfpack_di_operator_CSR umfpack_zi_operator_CSR umfpack_ci_operator_CSR umfpack_di_operator_pCSC umfpack_zi_operator_pCSC umfpack_ci_operator_pCSC umfpack_di_operator_pCSR umfpack_zi_operator_pCSR umfpack_ci_operator_pCSR Module Procedures public function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1)","tags":""},{"title":"get_unit – MSOLV-fortran","loc":"proc/get_unit.html","text":"public subroutine get_unit(iunit) Note from John Burkardt website Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out) :: iunit Called by proc~~get_unit~~CalledByGraph proc~get_unit get_unit program~test_solvers test_solvers program~test_solvers->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_unit Source Code subroutine get_unit ( iunit ) implicit none integer ( kind = I4 ), intent ( out ) :: iunit integer ( kind = I4 ) :: i integer ( kind = I4 ) :: ios logical ( kind = I4 ) :: lopen iunit = 0 do i = 10 , 99 if ( i /= OUT_U . and . i /= IN_U . and . i /= ERR_U ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return endif endif endif enddo return endsubroutine get_unit","tags":""},{"title":"sort_real_1real – MSOLV-fortran","loc":"proc/sort_real_1real.html","text":"public recursive subroutine sort_real_1real(g, d, rtabref, rtab1) Note Subroutine to sort a vector of reals, according a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 Contents Source Code sort_real_1real Source Code recursive subroutine sort_real_1real ( g , d , rtabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_1real ( g , j , rtabref , rtab1 ) if ( d > i ) call sort_real_1real ( i , d , rtabref , rtab1 ) return endsubroutine sort_real_1real","tags":""},{"title":"sort_real_2real – MSOLV-fortran","loc":"proc/sort_real_2real.html","text":"public recursive subroutine sort_real_2real(g, d, rtabref, rtab1, rtab2) Note Subroutine to sort 2 vectors of reals, according a vector of realq Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 Contents Source Code sort_real_2real Source Code recursive subroutine sort_real_2real ( g , d , rtabref , rtab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_2real ( g , j , rtabref , rtab1 , rtab2 ) if ( d > i ) call sort_real_2real ( i , d , rtabref , rtab1 , rtab2 ) return endsubroutine sort_real_2real","tags":""},{"title":"sort_int_1int_1real – MSOLV-fortran","loc":"proc/sort_int_1int_1real.html","text":"public recursive subroutine sort_int_1int_1real(g, d, itabref, itab1, rtab2) Note Subroutine to sort a vector of reals and a vector of integers, according a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref integer(kind=I4), intent(inout), dimension(:) :: itab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 Contents Source Code sort_int_1int_1real Source Code recursive subroutine sort_int_1int_1real ( g , d , itabref , itab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref integer ( kind = I4 ), dimension (:), intent ( inout ) :: itab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 2 itmp = itab1 ( i ) itab1 ( i ) = itab1 ( j ) itab1 ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1int_1real ( g , j , itabref , itab1 , rtab2 ) if ( d > i ) call sort_int_1int_1real ( i , d , itabref , itab1 , rtab2 ) return endsubroutine sort_int_1int_1real","tags":""},{"title":"sort_int_1real – MSOLV-fortran","loc":"proc/sort_int_1real.html","text":"public recursive subroutine sort_int_1real(g, d, itabref, rtab1) Note Subroutine to sort a vector of reals, according a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref real(kind=R8), intent(inout), dimension(:) :: rtab1 Contents Source Code sort_int_1real Source Code recursive subroutine sort_int_1real ( g , d , itabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1real ( g , j , itabref , rtab1 ) if ( d > i ) call sort_int_1real ( i , d , itabref , rtab1 ) return endsubroutine sort_int_1real","tags":""},{"title":"mumps_wrapper – MSOLV-fortran","loc":"module/mumps_wrapper.html","text":"Used by module~~mumps_wrapper~~UsedByGraph module~mumps_wrapper mumps_wrapper module~solver solver module~solver->module~mumps_wrapper program~test_solvers test_solvers program~test_solvers->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MPI_COMM_WORLD Derived Types DMUMPS_STRUC Variables Type Visibility Attributes Name Initial integer, public, parameter :: MPI_COMM_WORLD = 9 Derived Types type, public, sequence  :: DMUMPS_STRUC Components Type Visibility Attributes Name Initial integer, public :: COMM integer, public :: SYM integer, public :: PAR integer, public :: JOB integer, public :: N integer, public :: NZ integer(kind=8), public :: NNZ double precision, public, DIMENSION(:), POINTER :: A integer, public, DIMENSION(:), POINTER :: IRN integer, public, DIMENSION(:), POINTER :: JCN double precision, public, DIMENSION(:), POINTER :: COLSCA double precision, public, DIMENSION(:), POINTER :: ROWSCA double precision, public, DIMENSION(:), POINTER :: pad0 integer, public :: NZ_loc integer, public :: pad1 integer(kind=8), public :: NNZ_loc integer, public, DIMENSION(:), POINTER :: IRN_loc integer, public, DIMENSION(:), POINTER :: JCN_loc double precision, public, DIMENSION(:), POINTER :: A_loc double precision, public, DIMENSION(:), POINTER :: pad2 integer, public :: NELT integer, public :: pad3 integer, public, DIMENSION(:), POINTER :: ELTPTR integer, public, DIMENSION(:), POINTER :: ELTVAR double precision, public, DIMENSION(:), POINTER :: A_ELT double precision, public, DIMENSION(:), POINTER :: pad4 integer, public, DIMENSION(:), POINTER :: PERM_IN double precision, public, DIMENSION(:), POINTER :: RHS double precision, public, DIMENSION(:), POINTER :: REDRHS double precision, public, DIMENSION(:), POINTER :: RHS_SPARSE double precision, public, DIMENSION(:), POINTER :: SOL_loc integer, public, DIMENSION(:), POINTER :: IRHS_SPARSE integer, public, DIMENSION(:), POINTER :: IRHS_PTR integer, public, DIMENSION(:), POINTER :: ISOL_loc integer, public :: LRHS integer, public :: NRHS integer, public :: NZ_RHS integer, public :: LSOL_loc integer, public :: LREDRHS integer, public :: pad5 integer, public :: ICNTL (40) integer, public :: INFO (40) integer, public :: INFOG (40) double precision, public :: COST_SUBTREES double precision, public :: CNTL (15) double precision, public :: RINFO (40) double precision, public :: RINFOG (40) integer, public, DIMENSION(:), POINTER :: SYM_PERM integer, public, DIMENSION(:), POINTER :: UNS_PERM integer, public :: NPROW integer, public :: NPCOL integer, public :: MBLOCK integer, public :: NBLOCK integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC integer, public :: SCHUR_LLD integer, public :: SIZE_SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR_CINTERFACE integer, public, DIMENSION(:), POINTER :: LISTVAR_SCHUR integer, public, DIMENSION(:), POINTER :: MAPPING character(len=30), public :: VERSION_NUMBER character(len=255), public :: OOC_TMPDIR character(len=63), public :: OOC_PREFIX character(len=255), public :: WRITE_PROBLEM character(len=255), public :: SAVE_DIR character(len=255), public :: SAVE_PREFIX character(len=7), public :: pad8 integer(kind=8), public :: KEEP8 (150) integer(kind=8), public :: MAX_SURF_MASTER integer, public :: INST_Number integer, public :: COMM_NODES integer, public :: MYID_NODES integer, public :: COMM_LOAD integer, public :: MYID integer, public :: NPROCS integer, public :: NSLAVES integer, public :: ASS_IRECV integer, public :: LBUFR integer, public :: LBUFR_BYTES integer, public, DIMENSION(:), POINTER :: BUFR integer, public, DIMENSION(:), POINTER :: IS integer, public, DIMENSION(:), POINTER :: IS1 integer, public :: MAXIS1 integer, public :: Deficiency integer, public :: KEEP (500) integer, public :: LNA integer, public :: NBSA integer, public, POINTER, DIMENSION(:) :: STEP integer, public, POINTER, DIMENSION(:) :: NE_STEPS integer, public, POINTER, DIMENSION(:) :: ND_STEPS integer, public, POINTER, DIMENSION(:) :: Step2node integer, public, POINTER, DIMENSION(:) :: FRERE_STEPS integer, public, POINTER, DIMENSION(:) :: DAD_STEPS integer, public, POINTER, DIMENSION(:) :: FILS integer, public, POINTER, DIMENSION(:) :: FRTPTR integer, public, POINTER, DIMENSION(:) :: FRTELT integer(kind=8), public, POINTER, DIMENSION(:) :: PTRAR integer, public, POINTER, DIMENSION(:) :: NA integer, public, POINTER, DIMENSION(:) :: PROCNODE_STEPS integer, public, DIMENSION(:), POINTER :: PTLUST_S integer(kind=8), public, DIMENSION(:), POINTER :: PTRFAC double precision, public, DIMENSION(:), POINTER :: S integer, public, DIMENSION(:), POINTER :: PROCNODE integer, public, DIMENSION(:), POINTER :: INTARR double precision, public, DIMENSION(:), POINTER :: DBLARR integer, public :: NELT_loc integer, public :: LELTVAR integer, public, DIMENSION(:), POINTER :: ELTPROC integer, public, DIMENSION(:,:), POINTER :: CANDIDATES integer, public, DIMENSION(:), POINTER :: ISTEP_TO_INIV2 integer, public, DIMENSION(:), POINTER :: FUTURE_NIV2 integer, public, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE logical, public, DIMENSION(:), POINTER :: I_AM_CAND integer, public, DIMENSION(:), POINTER :: MEM_DIST integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_ROW logical, public :: POSINRHSCOMP_COL_ALLOC logical, public :: pad11 integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_COL double precision, public, DIMENSION(:), POINTER :: RHSCOMP double precision, public, DIMENSION(:), POINTER :: MEM_SUBTREE double precision, public, DIMENSION(:), POINTER :: COST_TRAV integer, public, DIMENSION(:), POINTER :: MY_ROOT_SBTR integer, public, DIMENSION(:), POINTER :: MY_FIRST_LEAF integer, public, DIMENSION(:), POINTER :: MY_NB_LEAF integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST_SEQ integer, public, DIMENSION(:), POINTER :: SBTR_ID integer, public, DIMENSION(:), POINTER :: SCHED_DEP integer, public, DIMENSION(:), POINTER :: SCHED_GRP integer, public, DIMENSION(:), POINTER :: SCHED_SBTR integer, public, DIMENSION(:), POINTER :: CROIX_MANU double precision, public, DIMENSION(:), POINTER :: WK_USER integer, public :: NBSA_LOCAL integer, public :: LWK_USER double precision, public :: DKEEP (230) double precision, public, DIMENSION(:), POINTER :: CB_SON_SIZE integer, public :: INSTANCE_NUMBER integer, public :: OOC_MAX_NB_NODES_FOR_ZONE integer, public, DIMENSION(:,:), POINTER :: OOC_INODE_SEQUENCE integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_VADDR integer, public, DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES integer, public, DIMENSION(:), POINTER :: OOC_NB_FILES integer, public :: OOC_NB_FILE_TYPE integer, public :: pad12 integer, public, DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH character, public, DIMENSION(:,:), POINTER :: OOC_FILE_NAMES integer, public, DIMENSION(:), POINTER :: PIVNUL_LIST integer, public, DIMENSION(:,:), POINTER :: SUP_PROC integer, public, DIMENSION(:,:), POINTER :: pad14 integer, public, DIMENSION(:), POINTER :: IPTR_WORKING integer, public, DIMENSION(:), POINTER :: WORKING type(DMUMPS_ROOT_STRUC), public :: root integer, public, POINTER, DIMENSION(:) :: LRGROUPS integer, public :: NBGRP integer, public :: pad13 character(len=1), public, DIMENSION(:), POINTER :: FDM_F_ENCODING character(len=1), public, DIMENSION(:), POINTER :: BLRARRAY_ENCODING integer, public :: LPOOL_AFTER_L0_OMP integer, public :: LPOOL_BEFORE_L0_OMP integer, public :: L_PHYS_L0_OMP integer, public :: L_VIRT_L0_OMP integer, public :: LL0_OMP_MAPPING integer, public :: pad15 integer(kind=8), public :: THREAD_LA integer, public, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP integer, public, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP integer, public, DIMENSION(:), POINTER :: PHYS_L0_OMP integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: PERM_L0_OMP integer, public, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP integer, public, DIMENSION(:), POINTER :: L0_OMP_MAPPING double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES integer, public :: NB_SINGULAR_VALUES logical, public :: ASSOCIATED_OOC_FILES","tags":""},{"title":"solver – MSOLV-fortran","loc":"module/solver.html","text":"Api for different sparse matrix solvers Uses iso_c_binding data_arch num_param sort_arrays hsl_ma48_double sulu_wrapper mumps_wrapper mumfpack module~~solver~~UsesGraph module~solver solver iso_c_binding iso_c_binding module~solver->iso_c_binding module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~mumfpack mumfpack module~solver->module~mumfpack module~sort_arrays sort_arrays module~solver->module~sort_arrays module~num_param num_param module~solver->module~num_param module~data_arch data_arch module~solver->module~data_arch module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~sulu_wrapper->iso_c_binding module~mumfpack->iso_c_binding module~sort_arrays->module~data_arch module~num_param->module~data_arch iso_fortran_env iso_fortran_env module~num_param->iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver~~UsedByGraph module~solver solver program~test_solvers test_solvers program~test_solvers->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MA48 SULU MUMP UMFP SOLVER_BS SOLVER_TS Derived Types MAT_MA48 MAT_UMFP MAT_SOLV MS_MAT_SOLV Subroutines solve_syst init_solver analyse_solver factorize_solver solution_solver freefact_solver close_solver convert_matrice_format from_elemental_to_assembled Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: MA48 = 0 code for     Ma48 solver type integer(kind=I4), public, parameter :: SULU = 1 code for SUPER LU solver type integer(kind=I4), public, parameter :: MUMP = 2 code for    MUMPS solver type integer(kind=I4), public, parameter :: UMFP = 3 code for  UMFPACK solver type integer(kind=I4), public :: SOLVER_BS = -1 solver used for bottom scale grids [not used by the present module] integer(kind=I4), public :: SOLVER_TS = -1 solver used for top scale grids [not used by the present module] Derived Types type, public :: MAT_MA48 All the stuff needed by HSL_MA48 Components Type Visibility Attributes Name Initial type(ZD11_TYPE), public :: zmat type(MA48_CONTROL), public :: ctrl type(MA48_AINFO), public :: ainf type(MA48_FINFO), public :: finf type(MA48_SINFO), public :: sinf type(MA48_FACTORS), public :: fact integer(kind=I4), public :: fast real(kind=R8), public, dimension(2) :: resid type, public :: MAT_UMFP All the stuff needed by UMFPACK Components Type Visibility Attributes Name Initial type(c_ptr), public :: c_symbolic type(c_ptr), public :: c_numeric real(kind=R8), public, dimension(0:UMFPACK_CONTROL-1) :: c_control real(kind=R8), public, dimension(0:UMFPACK_INFO   -1) :: c_info type, public :: MAT_SOLV MUSST high level system type Components Type Visibility Attributes Name Initial integer(kind=I4), public :: slv_t solver type logical(kind=I4), public :: first = .true. analysis of the system to be done? integer(kind=I4), public :: nn number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: nt number of a priori non-zero terms in the matrix integer(kind=I4), public :: nz number of non-zero terms in the matrix integer(kind=I4), public :: nvar eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices) integer(kind=I4), public :: code error code [not used yet] real(kind=R8), public :: error error value [not used yet] character(len=1024), public :: mess message [not used yet] type(MAT_MUMP), public :: matmump matrices for mumps solver type( MAT_MA48 ), public :: matma48 matrices for ma48 solver type(MAT_SULU), public :: matsulu matrices for SuperLu solver type( MAT_UMFP ), public :: matumfp matrices for Umfpack solver integer(kind=I4), public, dimension(:), allocatable :: eltvar rows in assembled matrix integer(kind=I4), public, dimension(:), allocatable :: eltptr element rows pointer real(kind=R8), public, dimension(:), allocatable :: a_elt unassembled rigidity matrix integer(kind=I4), public, dimension(:), allocatable :: irow line number integer(kind=I4), public, dimension(:), allocatable :: jcol column number integer(kind=I4), public, dimension(:), allocatable :: jptr line pointer real(kind=R8), public, dimension(:), allocatable :: b right hand side vector real(kind=R8), public, dimension(:), allocatable :: x unknwon vector type, public :: MS_MAT_SOLV MUSST multiscale high level solver type Read more… Components Type Visibility Attributes Name Initial type( MAT_SOLV ), public :: ts_mat top-scale solver type matrices type( MAT_SOLV ), public, dimension(:), allocatable :: bs_mat bottom-scale solver type matrices (table) integer(kind=I4), public, dimension(:), allocatable :: ass_loc_in_mat table for assembly location (for parallel computation) Subroutines public subroutine solve_syst (mat, step) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type character(len=*), intent(in) :: step 'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver public subroutine init_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type public subroutine analyse_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type public subroutine factorize_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type public subroutine solution_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type public subroutine freefact_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type public subroutine close_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type public subroutine convert_matrice_format (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type public subroutine from_elemental_to_assembled (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type","tags":""},{"title":"sulu_wrapper – MSOLV-fortran","loc":"module/sulu_wrapper.html","text":"A SuperLU wrapper Uses iso_c_binding module~~sulu_wrapper~~UsesGraph module~sulu_wrapper sulu_wrapper iso_c_binding iso_c_binding module~sulu_wrapper->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~sulu_wrapper~~UsedByGraph module~sulu_wrapper sulu_wrapper module~solver solver module~solver->module~sulu_wrapper program~test_solvers test_solvers program~test_solvers->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables I4 R4 R8 Enumerations Interfaces Destroy_SuperNode_Matrix Destroy_SuperMatrix_Store Destroy_CompCol_Matrix Destroy_Dense_Matrix StatInit StatFree dCreate_CompCol_Matrix dCreate_Dense_Matrix set_default_options dgssvx StatPrint Derived Types LU_STACK_T EXPHEADER GLOBALLU_T SUPERLUSTAT_T MEM_USAGE_T NCFORMAT SUPERMATRIX SUPERLU_OPTIONS_T SULU_ENV Subroutines init_superlu prep_superlu fact_superlu solv_superlu free_superlu close_superlu Variables Type Visibility Attributes Name Initial integer(kind=4), private, parameter :: I4 = 4 integer(kind=4), private, parameter :: R4 = 4 integer(kind=4), private, parameter :: R8 = 8 Enumerations enum, bind(c) Enumerators enumerator :: NOTRANS = 0 enumerator :: TRANS = 1 enumerator :: CONJ = 2 enum, bind(c) Enumerators enumerator :: DOFACT = 0 enumerator :: SAMEPATTERN = 1 enumerator :: SAMEPATTERN_SAMEROWPERM = 2 enumerator :: FACTORED = 3 enum, bind(c) Enumerators enumerator :: SLU_NC = 0 column-wise, no supernode enumerator :: SLU_NCP = 1 column-wise, column-permuted, no supernode enumerator :: SLU_NR = 2 row-wize, no supernode enumerator :: SLU_SC = 3 column-wise, supernode enumerator :: SLU_SCP = 4 supernode, column-wise, permuted enumerator :: SLU_SR = 5 row-wise, supernode enumerator :: SLU_DN = 6 Fortran style column-wise storage for dense matrix enumerator :: SLU_NR_loc = 7 distributed compressed row format enum, bind(c) Enumerators enumerator :: SLU_S = 0 single enumerator :: SLU_D = 1 double enumerator :: SLU_C = 2 single complex enumerator :: SLU_Z = 3 double complex enum, bind(c) Enumerators enumerator :: SLU_GE = 0 general enumerator :: SLU_TRLU = 1 lower triangular, unit diagonal enumerator :: SLU_TRUU = 2 upper triangular, unit diagonal enumerator :: SLU_TRL = 3 lower triangular enumerator :: SLU_TRU = 4 upper triangular enumerator :: SLU_SYL = 5 symmetric, store lower half enumerator :: SLU_SYU = 6 symmetric, store upper half enumerator :: SLU_HEL = 7 Hermitian, store lower half enumerator :: SLU_HEU = 8 Hermitian, store upper half Interfaces interface public subroutine Destroy_SuperNode_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private subroutine Destroy_SuperMatrix_Store(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface public subroutine Destroy_CompCol_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private subroutine Destroy_Dense_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private subroutine StatInit(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(out) :: stat interface private subroutine StatFree(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat interface private subroutine dCreate_CompCol_Matrix(A, m, n, nnz, nzval, rowind, colptr, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: A integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n integer(kind=C_INT), intent(in), value :: nnz real(kind=C_DOUBLE), intent(in) :: nzval (*) integer(kind=C_INT), intent(in) :: rowind (*) integer(kind=C_INT), intent(in) :: colptr (*) integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype interface private subroutine dCreate_Dense_Matrix(BX, m, n, x, ldx, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: BX integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n real(kind=C_DOUBLE), intent(in) :: x (*) integer(kind=C_INT), intent(in), value :: ldx integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype interface private subroutine set_default_options(options) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(inout) :: options interface private subroutine dgssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, U, work, lwork, B, X, recip_pivot_growth, rcond, ferr, berr, Glu, mem_usage, stat, info) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(in) :: options type( SUPERMATRIX ), intent(inout) :: A integer(kind=C_INT), intent(inout) :: perm_c (*) integer(kind=C_INT), intent(inout) :: perm_r (*) integer(kind=C_INT), intent(inout) :: etree (*) character(kind=C_CHAR), intent(inout) :: equed (*) real(kind=C_DOUBLE), intent(inout) :: R (*) real(kind=C_DOUBLE), intent(inout) :: C (*) type( SUPERMATRIX ), intent(inout) :: L type( SUPERMATRIX ), intent(inout) :: U type(C_PTR), intent(out) :: work integer(kind=C_INT), intent(in), value :: lwork type( SUPERMATRIX ), intent(inout) :: B type( SUPERMATRIX ), intent(out) :: X real(kind=C_DOUBLE), intent(out) :: recip_pivot_growth (*) real(kind=C_DOUBLE), intent(out) :: rcond (*) real(kind=C_DOUBLE), intent(out) :: ferr (*) real(kind=C_DOUBLE), intent(out) :: berr (*) type( GLOBALLU_T ), intent(inout) :: Glu type( MEM_USAGE_T ), intent(out) :: mem_usage type( SUPERLUSTAT_T ), intent(out) :: stat integer(kind=C_INT), intent(out) :: info interface private subroutine StatPrint(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat Derived Types type, private, bind(c) :: LU_STACK_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size integer(kind=C_INT), public :: used integer(kind=C_INT), public :: top1 integer(kind=C_INT), public :: top2 type(C_PTR), public :: array type, private, bind(c) :: EXPHEADER Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size type(C_PTR), public :: mem type, private, bind(c) :: GLOBALLU_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: xsup integer(kind=C_INT), public :: supno integer(kind=C_INT), public :: lsub integer(kind=C_INT), public :: xlsub type(C_PTR), public :: lusup integer(kind=C_INT), public :: xlusup type(C_PTR), public :: ucol integer(kind=C_INT), public :: usub integer(kind=C_INT), public :: xusub integer(kind=C_INT), public :: nzlmax integer(kind=C_INT), public :: nzumax integer(kind=C_INT), public :: nzlumax integer(kind=C_INT), public :: MemModel = 0 integer(kind=C_INT), public :: num_expansions type( EXPHEADER ), public :: expanders type( LU_STACK_T ), public :: stack type, private, bind(c) :: SUPERLUSTAT_T Components Type Visibility Attributes Name Initial type(C_PTR), public :: panel_histo histogram of panel size distribution type(C_PTR), public :: utime running time at various phases type(C_PTR), public :: ops operation count at various phases integer(kind=C_INT), public :: TinyPivots number of tiny pivots integer(kind=C_INT), public :: RefineSteps number of iterative refinement steps integer(kind=C_INT), public :: expansions number of memory expansions type, private, bind(c) :: MEM_USAGE_T Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: for_lu real(kind=C_FLOAT), public :: total_needed type, private, bind(c) :: NCFORMAT Read more… Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: nnz number of nonzeros in the matrix type(C_PTR), public :: nzval pointer to array of nonzero values, packed by column type(C_PTR), public :: rowind pointer to array of row indices of the nonzeros type(C_PTR), public :: colptr pointer to array of beginning of columns in nzval[] and rowind[] type, private, bind(c) :: SUPERMATRIX Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Stype Storage type: interprets the storage structure pointed to by Store integer(kind=C_INT), public :: Dtype Data type integer(kind=C_INT), public :: Mtype Matrix type: describes the mathematical property of the matrix integer(kind=C_INT), public :: nrow number of rows integer(kind=C_INT), public :: ncol number of columns type(C_PTR), public :: Store pointer to the actual storage of the matrix, here, pointer to NCFORMAT type, private, bind(c) :: SUPERLU_OPTIONS_T Read more… Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Fact integer(kind=C_INT), public :: Equil integer(kind=C_INT), public :: ColPerm integer(kind=C_INT), public :: Trans integer(kind=C_INT), public :: IterRefine real(kind=C_DOUBLE), public :: DiagPivotThresh integer(kind=C_INT), public :: SymmetricMode integer(kind=C_INT), public :: PivotGrowth integer(kind=C_INT), public :: ConditionNumber integer(kind=C_INT), public :: RowPerm integer(kind=C_INT), public :: ILU_DropRule real(kind=C_DOUBLE), public :: ILU_DropTol real(kind=C_DOUBLE), public :: ILU_FillFactor integer(kind=C_INT), public :: ILU_Norm real(kind=C_DOUBLE), public :: ILU_FillTol integer(kind=C_INT), public :: ILU_MILU real(kind=C_DOUBLE), public :: ILU_MILU_Dim integer(kind=C_INT), public :: ParSymbFact integer(kind=C_INT), public :: ReplaceTinyPivot integer(kind=C_INT), public :: SolveInitialized integer(kind=C_INT), public :: RefineInitialized integer(kind=C_INT), public :: PrintStat integer(kind=C_INT), public :: nnzL used to store nnzs for now integer(kind=C_INT), public :: nnzU used to store nnzs for now integer(kind=C_INT), public :: num_lookaheads num of levels in look-ahead integer(kind=C_INT), public :: lookahead_etree use etree computed from the serial symbolic factorization integer(kind=C_INT), public :: SymPattern symmetric factorization type, public :: SULU_ENV Global type for SuperLU which covers all the stuff needed Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n system size integer(kind=C_INT), public :: nrhs number of right hand sides integer(kind=C_INT), public :: nz number on non-zero entries integer(kind=C_INT), public :: info info returned by dgssvx integer(kind=C_INT), public :: lwork size of workspace, not used here logical(kind=I4), public :: first if false the system has been factorized at least once real(kind=R8), public, dimension(:), pointer :: b right hand side: points to b real(kind=R8), public, allocatable, dimension(:) :: x solution real(kind=R8), public, dimension(:), pointer :: a_elt CC system matrix: points to a_elt integer(kind=I4), public, dimension(:), pointer :: irow matrix line of an a_elt element: points to irow integer(kind=I4), public, dimension(:), pointer :: jptr matrix column pointers: points to jptr real(kind=C_DOUBLE), public, allocatable, dimension(:) :: ferr estimated forward error bound for each solution vector real(kind=C_DOUBLE), public, allocatable, dimension(:) :: berr componentwise relative backward error of each solution real(kind=C_DOUBLE), public, allocatable, dimension(:) :: RR *row scale factors for A * real(kind=C_DOUBLE), public, allocatable, dimension(:) :: CC column scale factors for A real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rpg reciprocal pivot growth factor real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rcond estimate of the reciprocal condition number of the matrix A integer(kind=C_INT), public, allocatable, dimension(:) :: perm_c If A->Stype = SLU_NC , Column permutation vector of size A->ncol integer(kind=C_INT), public, allocatable, dimension(:) :: perm_r If A->Stype = SLU_NC , row permutation vector of size A->nrow integer(kind=C_INT), public, allocatable, dimension(:) :: etree Elimination tree character(kind=len=1,C_CHAR), public :: equed form of equilibration type(C_PTR), public :: work User supplied workspace type( SUPERLU_OPTIONS_T ), public :: options LU controls type( SUPERMATRIX ), public :: sma Matrix A in A X=B* type( SUPERMATRIX ), public :: smb On entry, the right hand side matrix type( SUPERMATRIX ), public :: smx olution matrix to the original system type( SUPERMATRIX ), public :: sml factor L from the factorization type( SUPERMATRIX ), public :: smu factor U from the factorization type( SUPERLUSTAT_T ), public :: stat statistics on runtime and floating-point operation count type( GLOBALLU_T ), public :: Glu first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity type( MEM_USAGE_T ), public :: mem_usage memory usage statistics Subroutines public subroutine init_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public subroutine prep_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public subroutine fact_superlu (sulu, verbose) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose public subroutine solv_superlu (sol_x, sulu, verbose) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(:) :: sol_x type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose public subroutine free_superlu () Read more… Arguments None public subroutine close_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu","tags":""},{"title":"mumfpack – MSOLV-fortran","loc":"module/mumfpack.html","text":"Uses iso_c_binding module~~mumfpack~~UsesGraph module~mumfpack mumfpack iso_c_binding iso_c_binding module~mumfpack->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mumfpack~~UsedByGraph module~mumfpack mumfpack module~solver solver module~solver->module~mumfpack program~test_solvers test_solvers program~test_solvers->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i4 i8 ip r4 r8 iSymbolic iNumeric UMFPACK_INFO UMFPACK_CONTROL UMFPACK_VERSION UMFPACK_COPYRIGHT UMFPACK_DATE UMFPACK_MAIN_VERSION UMFPACK_SUB_VERSION UMFPACK_SUBSUB_VERSION Enumerations Interfaces c_umfpack_di_symbolic c_umfpack_zi_symbolic c_umfpack_di_numeric c_umfpack_zi_numeric c_umfpack_di_solve c_umfpack_zi_solve c_umfpack_di_scale c_umfpack_zi_scale c_umfpack_di_save_numeric c_umfpack_zi_save_numeric c_umfpack_di_save_symbolic c_umfpack_zi_save_symbolic c_umfpack_di_load_numeric c_umfpack_zi_load_numeric c_umfpack_di_load_symbolic c_umfpack_zi_load_symbolic c_umfpack_di_report_numeric c_umfpack_zi_report_numeric c_umfpack_di_report_symbolic c_umfpack_zi_report_symbolic c_umfpack_di_free_symbolic c_umfpack_zi_free_symbolic c_umfpack_di_free_numeric c_umfpack_zi_free_numeric c_umfpack_di_defaults c_umfpack_zi_defaults c_umfpack_di_report_status c_umfpack_zi_report_status c_umfpack_di_report_control c_umfpack_zi_report_control c_umfpack_di_report_info c_umfpack_zi_report_info umfpack_zi_symbolic s_umfpack_zi_symbolic umfpack_symbolic s_umfpack_symbolic umfpack_zi_numeric s_umfpack_zi_numeric umfpack_numeric s_umfpack_numeric umfpack_zi_solve s_umfpack_zi_solve umfpack_solve s_umfpack_solve s_umfpack_free_symbolic s_umfpack_di_free_symbolic s_umfpack_zi_free_symbolic s_umfpack_free_numeric s_umfpack_di_free_numeric s_umfpack_zi_free_numeric s_umfpack_defaults s_umfpack_di_defaults s_umfpack_zi_defaults umfpack_zi_scale umfpack_scale_function s_umfpack_zi_scale s_umfpack_scale s_umfpack_report_control s_umfpack_di_report_control s_umfpack_zi_report_control s_umfpack_report_info s_umfpack_di_report_info s_umfpack_zi_report_info umf4csym umf4zsym umf4sym umf4cnum umf4znum umf4num umf4csolr umf4zsolr umf4solr umf4csol umf4zsol umf4sol umf4cscal umf4zscal umf4scal umf4cfnum umf4zfnum umf4fnum umf4cfsym umf4zfsym umf4fsym umf4csnum umf4zsnum umf4snum umf4cssym umf4zssym umf4ssym umf4clnum umf4zlnum umf4lnum umf4clsym umf4zlsym umf4lsym pCSC pCSR pVec operator(.umfpack.) Derived Types tCSC_di tCSC_zi tCSC_ci tCSR_di tCSR_zi tCSR_ci tVec_zi pCSC_di pCSC_zi pCSC_ci pCSR_di pCSR_zi pCSR_ci pVec_zi Functions umfpack_di_symbolic umfpack_zi_symbolic umfpack_ci_symbolic umfpack_di_numeric umfpack_zi_numeric umfpack_ci_numeric umfpack_di_solve umfpack_zi_solve umfpack_ci_solve umfpack_di_scale umfpack_zi_scale umfpack_ci_scale umfpack_di_save_numeric umfpack_zi_save_numeric umfpack_save_numeric umfpack_di_save_symbolic umfpack_zi_save_symbolic umfpack_save_symbolic umfpack_di_load_numeric umfpack_zi_load_numeric umfpack_load_numeric umfpack_di_load_symbolic umfpack_zi_load_symbolic umfpack_load_symbolic umfpack_di_operator_CSC umfpack_zi_operator_CSC umfpack_ci_operator_CSC umfpack_di_operator_CSR umfpack_zi_operator_CSR umfpack_ci_operator_CSR umfpack_di_operator_pCSC umfpack_zi_operator_pCSC umfpack_ci_operator_pCSC umfpack_di_operator_pCSR umfpack_zi_operator_pCSR umfpack_ci_operator_pCSR make_CSC_di make_CSC_zi make_CSC_ci make_CSR_di make_CSR_zi make_CSR_ci make_Vec_zi Subroutines s_umfpack_di_symbolic s_umfpack_zi_symbolic s_umfpack_ci_symbolic s_umfpack_di_numeric s_umfpack_zi_numeric s_umfpack_ci_numeric s_umfpack_di_solve s_umfpack_zi_solve s_umfpack_ci_solve umfpack_di_free_symbolic umfpack_zi_free_symbolic umfpack_free_symbolic umfpack_di_free_numeric umfpack_zi_free_numeric umfpack_free_numeric s_umfpack_di_scale s_umfpack_zi_scale s_umfpack_ci_scale umfpack_di_defaults umfpack_zi_defaults umfpack_defaults umfpack_di_report_control umfpack_zi_report_control umfpack_report_control umfpack_di_report_info umfpack_zi_report_info umfpack_report_info s_umfpack_di_save_numeric s_umfpack_zi_save_numeric s_umfpack_save_numeric s_umfpack_di_save_symbolic s_umfpack_zi_save_symbolic s_umfpack_save_symbolic s_umfpack_di_load_numeric s_umfpack_zi_load_numeric s_umfpack_load_numeric s_umfpack_di_load_symbolic s_umfpack_zi_load_symbolic s_umfpack_load_symbolic umf4def umf4zdef umf4cdef umf4pcon umf4zpcon umf4cpcon umf4sym umf4zsym umf4csym umf4sym_ip umf4zsym_ip umf4csym_ip umf4num umf4znum umf4cnum umf4num_ip umf4znum_ip umf4cnum_ip umf4solr umf4zsolr umf4csolr umf4solr_ip umf4zsolr_ip umf4csolr_ip umf4sol umf4zsol umf4csol umf4sol_ip umf4zsol_ip umf4csol_ip umf4scal umf4zscal umf4cscal umf4scal_ip umf4zscal_ip umf4cscal_ip umf4pinf umf4zpinf umf4cpinf umf4fnum umf4zfnum umf4cfnum umf4fnum_ip umf4zfnum_ip umf4cfnum_ip umf4fsym umf4zfsym umf4cfsym umf4fsym_ip umf4zfsym_ip umf4cfsym_ip umf4snum umf4zsnum umf4csnum umf4snum_ip umf4zsnum_ip umf4csnum_ip umf4ssym umf4zssym umf4cssym umf4ssym_ip umf4zssym_ip umf4cssym_ip umf4lnum umf4zlnum umf4clnum umf4lnum_ip umf4zlnum_ip umf4clnum_ip umf4lsym umf4zlsym umf4clsym umf4lsym_ip umf4zlsym_ip umf4clsym_ip Variables Type Visibility Attributes Name Initial integer, private, parameter :: i4 = 4 integer, private, parameter :: i8 = 8 integer, private, parameter :: ip = c_intptr_t integer, private, parameter :: r4 = 4 integer, private, parameter :: r8 = 8 type(c_ptr), private :: iSymbolic = c_null_ptr type(c_ptr), private :: iNumeric = c_null_ptr integer, public, parameter :: UMFPACK_INFO = 90 integer, public, parameter :: UMFPACK_CONTROL = 20 character(len=30), public, parameter :: UMFPACK_VERSION = \"UMFPACK V5.6.2 (Apr 25, 2013)\" character(len=79), public, parameter :: UMFPACK_COPYRIGHT = \"UMFPACK:  Copyright (c) 2005-2012 by Timothy A. Davis.  All Rights Reserved.\" character(len=12), public, parameter :: UMFPACK_DATE = \"Apr 25, 2013\" integer, public, parameter :: UMFPACK_MAIN_VERSION = 5 integer, public, parameter :: UMFPACK_SUB_VERSION = 6 integer, public, parameter :: UMFPACK_SUBSUB_VERSION = 2 Enumerations enum, bind(c) Enumerators enumerator :: UMFPACK_STATUS = 0 enumerator :: UMFPACK_NROW = 1 enumerator :: UMFPACK_NCOL = 16 enumerator :: UMFPACK_NZ = 2 enumerator :: UMFPACK_SIZE_OF_UNIT = 3 enumerator :: UMFPACK_SIZE_OF_INT = 4 enumerator :: UMFPACK_SIZE_OF_LONG = 5 enumerator :: UMFPACK_SIZE_OF_POINTER = 6 enumerator :: UMFPACK_SIZE_OF_ENTRY = 7 enumerator :: UMFPACK_NDENSE_ROW = 8 enumerator :: UMFPACK_NEMPTY_ROW = 9 enumerator :: UMFPACK_NDENSE_COL = 10 enumerator :: UMFPACK_NEMPTY_COL = 11 enumerator :: UMFPACK_SYMBOLIC_DEFRAG = 12 enumerator :: UMFPACK_SYMBOLIC_PEAK_MEMORY = 13 enumerator :: UMFPACK_SYMBOLIC_SIZE = 14 enumerator :: UMFPACK_SYMBOLIC_TIME = 15 enumerator :: UMFPACK_SYMBOLIC_WALLTIME = 17 enumerator :: UMFPACK_STRATEGY_USED = 18 enumerator :: UMFPACK_ORDERING_USED = 19 enumerator :: UMFPACK_QFIXED = 31 enumerator :: UMFPACK_DIAG_PREFERRED = 32 enumerator :: UMFPACK_PATTERN_SYMMETRY = 33 enumerator :: UMFPACK_NZ_A_PLUS_AT = 34 enumerator :: UMFPACK_NZDIAG = 35 enumerator :: UMFPACK_SYMMETRIC_LUNZ = 36 enumerator :: UMFPACK_SYMMETRIC_FLOPS = 37 enumerator :: UMFPACK_SYMMETRIC_NDENSE = 38 enumerator :: UMFPACK_SYMMETRIC_DMAX = 39 enumerator :: UMFPACK_COL_SINGLETONS = 56 enumerator :: UMFPACK_ROW_SINGLETONS = 57 enumerator :: UMFPACK_N2 = 58 enumerator :: UMFPACK_S_SYMMETRIC = 59 enumerator :: UMFPACK_NUMERIC_SIZE_ESTIMATE = 20 enumerator :: UMFPACK_PEAK_MEMORY_ESTIMATE = 21 enumerator :: UMFPACK_FLOPS_ESTIMATE = 22 enumerator :: UMFPACK_LNZ_ESTIMATE = 23 enumerator :: UMFPACK_UNZ_ESTIMATE = 24 enumerator :: UMFPACK_VARIABLE_INIT_ESTIMATE = 25 enumerator :: UMFPACK_VARIABLE_PEAK_ESTIMATE = 26 enumerator :: UMFPACK_VARIABLE_FINAL_ESTIMATE = 27 enumerator :: UMFPACK_MAX_FRONT_SIZE_ESTIMATE = 28 enumerator :: UMFPACK_MAX_FRONT_NROWS_ESTIMATE = 29 enumerator :: UMFPACK_MAX_FRONT_NCOLS_ESTIMATE = 30 enumerator :: UMFPACK_NUMERIC_SIZE = 40 enumerator :: UMFPACK_PEAK_MEMORY = 41 enumerator :: UMFPACK_FLOPS = 42 enumerator :: UMFPACK_LNZ = 43 enumerator :: UMFPACK_UNZ = 44 enumerator :: UMFPACK_VARIABLE_INIT = 45 enumerator :: UMFPACK_VARIABLE_PEAK = 46 enumerator :: UMFPACK_VARIABLE_FINAL = 47 enumerator :: UMFPACK_MAX_FRONT_SIZE = 48 enumerator :: UMFPACK_MAX_FRONT_NROWS = 49 enumerator :: UMFPACK_MAX_FRONT_NCOLS = 50 enumerator :: UMFPACK_NUMERIC_DEFRAG = 60 enumerator :: UMFPACK_NUMERIC_REALLOC = 61 enumerator :: UMFPACK_NUMERIC_COSTLY_REALLOC = 62 enumerator :: UMFPACK_COMPRESSED_PATTERN = 63 enumerator :: UMFPACK_LU_ENTRIES = 64 enumerator :: UMFPACK_NUMERIC_TIME = 65 enumerator :: UMFPACK_UDIAG_NZ = 66 enumerator :: UMFPACK_RCOND = 67 enumerator :: UMFPACK_WAS_SCALED = 68 enumerator :: UMFPACK_RSMIN = 69 enumerator :: UMFPACK_RSMAX = 70 enumerator :: UMFPACK_UMIN = 71 enumerator :: UMFPACK_UMAX = 72 enumerator :: UMFPACK_ALLOC_INIT_USED = 73 enumerator :: UMFPACK_FORCED_UPDATES = 74 enumerator :: UMFPACK_NUMERIC_WALLTIME = 75 enumerator :: UMFPACK_NOFF_DIAG = 76 enumerator :: UMFPACK_ALL_LNZ = 77 enumerator :: UMFPACK_ALL_UNZ = 78 enumerator :: UMFPACK_NZDROPPED = 79 enumerator :: UMFPACK_IR_TAKEN = 80 enumerator :: UMFPACK_IR_ATTEMPTED = 81 enumerator :: UMFPACK_OMEGA1 = 82 enumerator :: UMFPACK_OMEGA2 = 83 enumerator :: UMFPACK_SOLVE_FLOPS = 84 enumerator :: UMFPACK_SOLVE_TIME = 85 enumerator :: UMFPACK_SOLVE_WALLTIME = 86 enum, bind(c) Enumerators enumerator :: UMFPACK_PRL = 0 enumerator :: UMFPACK_DENSE_ROW = 1 enumerator :: UMFPACK_DENSE_COL = 2 enumerator :: UMFPACK_BLOCK_SIZE = 4 enumerator :: UMFPACK_STRATEGY = 5 enumerator :: UMFPACK_ORDERING = 10 enumerator :: UMFPACK_FIXQ = 13 enumerator :: UMFPACK_AMD_DENSE = 14 enumerator :: UMFPACK_AGGRESSIVE = 19 enumerator :: UMFPACK_SINGLETONS = 11 enumerator :: UMFPACK_PIVOT_TOLERANCE = 3 enumerator :: UMFPACK_ALLOC_INIT = 6 enumerator :: UMFPACK_SYM_PIVOT_TOLERANCE = 15 enumerator :: UMFPACK_SCALE = 16 enumerator :: UMFPACK_FRONT_ALLOC_INIT = 17 enumerator :: UMFPACK_DROPTOL = 18 enumerator :: UMFPACK_IRSTEP = 7 enumerator :: UMFPACK_COMPILED_WITH_BLAS = 8 enum, bind(c) Enumerators enumerator :: UMFPACK_STRATEGY_AUTO = 0 enumerator :: UMFPACK_STRATEGY_UNSYMMETRIC = 1 enumerator :: UMFPACK_STRATEGY_OBSOLETE = 2 enumerator :: UMFPACK_STRATEGY_SYMMETRIC = 3 enum, bind(c) Enumerators enumerator :: UMFPACK_SCALE_NONE = 0 enumerator :: UMFPACK_SCALE_SUM = 1 enumerator :: UMFPACK_SCALE_MAX = 2 enum, bind(c) Enumerators enumerator :: UMFPACK_ORDERING_CHOLMOD = 0 enumerator :: UMFPACK_ORDERING_AMD = 1 enumerator :: UMFPACK_ORDERING_GIVEN = 2 enumerator :: UMFPACK_ORDERING_METIS = 3 enumerator :: UMFPACK_ORDERING_BEST = 4 enumerator :: UMFPACK_ORDERING_NONE = 5 enumerator :: UMFPACK_ORDERING_USER = 6 enum, bind(c) Enumerators enumerator :: UMFPACK_OK = 0 enumerator :: UMFPACK_WARNING_singular_matrix = 1 enumerator :: UMFPACK_WARNING_determinant_underflow = 2 enumerator :: UMFPACK_WARNING_determinant_overflow = 3 enumerator :: UMFPACK_ERROR_out_of_memory = -1 enumerator :: UMFPACK_ERROR_invalid_Numeric_object = -3 enumerator :: UMFPACK_ERROR_invalid_Symbolic_object = -4 enumerator :: UMFPACK_ERROR_argument_missing = -5 enumerator :: UMFPACK_ERROR_n_nonpositive = -6 enumerator :: UMFPACK_ERROR_invalid_matrix = -8 enumerator :: UMFPACK_ERROR_different_pattern = -11 enumerator :: UMFPACK_ERROR_invalid_system = -13 enumerator :: UMFPACK_ERROR_invalid_permutation = -15 enumerator :: UMFPACK_ERROR_internal_error = -911 enumerator :: UMFPACK_ERROR_file_IO = -17 enumerator :: UMFPACK_ERROR_ordering_failed = -18 enum, bind(c) Enumerators enumerator :: UMFPACK_A = 0 enumerator :: UMFPACK_At = 1 enumerator :: UMFPACK_Aat = 2 enumerator :: UMFPACK_Pt_L = 3 enumerator :: UMFPACK_L = 4 enumerator :: UMFPACK_Lt_P = 5 enumerator :: UMFPACK_Lat_P = 6 enumerator :: UMFPACK_Lt = 7 enumerator :: UMFPACK_Lat = 8 enumerator :: UMFPACK_U_Qt = 9 enumerator :: UMFPACK_U = 10 enumerator :: UMFPACK_Q_Ut = 11 enumerator :: UMFPACK_Q_Uat = 12 enumerator :: UMFPACK_Ut = 13 enumerator :: UMFPACK_Uat = 14 Interfaces interface public function c_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) bind(c,name='umfpack_di_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) bind(c,name='umfpack_zi_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_di_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_zi_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) bind(c,name='umfpack_di_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) bind(c,name='umfpack_zi_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_di_scale(X, B, Numeric) bind(c,name='umfpack_di_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int) interface public function c_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) bind(c,name='umfpack_zi_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int) interface public function c_umfpack_di_save_numeric(Numeric, filename) bind(c,name='umfpack_di_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_save_numeric(Numeric, filename) bind(c,name='umfpack_zi_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_save_symbolic(Symbolic, filename) bind(c,name='umfpack_di_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_save_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_load_numeric(Numeric, filename) bind(c,name='umfpack_di_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_load_numeric(Numeric, filename) bind(c,name='umfpack_zi_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_load_symbolic(Symbolic, filename) bind(c,name='umfpack_di_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_load_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_report_numeric(Numeric, Control) bind(c,name='umfpack_di_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public function c_umfpack_zi_report_numeric(Numeric, Control) bind(c,name='umfpack_zi_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public function c_umfpack_di_report_symbolic(Symbolic, Control) bind(c,name='umfpack_di_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public function c_umfpack_zi_report_symbolic(Symbolic, Control) bind(c,name='umfpack_zi_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public subroutine c_umfpack_di_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic interface public subroutine c_umfpack_zi_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic interface public subroutine c_umfpack_di_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric interface public subroutine c_umfpack_zi_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric interface public subroutine c_umfpack_di_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_zi_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_di_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status interface public subroutine c_umfpack_zi_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status interface public subroutine c_umfpack_di_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_zi_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_di_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info interface public subroutine c_umfpack_zi_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info public interface umfpack_zi_symbolic public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_zi_symbolic public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_symbolic public function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_symbolic public subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_zi_numeric public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_zi_numeric public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_numeric public function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_numeric public subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_zi_solve public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_zi_solve public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_solve public function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_solve public subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_free_symbolic public subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version public interface s_umfpack_di_free_symbolic public subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public interface s_umfpack_zi_free_symbolic public subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public interface s_umfpack_free_numeric public subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version public interface s_umfpack_di_free_numeric public subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public interface s_umfpack_zi_free_numeric public subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public interface s_umfpack_defaults public subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public interface s_umfpack_di_defaults public subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface s_umfpack_zi_defaults public subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface umfpack_zi_scale public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface umfpack_scale_function public function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface s_umfpack_zi_scale public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_scale public subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_report_control public subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public interface s_umfpack_di_report_control public subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface s_umfpack_zi_report_control public subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface s_umfpack_report_info public subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version public interface s_umfpack_di_report_info public subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public interface s_umfpack_zi_report_info public subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public interface umf4csym public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsym public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4sym public interface umf4sym () Arguments None public subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4znum public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4num public interface umf4num () Arguments None public subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsolr public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4solr public interface umf4solr () Arguments None public subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsol public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4sol public interface umf4sol () Arguments None public subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cscal public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4zscal public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4scal public interface umf4scal () Arguments None public subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cfnum public interface umf4cfnum () Arguments None public subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public interface umf4zfnum public interface umf4zfnum () Arguments None public subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public interface umf4fnum public interface umf4fnum () Arguments None public subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public interface umf4cfsym public interface umf4cfsym () Arguments None public subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public interface umf4zfsym public interface umf4zfsym () Arguments None public subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public interface umf4fsym public interface umf4fsym () Arguments None public subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public interface umf4csnum public interface umf4csnum () Arguments None public subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zsnum public interface umf4zsnum () Arguments None public subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4snum public interface umf4snum () Arguments None public subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4cssym public interface umf4cssym () Arguments None public subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zssym public interface umf4zssym () Arguments None public subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4ssym public interface umf4ssym () Arguments None public subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4clnum public interface umf4clnum () Arguments None public subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zlnum public interface umf4zlnum () Arguments None public subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4lnum public interface umf4lnum () Arguments None public subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4clsym public interface umf4clsym () Arguments None public subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zlsym public interface umf4zlsym () Arguments None public subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4lsym public interface umf4lsym () Arguments None public subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface pCSC public function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) public interface pCSR public function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) public interface pVec public function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) public interface operator(.umfpack.) public function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Derived Types type, public :: tCSC_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) type, public :: tCSC_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:) type, public :: tCSC_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:) type, public :: tCSR_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) type, public :: tCSR_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:) type, public :: tCSR_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:) type, public :: tVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, allocatable :: x (:) real(kind=r8), public, allocatable :: z (:) type, public :: pCSC_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) type, public :: pCSC_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:) type, public :: pCSC_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:) type, public :: pCSR_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) type, public :: pCSR_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:) type, public :: pCSR_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:) type, public :: pVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, pointer :: x (:) real(kind=r8), public, pointer :: z (:) Functions public function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), optional target :: Az (*) real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public function umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public function umfpack_di_save_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_save_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_save_numeric (Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_save_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_save_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_save_symbolic (Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_load_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_load_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_load_numeric (Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_load_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_load_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_load_symbolic (Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) public function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) public function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) Subroutines public subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in), optional :: Az (*) real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version public subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version public subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public subroutine s_umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version public subroutine s_umfpack_di_save_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_save_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_save_numeric (Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine s_umfpack_di_save_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_save_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_save_symbolic (Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine s_umfpack_di_load_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_load_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_load_numeric (Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine s_umfpack_di_load_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_load_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_load_symbolic (Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine umf4def (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4zdef (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4cdef (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4pcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4zpcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4cpcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4sym (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsym (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csym (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4num (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4znum (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4cnum (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4solr (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsolr (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csolr (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4sol (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsol (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csol (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4scal (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status public subroutine umf4zscal (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric integer, intent(out) :: status public subroutine umf4cscal (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status public subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public subroutine umf4pinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zpinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4cpinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4fnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public subroutine umf4zfnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public subroutine umf4cfnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public subroutine umf4fsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public subroutine umf4zfsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public subroutine umf4cfsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public subroutine umf4snum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zsnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4csnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4ssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4cssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":""},{"title":"num_param – MSOLV-fortran","loc":"module/num_param.html","text":"MUSST general parameters Note The type NUM_PAR is not used in MSOLV , it is a type related to the iterative process of MUSST Uses iso_fortran_env data_arch module~~num_param~~UsesGraph module~num_param num_param module~data_arch data_arch module~num_param->module~data_arch iso_fortran_env iso_fortran_env module~num_param->iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~num_param~~UsedByGraph module~num_param num_param program~test_solvers test_solvers program~test_solvers->module~num_param module~solver solver program~test_solvers->module~solver module~solver->module~num_param Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables NO_MESS PRINT_MESS SOLV_MESS OPU IPU VERBOSE OUTPUT_FILE Derived Types NUM_PAR Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: NO_MESS = 0 code for no message on screen during problem solving integer(kind=I4), public, parameter :: PRINT_MESS = 1 code for printing message during problem solving integer(kind=I4), public :: SOLV_MESS Solver output detail control integer(kind=I4), public :: OPU = output_unit Output unit integer(kind=I4), public :: IPU = input_unit Input unit integer(kind=I4), public :: VERBOSE Output detail control character(len=128), public :: OUTPUT_FILE When needed, output file Derived Types type, public :: NUM_PAR Components Type Visibility Attributes Name Initial real(kind=R8), public :: relax relaxation parameter real(kind=R8), public :: eps error for convergence integer(kind=I4), public :: it_max maximal number of iterations integer(kind=I4), public :: mess message integer(kind=I4), public :: free_threads number of free threads in case of open_MP computation","tags":""},{"title":"data_arch – MSOLV-fortran","loc":"module/data_arch.html","text":"General type definition Uses iso_fortran_env module~~data_arch~~UsesGraph module~data_arch data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~data_arch~~UsedByGraph module~data_arch data_arch module~sort_arrays sort_arrays module~sort_arrays->module~data_arch program~test_solvers test_solvers program~test_solvers->module~data_arch module~solver solver program~test_solvers->module~solver module~num_param num_param program~test_solvers->module~num_param module~solver->module~data_arch module~solver->module~sort_arrays module~solver->module~num_param module~num_param->module~data_arch Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables I4 I8 R4 R8 IN_U OUT_U ERR_U HIG_I4 PI_R4 PI_R8 EPS_R4 EPS_R8 HIG_R8 HIG_E8 EPS_E8 EXPO_MAX NB_THREADS_MAX Subroutines get_unit Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: I4 = int32 integer(kind=I4), public, parameter :: I8 = int64 integer(kind=I4), public, parameter :: R4 = real32 integer(kind=I4), public, parameter :: R8 = real64 integer(kind=I4), public, parameter :: IN_U = input_unit integer(kind=I4), public, parameter :: OUT_U = output_unit integer(kind=I4), public, parameter :: ERR_U = error_unit integer(kind=I4), public, parameter :: HIG_I4 = huge(1) real(kind=R4), public, parameter :: PI_R4 = acos(-1._R4) real(kind=R8), public, parameter :: PI_R8 = acos(-1._R8) real(kind=R4), public, parameter :: EPS_R4 = tiny(1._R4) real(kind=R8), public, parameter :: EPS_R8 = tiny(1._R8) real(kind=R8), public, parameter :: HIG_R8 = huge(1._R8) real(kind=R8), public, parameter :: HIG_E8 = log(HIG_R8) real(kind=R8), public, parameter :: EPS_E8 = log(EPS_R8) integer(kind=I4), public, parameter :: EXPO_MAX = exponent(HIG_R8) integer(kind=I4), public :: NB_THREADS_MAX Subroutines public subroutine get_unit (iunit) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out) :: iunit","tags":""},{"title":"sort_arrays – MSOLV-fortran","loc":"module/sort_arrays.html","text":"Various routines to sort real/integer arrays Uses data_arch module~~sort_arrays~~UsesGraph module~sort_arrays sort_arrays module~data_arch data_arch module~sort_arrays->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~sort_arrays~~UsedByGraph module~sort_arrays sort_arrays module~solver solver module~solver->module~sort_arrays program~test_solvers test_solvers program~test_solvers->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines sort_real_1real sort_real_2real sort_int_1int_1real sort_int_1real Subroutines public recursive subroutine sort_real_1real (g, d, rtabref, rtab1) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 public recursive subroutine sort_real_2real (g, d, rtabref, rtab1, rtab2) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 public recursive subroutine sort_int_1int_1real (g, d, itabref, itab1, rtab2) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref integer(kind=I4), intent(inout), dimension(:) :: itab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 public recursive subroutine sort_int_1real (g, d, itabref, rtab1) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref real(kind=R8), intent(inout), dimension(:) :: rtab1","tags":""},{"title":"test_solvers – MSOLV-fortran","loc":"program/test_solvers.html","text":"Uses omp_lib data_arch num_param solver program~~test_solvers~~UsesGraph program~test_solvers test_solvers omp_lib omp_lib program~test_solvers->omp_lib module~data_arch data_arch program~test_solvers->module~data_arch module~solver solver program~test_solvers->module~solver module~num_param num_param program~test_solvers->module~num_param iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~solver->module~data_arch module~solver->module~num_param iso_c_binding iso_c_binding module~solver->iso_c_binding module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~mumfpack mumfpack module~solver->module~mumfpack module~sort_arrays sort_arrays module~solver->module~sort_arrays module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~num_param->module~data_arch module~num_param->iso_fortran_env module~sulu_wrapper->iso_c_binding module~mumfpack->iso_c_binding module~sort_arrays->module~data_arch Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. MSOLV example of use Note The program asks first for the matrix size: 1 for a very small matrix, and 0 for a bigger one.The systems are CC HB format systems with elemental matrices. Small system – nnz=18 The system is (example provided by MUMP): A1 = \\begin{pmatrix}\n           -1 & 2 & 3 \\\\\n            2 & 1 & 1 \\\\\n            1 & 1 & 1\n          \\end{pmatrix} ~\n    A2 = \\begin{pmatrix}\n            2 & -1 &  3 \\\\\n            1 &  2 & -1 \\\\\n            3 &  2 &  1\n         \\end{pmatrix}  \\\\ \\text{ } \\\\\n \\rightarrow a\\_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) \\\\ \\text{ } \\\\\n  A = \\begin{pmatrix}\n           -1 & 2 & 3 & 0 & 0 \\\\\n            2 & 1 & 1 & 0 & 0 \\\\\n            1 & 1 & 3 &-1 & 3 \\\\\n            0 & 0 & 1 & 2 &-1 \\\\\n            0 & 0 & 3 & 2 & 1\n      \\end{pmatrix}  \\\\ \\text{ } \\\\\n \\rightarrow eltvar = (1, 2, 3, 3, 4, 5) \\text{ and } eltptr = (1, 4, 7) eltvar locates the elemental matrix line in the assembled matrix eltptr gives the elemental matrix first entry position in eltvar (last position being size( eltvar )+1) The rhs is (12, 7, 23, 6, 22), and the solution (1, 2, 3, 4, 5) Big (well, in fact, medium) system – nnz=2,097,152 The system results from a MUSST study case and there is of course no theoretical solution to compare with Warning Some solver implementation are C written, so the arrays may begin at 0. It explains the variable dec in prod_a_x Calls program~~test_solvers~~CallsGraph program~test_solvers test_solvers proc~convert_matrice_format convert_matrice_format program~test_solvers->proc~convert_matrice_format proc~solve_syst solve_syst program~test_solvers->proc~solve_syst omp_get_wtime omp_get_wtime program~test_solvers->omp_get_wtime proc~get_unit get_unit program~test_solvers->proc~get_unit proc~verif_solution verif_solution program~test_solvers->proc~verif_solution proc~modify_a_elt modify_a_elt program~test_solvers->proc~modify_a_elt proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~prod_a_x prod_a_x proc~verif_solution->proc~prod_a_x proc~prod_elemental_x prod_elemental_x proc~verif_solution->proc~prod_elemental_x mpi_finalize mpi_finalize proc~solution_solver->mpi_finalize proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu dmumps dmumps proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~factorize_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~close_solver->dmumps proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~analyse_solver->dmumps proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~init_solver->mpi_finalize mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~init_solver->dmumps ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~close_superlu->interface~destroy_compcol_matrix interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric var panprogramtest_solversCallsGraph = svgPanZoom('#programtest_solversCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i ii uu size_a_elt state time1 time2 error slv_struct b a_elt a_elt_ref eltptr eltvar Subroutines verif_solution modify_a_elt prod_a_x prod_elemental_x Source Code test_solvers Variables Type Attributes Name Initial integer(kind=I4) :: i integer(kind=I4) :: ii integer(kind=I4) :: uu integer(kind=I4) :: size_a_elt integer(kind=I4) :: state real(kind=R8) :: time1 real(kind=R8) :: time2 real(kind=R8) :: error type( MAT_SOLV ) :: slv_struct real(kind=R8), dimension(:), allocatable :: b system right hand side real(kind=R8), dimension(:), allocatable :: a_elt matrix non-zero entries in CC real(kind=R8), dimension(:), allocatable :: a_elt_ref initial a_elt integer(kind=I4), dimension(:), allocatable :: eltptr elemental matrices position in eltvar integer(kind=I4), dimension(:), allocatable :: eltvar elemental matrix global lines Subroutines subroutine verif_solution (slv_struct, a_elt, b, error) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(in) :: slv_struct real(kind=R8), intent(in), dimension(:) :: a_elt real(kind=R8), intent(in), dimension(:) :: b real(kind=R8), intent(out) :: error subroutine modify_a_elt (tab, nz) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout) :: tab (1:nz) integer(kind=I4), intent(in) :: nz subroutine prod_a_x (n, nz, x, y, a_elt, irow, jptr, slvt) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz) :: a_elt integer(kind=I4), intent(in), dimension(nz ) :: irow integer(kind=I4), intent(in), dimension(n+1) :: jptr integer(kind=I4), intent(in) :: slvt subroutine prod_elemental_x (n, nz, nelt, nvar, x, y, a_elt, eltptr, eltvar) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz integer(kind=I4), intent(in) :: nelt integer(kind=I4), intent(in) :: nvar real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz     ) :: a_elt integer(kind=I4), intent(in), dimension(nelt +1) :: eltptr integer(kind=I4), intent(in), dimension(nvar   ) :: eltvar Source Code program test_solvers use omp_lib , only : omp_get_wtime use data_arch , only : I4 , R4 , R8 , get_unit use num_param , only : OPU , & ! *default output unit* IPU , & ! *default input unit* SOLV_MESS , & ! *Solver message: yes=```PRINT_MESS```, no=```NO_MESS```* NO_MESS , & ! *no output message* PRINT_MESS ! *solver infos output* use solver , only : MAT_SOLV , & ! *system data type* solve_syst , & ! *subroutine for the system resolution* MUMP , & ! *integer* UMFP , & ! *integer* SULU , & ! *integer* convert_matrice_format ! *various matrix format conversion* implicit none integer ( kind = I4 ) :: i , ii , uu , size_a_elt , state real ( kind = R8 ) :: time1 , time2 , error type ( MAT_SOLV ) :: slv_struct real ( kind = R8 ), dimension (:), allocatable :: b !! *system right hand side* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *matrix non-zero entries in CC* real ( kind = R8 ), dimension (:), allocatable :: a_elt_ref !! *initial ```a_elt```* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *elemental matrices position in ```eltvar```* integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *elemental matrix global lines* SOLV_MESS = NO_MESS !PRINT_MESS! write ( OPU , * ) 'small matrix? 0:n, 1:y' read ( IPU , * ) i ! ======================== SOLVER TYPE =========================================== do write ( OPU , * ) 'data read, choose solver n° : 0-MA48, 1-SULU, 2-MUMP (ref), 3-UMFP' read ( IPU , * ) ii slv_struct % slv_t = ii if ( ii >= 0 . and . ii <= 3 ) exit enddo ! ======================== SYST DATA READ =========================================== call get_unit ( uu ) if ( i == 0 ) then open ( uu , file = \"mat/big_syst.sys\" ) else open ( uu , file = \"mat/small_syst.sys\" ) endif ! ======================== SYST INFO =========================================== read ( uu , * ) slv_struct % nn , slv_struct % ne , slv_struct % nvar , slv_struct % nt write ( OPU , * ) '*************** INFO ********************' write ( OPU , * ) 'system size:                  ' , slv_struct % nn write ( OPU , * ) 'number of elemental matrices: ' , slv_struct % ne write ( OPU , * ) 'number of nnz entries:        ' , slv_struct % nt write ( OPU , * ) '*****************************************' slv_struct % first = . true . allocate ( eltvar ( slv_struct % nvar ) ) allocate ( a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( a_elt_ref ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( eltptr ( slv_struct % ne + 1 ) ) allocate ( b ( slv_struct % nn ) ) allocate ( slv_struct % eltvar ( slv_struct % nvar ) ) allocate ( slv_struct % a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( slv_struct % eltptr ( slv_struct % ne + 1 ) ) call solve_syst ( mat = slv_struct , step = 'ini' ) do ii = 1 , slv_struct % nvar read ( uu , * ) slv_struct % eltvar ( ii ) enddo do ii = 1 , slv_struct % ne + 1 read ( uu , * ) slv_struct % eltptr ( ii ) enddo do ii = 1 , slv_struct % nt read ( uu , * ) slv_struct % a_elt ( ii ) enddo do ii = 1 , slv_struct % nn read ( uu , * ) slv_struct % b ( ii ) enddo close ( uu ) ! The matrices are in CC HB format. Only MUMPS accepts elemental entries, so the ! following subroutine converts elemental marices to assembled vectors. ! If MUMPS is chosen, nothing is done. call convert_matrice_format ( mat = slv_struct ) ! ======================== backup ============================================ eltvar = slv_struct % eltvar a_elt_ref = slv_struct % a_elt eltptr = slv_struct % eltptr b = slv_struct % b ! ======================== PROCESS =========================================== time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'ana' ) ; write ( OPU , * ) 'system analyzed' ; slv_struct % first = . false . call solve_syst ( mat = slv_struct , step = 'fac' ) ; write ( OPU , * ) 'system factorized' call solve_syst ( mat = slv_struct , step = 'sol' ) ; write ( OPU , * ) 'system solved' call solve_syst ( mat = slv_struct , step = 'fre' ) ; write ( OPU , * ) 'system freed' time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt_ref , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) ! Here, the matrix coefficients are modified, but the sparsity is conserved. It gives a look to the ability ! of the solver to exploit the symbolic calculations performed before. do if ( slv_struct % slv_t == MUMP ) then size_a_elt = size ( slv_struct % a_elt ) else size_a_elt = slv_struct % nt endif ! the original entries are retrieved, then modified a_elt = a_elt_ref call modify_a_elt ( tab = a_elt , nz = size_a_elt ) slv_struct % a_elt = a_elt slv_struct % b = b slv_struct % x = 0._R8 time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'fac' ) call solve_syst ( mat = slv_struct , step = 'sol' ) call solve_syst ( mat = slv_struct , step = 'fre' ) time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) write ( OPU , * ) 'STOP? (y=1, n=0)' read ( IPU , * ) ii if ( ii == 1 ) exit enddo deallocate ( eltvar , a_elt , a_elt_ref , eltptr , b ) call solve_syst ( mat = slv_struct , step = 'end' ) stop contains !========================================================================================= !< @note The product \\{y\\} of the system matrix [A] by the solution \\{x\\}, is !        calculated, and compared to the right hand side \\{b\\}. !        The calculated error is the absolute error in %. !----------------------------------------------------------------------------------------- subroutine verif_solution ( slv_struct , a_elt , b , error ) implicit none type ( MAT_SOLV ), intent ( in ) :: slv_struct real ( kind = R8 ), dimension (:), intent ( in ) :: a_elt real ( kind = R8 ), dimension (:), intent ( in ) :: b real ( kind = R8 ), intent ( out ) :: error real ( kind = R8 ), dimension ( slv_struct % nn ) :: y ! to assess the accuracy, the solution is applied to the ! system matrix and compared to the rhs. if ( slv_struct % slv_t == MUMP ) then call prod_elemental_x ( n = slv_struct % nn , & nz = slv_struct % nt , & nelt = slv_struct % ne , & nvar = slv_struct % nvar , & x = slv_struct % x , & y = y , & a_elt = a_elt , & eltptr = slv_struct % eltptr , & eltvar = slv_struct % eltvar ) else call prod_a_x ( n = slv_struct % nn , & nz = slv_struct % nz , & x = slv_struct % x , & y = y , & a_elt = a_elt , & irow = slv_struct % irow , & jptr = slv_struct % jptr , & slvt = slv_struct % slv_t ) endif error = 100 * maxval ( abs ( y ( 1 : slv_struct % nn ) - b ( 1 : slv_struct % nn )) ) / & maxval ( abs ( y ( 1 : slv_struct % nn ) + b ( 1 : slv_struct % nn )) ) return endsubroutine verif_solution !========================================================================================= !> @note multiplication of the system coefficient by a random factor !----------------------------------------------------------------------------------------- subroutine modify_a_elt ( tab , nz ) implicit none integer ( kind = I4 ), intent ( in ) :: nz real ( kind = R8 ), intent ( inout ) :: tab ( 1 : nz ) real ( kind = R8 ), allocatable :: tmp (:) allocate ( tmp ( 1 : nz )) call random_number ( harvest = tmp ( 1 : nz )) tmp ( 1 : nz ) = 2 * tmp ( 1 : nz ) - 1.0_R8 tab ( 1 : nz ) = tab ( 1 : nz ) * tmp ( 1 : nz ) deallocate ( tmp ) return endsubroutine modify_a_elt !========================================================================================= !> @note [A] \\{x\\}, assembled CC format !----------------------------------------------------------------------------------------- subroutine prod_a_x ( n , nz , x , y , a_elt , irow , jptr , slvt ) implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , slvt real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nz ), intent ( in ) :: irow integer ( kind = I4 ), dimension ( n + 1 ), intent ( in ) :: jptr real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , k , dec y ( 1 : n ) = 0._R8 dec = 0 if ( slvt == UMFP . or . slvt == SULU ) dec = 1 do i = 1 , n do k = jptr ( i ), jptr ( i + 1 ) - 1 y ( irow ( k + dec ) + dec ) = y ( irow ( k + dec ) + dec ) + x ( i ) * a_elt ( k + dec ) enddo enddo return endsubroutine prod_a_x !========================================================================================= !> @note [A] \\{x\\}, elemental CC format !----------------------------------------------------------------------------------------- subroutine prod_elemental_x ( n , nz , nelt , nvar , x , y , a_elt , eltptr , eltvar ) implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , nelt , nvar real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nelt + 1 ), intent ( in ) :: eltptr integer ( kind = I4 ), dimension ( nvar ), intent ( in ) :: eltvar real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , j , k , kk , inc_nz , inc_nn , n_elem , i_elem , max_n_elem real ( kind = R8 ), dimension (:), allocatable :: a_elt_tmp , x_tmp , y_tmp inc_nz = 0 inc_nn = 0 n_elem = 0 y = 0._R8 max_n_elem = 0 do i_elem = 1 , nelt max_n_elem = max ( max_n_elem , eltptr ( i_elem + 1 ) - eltptr ( i_elem )) enddo allocate ( a_elt_tmp ( 1 : max_n_elem ** 2 ) ) allocate ( x_tmp ( 1 : max_n_elem ) ) allocate ( y_tmp ( 1 : max_n_elem ) ) do i_elem = 1 , nelt ! browse all elemental matrices inc_nn = inc_nn + n_elem ! step in eltvar for matrix number i_elem inc_nz = inc_nz + n_elem ** 2 ! step in a_elt for matrix number i_elem n_elem = eltptr ( i_elem + 1 ) - eltptr ( i_elem ) ! elemental matrix size a_elt_tmp ( 1 : n_elem ** 2 ) = a_elt ( inc_nz + 1 : inc_nz + n_elem ** 2 ) ! elemental matrix coefficients ! --- elemental rhs kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 x_tmp ( kk ) = x ( eltvar ( k )) enddo ! --- elemental product y_tmp ( 1 : n_elem ) = 0._R8 do i = 1 , n_elem do j = 1 , n_elem y_tmp ( i ) = y_tmp ( i ) + a_elt_tmp ( i + n_elem * ( j - 1 )) * x_tmp ( j ) enddo enddo ! --- elemental product in global vector y kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 y ( eltvar ( k )) = y ( eltvar ( k )) + y_tmp ( kk ) enddo enddo deallocate ( a_elt_tmp , x_tmp , y_tmp ) return endsubroutine prod_elemental_x endprogram test_solvers","tags":""}]}